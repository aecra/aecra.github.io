
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"content":"什么是 ClashForWindows ClashForWindows 是一个开源的 Clash 的图形化界面，可以在 Windows 上使用。既然看了这篇文章，那就意味着你已经知道 Clash 是什么了，所以这里就不再赘述了。\n安装 我选择的是使用 scoop 安装，因为我觉得这样比较方便。scoop 是 Windows 平台的软件管理工具，可以看看查看官网 scoop.sh。\n# 添加 scoop bucket scoop bucket add yixuju https://github.com/yi-Xu-0100/scoop-bucket # 安装 scoop install yuxuju/ClashForWindows 问题 什么样的使用方式问题最少 因为做开发的缘故，知名的项目地址在国内都难以访问，经常需要设置镜像源，同时因为毒瘤的 Python 在使用代理时无法使用 HTTPS 协议，所以我选择使用 ClashForWindows 的的 TUN 模式。这样可以直接虚拟出一个网卡，从而使得所有的程序对网络代理无感，这样同时省去了不同开发工具的代理设置。\n启动 TUN 模式需要进行如下操作：\n点击 General 中 Service Mode 右边 Manage，在打开窗口中安装服务模式，安装完成应用会自动重启，Service Mode 右边地球图标变为绿色即安装成功。\n点击 General 中 TUN Mode 右边开关启动 TUN 模式\n更新后 TUN 模式无法使用 因为 ClashForWindows 目前无法识别不同版本安装的 TUN 服务，所以在更新后需要重新安装 TUN 服务。\n这里需要注意，yixuju 提供的 bucket scoop-bucket 在更新时会申请权限卸载 TUN 服务，所以软件更新后只需要重新安装 TUN 服务即可。\n无法安装 TUN 服务 如果无法安装 TUN 服务，可能有如下几种情况：\nC:\\Program Files 目录下有名为 Clash for Windows Service 的文件夹或文件。\n没有提供管理员权限。\n旧版的 TUN 服务没有卸载。\n旧版的 TUN 服务卸载时有部分内容残留。\n此时可以尝试在面板中卸载 TUN 服务，删除 C:\\Program Files\\Clash for Windows Service 文件夹或文件，然后重新安装 TUN 服务。\n如果你的各种尝试都没有成功，你可以采用如下方法手动安装 TUN 服务：\n点击 General 中的 Home Directory 打开文件夹，进入此软件的 resources\\static\\files\\win\\common 子目录中。\n将 service.yml 文件复制到 resources\\static\\files\\win\\x64\\service 子目录。\n执行如下命令：\nservice.exe uninstall service.exe install service.exe start ","date":"2023-01-26T21:34:00Z","image":"https://static.aecra.cn/cover/problems-in-using-ClashForWindows.png","permalink":"https://aecra.github.io/article/problems-in-using-clashforwindows/","title":"使用 ClashForWindows 时的一些问题"},{"content":"什么是 GDB？ GDB 是 GNU Project 调试器，它允许您查看另一个程序在执行时“内部”发生了什么——或者在它崩溃时另一个程序正在做什么。\nGDB 可以做四种主要的事情(加上支持这些事情的其他事情)来帮助你在行动中捕捉错误:\n启动程序，指定任何可能影响其行为的内容。 使您的程序在指定条件下停止。 检查程序停止时发生了什么。 更改程序中的内容，这样您就可以尝试纠正一个 bug 的影响，然后继续了解另一个 bug。 这些程序可能与 GDB (本机)在同一台机器上执行，也可能在另一台机器(远程)上执行，或者在模拟器上执行。GDB 可以在大多数流行的 UNIX 和 Microsoft Windows 变体，以及 Mac OS X 上运行。\nGDB 支持如下语言：\nAda Assembly C C++ D Fortran Go Objective-C OpenCL Modula-2 Pascal Rust 如何启动 GDB？ 如果我们使用 [tldr](tldr pages) 来查看 gdb 使用方法，我们可以得到如下提示：\n$ tldr gdb gdb The GNU Debugger.More information: https://www.gnu.org/software/gdb. - Debug an executable: gdb {{executable}} - Attach a process to gdb: gdb -p {{procID}} - Debug with a core file: gdb -c {{core}} {{executable}} - Execute given GDB commands upon start: gdb -ex \u0026#34;{{commands}}\u0026#34; {{executable}} - Start gdb and pass arguments to the executable: gdb --args {{executable}} {{argument1}} {{argument2}} 这是 GDB 的几种常见用法，分别是：\n执行一个程序并 debug； 通过指定程序的 proceID 进入一个正在运行的程序并 debug； 通过指定程序出错时生成的 [core 文件](Core Files in Linux (perforce.com)) 还原程序出错时的现场来 debug； 执行一个程序并传入参数并 debug。 我们编写一个简单的 C 语言程序作为我们调试程序。\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 1, b = 2, c = 0; c = a + b; printf(\u0026#34;c = %d\\n\u0026#34;, c); return 0; } 编译链接为可执行文件同时附带调试信息：\ngcc -g a.c -o a 使用如下命令开启 GDB 调试：\ngdb a 进入 GDB 后将显示类似如下的信息：\nGNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git Copyright (C) 2021 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-linux-gnu\u0026#34;. Type \u0026#34;show configuration\u0026#34; for configuration details. For bug reporting instructions, please see: \u0026lt;https://www.gnu.org/software/gdb/bugs/\u0026gt;. Find the GDB manual and other documentation resources online at: \u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;. For help, type \u0026#34;help\u0026#34;. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;... Reading symbols from a... (No debugging symbols found in a) (gdb) 它给我们提示可以使用 apropos word 来查找相关的命令，所以在不查询文档时可以通过这种方法快速查找某个命令如何使用。\n更多启动相关命令见官方文档 Running (Debugging with GDB) (sourceware.org)。\n如何在 GDB 中调试程序？ 调试无非是了解程序的运行逻辑，以及在某个执行步骤中程序的状态，所以作为入门只需要知道如何中断、启动、查询，以及如何使用 display 来提供代码展示。\n中断 中断可以使用断点(Breakpoints)、观察点(Watchpoints)、捕捉点(Catchpoints)。断点是程序运行到此处则中断；观察点用于观察某个变量甚至是由运算符组合的许多变量，如果变量值发生变化则中断；捕捉点则是在程序触发某种事件时中断，如 catch、throw、assert、exec、syscall、fork、vfork、signal。\n可以使用 list 命令来查询代码，每次执行将输出十行代码，如果需要获取更多可以多次使用 list 命令，同时 list 也支持打印指定行的代码，用法如下：\n(gdb) list (gdb) list 3,5 使用如下命令设置断点：\n(gdb) break locspec locspecc 可以指定函数名、行号、指令地址等，break 可以缩写为 b。\n使用如下命令来查询断点：\n(gdb) info breakpoints (gdb) info b 使用如下命令设置观察点：\n(gdb) watch expr 使用如下方式来查询观察点：\n(gdb) info watchpoints 使用如下方式来设置捕捉点：\n(gdb) catch event 捕捉点同样使用 info b 来查看，值得一提的是，此命令同样会列出我们设置的观察点。\n启动 启动分为从最开始启动程序和中断后继续执行程序。\n从最开始启动程序的命令有starti 和 run两个命令。其中 starti 是开启程序，并停止在第一个指令，该指令在 linux 为 _start 而非 main 函数，因为堆栈、全局函数等一系列程序初始状态尚未设置。run 命令则是开启程序并在到达设置的断点处中断。\n中断后继续执行程序，其实是 Continuing and Stepping ，这里只介绍最常用的几个命令：\n(gdb) continue / c # 在程序上次停止的地址处恢复程序执行；绕过在该地址设置的任何断点，直到遇到下一个断点。 (gdb) step / s # 继续运行程序，直到控制到达另一个源代码行，然后停止它并将控制返回给 GDB，如果遇到函数则进入函数。 (gdb) step count # 按步骤继续运行，但要计算次数。如果在计数步骤之前出现断点或与单步执行无关的信号，则单步执行立即停止。 (gdb) next [count] / n [count] # 继续到当前(最内层)堆栈帧中的下一个源行。这与 step 类似，但是在代码行中出现的函数调用不会停止执行，即将函数看作一个原子指令。 (gdb) finish # 继续运行，直到所选堆栈帧中的函数返回之后。 (gdb) until locspec # 继续运行程序，直到程序到达解析 locspec 的代码位置，或者当前堆栈帧返回。 (gdb) stepi / si # 执行一个指令，然后停止并返回到调试器。 (gdb) nexti / ni # 执行一个指令，但如果是函数调用，则继续执行，直到函数返回。 查询 在程序执行过程中，我们可能需要获取某些信息，如前文提到的查询断点指令 info breakpoints，如下是常用的查询：\n(gdb) print expr # 打印表达式的值 (gdb) info breakpoints # 查询断点 (gdb) info frame # 查询堆栈信息 (gdb) info registers # 查询寄存器的值 更友好的页面 为了更清晰地直到程序运行到哪里，我们可以显示源代码，甚至是汇编代码。\n显示当前运行的源代码：\n(gdb) layout src 我们可以得到如下页面：\n┌─a.c────────────────────────────────────────────────────────────────────────────┐ │ 1 #include \u0026lt;stdio.h\u0026gt; │ │ 2 │ │ 3 int main() │ │ 4 { │ │B+\u0026gt;5 int a = 1, b = 2, c = 0; │ │ 6 c = a + b; │ │ 7 printf(\u0026#34;c = %d\\n\u0026#34;, c); │ │ 8 │ │ 9 return 0; │ │ 10 } │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ └────────────────────────────────────────────────────────────────────────────────┘ native process 134526 In: main L5 PC: 0x55555555513d (gdb) layout asm (gdb) 显示汇编代码：\n(gdb) layout src 得到如下页面：\n┌────────────────────────────────────────────────────────────────────────────────┐ │ 0x555555555135 \u0026lt;main\u0026gt; push %rbp │ │ 0x555555555136 \u0026lt;main+1\u0026gt; mov %rsp,%rbp │ │ 0x555555555139 \u0026lt;main+4\u0026gt; sub $0x10,%rsp │ │B+\u0026gt;0x55555555513d \u0026lt;main+8\u0026gt; movl $0x1,-0x4(%rbp) │ │ 0x555555555144 \u0026lt;main+15\u0026gt; movl $0x2,-0x8(%rbp) │ │ 0x55555555514b \u0026lt;main+22\u0026gt; movl $0x0,-0xc(%rbp) │ │ 0x555555555152 \u0026lt;main+29\u0026gt; mov -0x4(%rbp),%edx │ │ 0x555555555155 \u0026lt;main+32\u0026gt; mov -0x8(%rbp),%eax │ │ 0x555555555158 \u0026lt;main+35\u0026gt; add %edx,%eax │ │ 0x55555555515a \u0026lt;main+37\u0026gt; mov %eax,-0xc(%rbp) │ │ 0x55555555515d \u0026lt;main+40\u0026gt; mov -0xc(%rbp),%eax │ │ 0x555555555160 \u0026lt;main+43\u0026gt; mov %eax,%esi │ │ 0x555555555162 \u0026lt;main+45\u0026gt; lea 0xe9b(%rip),%rdi # 0x555555556 │ │ 0x555555555169 \u0026lt;main+52\u0026gt; mov $0x0,%eax │ │ 0x55555555516e \u0026lt;main+57\u0026gt; call 0x555555555030 \u0026lt;printf@plt\u0026gt; │ │ 0x555555555173 \u0026lt;main+62\u0026gt; mov $0x0,%eax │ │ 0x555555555178 \u0026lt;main+67\u0026gt; leave │ │ 0x555555555179 \u0026lt;main+68\u0026gt; ret │ │ 0x55555555517a nopw 0x0(%rax,%rax,1) │ └────────────────────────────────────────────────────────────────────────────────┘ native process 134526 In: main L5 PC: 0x55555555513d (gdb) layout asm (gdb) ","date":"2022-10-31T20:27:48Z","image":"https://static.aecra.cn/cover/Brief-Instructions-for-Using-GDB.png","permalink":"https://aecra.github.io/article/brief-instructions-for-using-gdb/","title":"GDB 简要使用说明"},{"content":"标记清除法 在 v1.0~v1.3 版本中都是用的是标记清除算法。首先我们需要了解 STW（Stop The World）是什么，顾名思义，STW 是将当前程序完全暂停，不执行用户程序并开始垃圾回收。标记清除算法的流程如下：\nStop the world； 标记：从根对象开始标记，将可达对象和不可达对象区分开； 清除：将不可达对象回收； 恢复用户程序的执行。 标记清除算法如此简单粗暴很明显有非常突出的性能问题，体现在\nSTW 会导致程序卡顿，对程序相应带来不可接受的延时； 标记过程需要扫描整个堆空间； 清除数据会产生堆碎片，这里需要参照内存分配算法。 v1.0 是完全串行的标记清除算法，v1.1 实现了多核系统的并行垃圾收集和标记，v1.3 运行时基于只有指针类型的值包含指针的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集。\n三色标记法 在 v1.5 中 Golang 实现了三色标记法，三色标记法的流程如下：\n所有对象都标记为白色； 从根节点开始将对象标记为灰色； 从灰色及各种选择一个灰色对象并将其标记为黑色； 将该黑色对象指向的对象都标记为灰色； 重复步骤2、步骤3 直到不存在灰色对象。 回收白色对象。 写屏障 三色不变式 如果我们在使用三色标记法时采用和标记清除法相同的 STW 措施时肯定可以正常运行，但正是为了解决 STW 时间过长而采用的三色标记法，所以程序和GC是要并行的，如果有如下情况将会回收不应回收的对象：\n黑色对象指向白色对象； 直接或间接指向该白色对象的灰色对象切断了依赖链条； 这种情况在标记完之后会将该白色对象清除掉，而黑色对象将产生悬浮指针问题。\n强三色不变式：不允许黑色对象引用白色对象\n弱三色不变式：黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。\n而为了实现三色不变式，引入了屏障机制。\n插入写屏障 写屏障这个名字如果没有接触过会感到很迷惑，其实它就是在进行写操作之前添加额外的处理，可以看作对函数的进一步封装。\nwritePointer(slot, ptr): shade(ptr) *slot = ptr 上述插入写屏障的伪代码非常好理解，每当执行类似 *slot = ptr 的表达式时，我们会执行上述写屏障通过 shade 函数尝试改变指针的颜色。如果 ptr 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。\n通过这种方法就可以保证强三色不变式。\n因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，插入写屏障必须为栈上的对象增加写屏障，而用户代码执行过程中对会对栈上的数据频繁读写，所以会大幅增加写入的额外开销；另一种方法是不对栈上的空间开启插入写屏障，而是在标记阶段完成后 Stop the World，并对栈上的对象进行扫描，这两种方法各有利弊。\n删除写屏障 writePointer(slot, ptr) shade(*slot) *slot = ptr 被删除对象，如果自身为灰色或者白色，那么被标记为灰色。\n通过这种方法就可以保证弱三色不变式。\n这种方式的缺点是，对于本次要删除的对象，只有在下一轮之后才会被清除。\n混合写屏障 v1.8 使用了混合写屏障将垃圾收集时最坏的 STW 时间缩短至 0.05ms 以内。\nwritePointer(slot, ptr): shade(*slot) if current stack is grey: shade(ptr) *slot = ptr 该写屏障会将被覆盖的对象标记成灰色并在当前 goroutine 的栈没有扫描时将新对象也标记成灰色。\n标记阶段开始时将栈上的可达对象全部扫描并标记为黑色。\n在垃圾收集的标记阶段，我们需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，同时因为栈中的对象在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。\n通过这种方法就可以保证变形的弱三色不变式。\n关于 if current stack is grey 的问题，这个判断如果单纯看写屏障不容易搞明白适用条件，这里的标记阶段是并发执行的，当涉及到不同 goroutine 的操作时，例如 channel 带来的变量复制情况，会在不同的栈上进行操作，这里是为了防止另一个栈将我们需要的对象进行回收。\n","date":"2022-10-20T20:07:32Z","image":"https://static.aecra.cn/cover/GC-Algorithm-in-Golang-Tri-color-Marking-and-Hybrid-Write-Barrier.png","permalink":"https://aecra.github.io/article/gc-algorithm-in-golang-tri-color-marking-and-hybrid-write-barrier/","title":"Golang 中的 GC 算法：三色标记与混合写屏障"},{"content":"在 Golang 中我们可以找到 heap 的实现，但是，基于 heap 的优先队列没有提供支持，只在 heap 文档中提供了优先队列的一个示例，Go 团队是在是太狗了，这对于我们这些要刷算法题，参加算法竞赛的同志们非常的不友好，而且在示例里面展示的优先队列还是 string 类型的，如果我们使用肯定是要修改的，和 C++ 相比，Go 没有 template 的特性和运算符重载的支持实在是很不方便（终于体会到什么是 \u0026ldquo;less is more\u0026quot;了）。\n堆的实现这里就不赘述了，我们只了解以下先验知识：\n堆是一个完全二叉树 堆使用数组作为底层存储，它的每个元素的子节点是2\\*i，和2\\*i+1 堆中的最小元素在下标 0 处，即完全二叉树的根 入队时将元素加入到数组末尾，然后进行上浮操作 出队时将最大值与数组末尾元素互换位置，并对根进行下沉操作 好了，我们知道这些之后，看看下面这个最简洁的优先队列例子。\ntype Item struct { value int priority int } type PriorityQueue []*Item func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { return pq[i].priority \u0026lt; pq[j].priority } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq *PriorityQueue) Push(x interface{}) { item := x.(*Item) *pq = append(*pq, item) } func (pq *PriorityQueue) Pop() interface{} { old := *pq n := len(old) item := old[n-1] old[n-1] = nil *pq = old[0 : n-1] return item } 我们需要关注的是 Item 结构体的字段，在实际使用中可以根据需要自定义。\n其次就是 Less 函数了，前面已经知道了，最小的在下标 0 处，出队时也是它，所以我们修改 Less 函数，让我们排在前面的优先级最小，这就是优先级最小的在队首优先队列，如果要得到优先级最大的在队首的优先队列只需要反转 Less 函数即可。\n","date":"2022-09-13T23:41:00Z","image":"https://static.aecra.cn/cover/use-priority-queue-in-golang.png","permalink":"https://aecra.github.io/article/use-priority-queue-in-golang/","title":"在 Golang 中使用优先队列"},{"content":"问题描述 先简要描述一下，在构建 Podman 过程中，如果使用 Ctrl + C 强制终止，会使构建中的容器残留在 Podman 中，不仅占用空间还影响无用镜像的删除。\n之前多次构建时有强制中断的情况，所以我的问题比较严重才发现，要不然一个两个无法删除的镜像还引不起重视。\n我的镜像列表：\nREPOSITORY TAG IMAGE ID CREATED SIZE\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 6b97c9f7f89f 2 days ago 1.67 GB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 37616f79cf88 2 days ago 992 MB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; e5028987de23 2 days ago 1.67 GB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 29ebb80d809d 7 days ago 992 MB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 30994a0dd3f6 7 days ago 1.67 GB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; eea90f9d3610 7 days ago 992 MB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; e2f2eb80c593 7 days ago 1.67 GB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 339be923556e 7 days ago 930 MB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; bc390bc57574 8 days ago 930 MB\rdocker.io/library/golang 1.18.4 e3c0472b1b62 4 weeks ago 988 MB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 57e0342b3532 5 weeks ago 991 MB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 8b5845455f80 5 weeks ago 1.67 GB\r\u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 803d3146f7dd 7 weeks ago 1 GB\rdocker.io/library/alpine latest e66264b98777 2 months ago 5.82 MB\rdocker.io/library/golang 1.17.5 276895edf967 7 months ago 963 MB\rdocker.io/library/node 16.13.0 5964aa70c11d 9 months ago 928 MB 当使用 podman image prune 删除无用镜像时，依旧剩余如上镜像，这时就想到删除单个镜像，如下删除列表中的第一个镜像：\npodman rmi 6b97c9f7f89f 此时会报错:\nError: 1 errors occurred:\r* Image used by b63f5d5c99dd8bbb17510f58a9dfa2fe5b3a71ba57257aec6aa53c1ec4366db8: image is in use by a container 但这个容器使用 pdoman ps -a 查看并不存在。\n经过一番搜索发现，使用 podman ps --all --storage 可以查询当前存储的容器和镜像，其中就包含了构建过程中因强制终止而遗留的容器，如下：\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\rf735cc1062a7 docker.io/library/golang:1.17.5 buildah 7 weeks ago storage golang-working-container\rfe95fad6d0ec docker.io/library/98ee13c4afe4a5a88fb6e3464a90ea3838e62806e9e5e025bedaaae2db25c653-tmp:latest buildah 7 weeks ago storage 8e860db1f8ded07d0d7083ee05ab5c17a7d41519b04ef3127bd3921f8b3df6ff-working-containerbf7d43b6e1de docker.io/library/b1d4f01a06501868672f31dee8be2506c18dbe938a0a12a2edb1e99fb1cb0b1d-tmp:latest buildah 7 weeks ago storage 803d3146f7ddce32b8f2e9f4f9ec7d51607f5b3ddc618758aa55634d0aa1576e-working-containere5fba2ea7216 docker.io/library/golang:1.17.5 buildah 7 weeks ago storage golang-working-container-1\r7b94635d2311 docker.io/library/98ee13c4afe4a5a88fb6e3464a90ea3838e62806e9e5e025bedaaae2db25c653-tmp:latest buildah 7 weeks ago storage 8e860db1f8ded07d0d7083ee05ab5c17a7d41519b04ef3127bd3921f8b3df6ff-working-container-1\r3297183ec5dd docker.io/library/b1d4f01a06501868672f31dee8be2506c18dbe938a0a12a2edb1e99fb1cb0b1d-tmp:latest buildah 7 weeks ago storage 803d3146f7ddce32b8f2e9f4f9ec7d51607f5b3ddc618758aa55634d0aa1576e-working-container-1\r# 后面还有非常多的项目，我们只列举了一部分。 现在的任务就是如何解决这些垃圾数据了。\n解决方法 因为 Podman 只是一个容器管理工具，它的是使用 buildah 来构建镜像的，所以我们可以直接使用 buildah 来清理构建过程中残留的容器，使用方法如下：\nbuildah rm --all 该方法不会删除 podman iamges 中可以查询到的镜像，因为这些构建好的镜像是交给 podman 了的，所以可以放心地删除。\n","date":"2022-08-16T10:43:50Z","image":"https://static.aecra.cn/cover/Podman-build-container-residual-problem-when-the-build-process-is-forced-to-terminate.png","permalink":"https://aecra.github.io/article/podman-build-container-residual-problem-when-the-build-process-is-forced-to-terminate/","title":"Podman 构建过程强制终止时构建容器残留问题"},{"content":"问题背景和描述 Windows 系统中使用 Clash-for-Windows 作为代理应用，同时 wsl 中设置了系统代理，配置如下：\nexport http_proxy=\u0026#34;http://192.168.1.3:7890/\u0026#34; export https_proxy=\u0026#34;http://192.168.1.3:7890/\u0026#34; export ftp_proxy=\u0026#34;http://192.168.1.3:7890/\u0026#34; export no_proxy=\u0026#34;127.0.0.1,localhost\u0026#34; export HTTP_PROXY=\u0026#34;http://192.168.1.3:7890/\u0026#34; export HTTPS_PROXY=\u0026#34;http://192.168.1.3:7890/\u0026#34; export FTP_PROXY=\u0026#34;http://192.168.1.3:7890/\u0026#34; export NO_PROXY=\u0026#34;127.0.0.1,localhost\u0026#34; 我的目标是构建 Golang 应用，涉及到的 Dockerfile 如下：\nFROM golang:1.18.4 AS BACK WORKDIR /go/src/bus COPY . . RUN ./build.sh 其中 build.sh 内容如下：\n#!/bin/bash #try to connect to google to determine whether user need to use proxy curl www.google.com -o /dev/null --connect-timeout 5 2 \u0026gt; /dev/null if [ $? == 0 ] then echo \u0026#34;Successfully connected to Google, no need to use Go proxy\u0026#34; CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\u0026#34;-w -s\u0026#34; -o server . else echo \u0026#34;Google is blocked, Go proxy is enabled: GOPROXY=https://goproxy.cn,direct\u0026#34; CGO_ENABLED=0 GOOS=linux GOARCH=amd64 GOPROXY=https://goproxy.cn,direct go build -ldflags=\u0026#34;-w -s\u0026#34; -o server . fi 此时正常构建会卡到如下步骤：\n[2/3] STEP 4/4: RUN ./build.sh\r% Total % Received % Xferd Average Speed Time Time Time Current\rDload Upload Total Spent Left Speed\r100 15157 0 15157 0 0 504 0 --:--:-- 0:00:30 --:--:-- 0 这一步几个小时都不会有好转。\n解决方法 问题背景和问题描述都清楚之后，怎么解决呢？尝试过如下方法：\n等待更长时间，但三个小时都不起效果。 更换 Podman，经测试同样如此。 这就很迷惑了，猜测可能是网络问题，所以经过不断尝试发现如下解决方案。\n暂时将 Clash-for-Windows 的 Allow LAN 关闭；\n执行构建命令；\n等待出现如下日志：\n[2/3] STEP 4/4: RUN ./build.sh\r% Total % Received % Xferd Average Speed Time Time Time Current\rDload Upload Total Spent Left Speed\r0 0 0 0 0 0 0 0 --:--:-- 0:00:05 --:--:-- 0\rcurl: (28) Connection timed out after 5001 milliseconds 打开 Clash-for-Windows 的 Allow LAN 。\n然后就可以正常下载项目依赖并构建了。至于为什么会出现这种状况，还需要再了解下 Docker 网络相关的内容了。\n","date":"2022-08-13T21:09:21Z","image":"https://static.aecra.cn/cover/Web-proxy-causes-build-jam-when-building-Golang-projects-in-wsl.png","permalink":"https://aecra.github.io/article/web-proxy-causes-build-jam-when-building-golang-projects-in-wsl/","title":"wsl 中构建 Golang 项目时网络代理引起构建卡壳的问题"},{"content":"NGINX 安装 NGINX 入门指导\n网站强制使用 HTTPS 监听 80 端口上的所有请求，将其重定向到 443 端口，之后每个服务只需要监听 443 点扣上对应的域名即可。\nserver { listen 80 default_server; server_name _; return 301 https://$host$request_uri; } ","date":"2022-07-14T11:25:54Z","image":"https://static.aecra.cn/cover/collection-of-nginx-issues.png","permalink":"https://aecra.github.io/article/collection-of-nginx-issues/","title":"NGINX 问题集锦"},{"content":"简述 因为国内网络不能畅通，在配置服务器和更新资源时常常需要更换成国内的镜像源，过多的配置实在是繁杂，倒不如直接将本机流量转发到处于正常的网络环境的机器中。\n代理机器配置 想要服务器可以代理我们的网络请求，就需要我们的服务器提供代理服务，相应的工具有很多种，这里为了简单快速我们使用 goproxy。\n安装 curl -L https://mirrors.host900.com/https://github.com/snail007/goproxy/blob/master/install_auto.sh | bash 启动 proxy http --forever -p \u0026#34;0.0.0.0:port\u0026#34; --daemon --log proxy.log -T tls 服务器配置 # 1. 编辑配置文件 sudo vim /etc/profile.d/proxy.sh # 2. 写入如下内容 # set proxy config via profie.d - should apply for all users export http_proxy=\u0026#34;ip:port/\u0026#34; export https_proxy=\u0026#34;http://ip:port/\u0026#34; export ftp_proxy=\u0026#34;http://ip:port/\u0026#34; export no_proxy=\u0026#34;127.0.0.1,localhost\u0026#34; # For curl export HTTP_PROXY=\u0026#34;http://ip:port/\u0026#34; export HTTPS_PROXY=\u0026#34;http://ip:port/\u0026#34; export FTP_PROXY=\u0026#34;http://ip:port/\u0026#34; export NO_PROXY=\u0026#34;127.0.0.1,localhost\u0026#34; # 3. 增加权限 sudo chmod +x /etc/profile.d/proxy.sh # 3. 引入配置 source /etc/profile.d/proxy.sh # 4. 检查配置 env | grep -i proxy 此时我们的服务器就可以畅通地访问网络了。\n其他 此时我们的代理是没有权限的，任何人只要知道了我们的地址即可使用服务，所以可以采用二级代理的方式，详见http二级代理加密\n","date":"2022-05-26T19:00:25Z","image":"https://static.aecra.cn/cover/configure-a-smooth-network-environment-for-the-server.jpg","permalink":"https://aecra.github.io/article/configure-a-smooth-network-environment-for-the-server/","title":"为服务器配置畅通的网络环境"},{"content":"为什么要自己搭建网关？ 首先明确网关的用途，我使用网关完全是统一管理自己的各种后台接口。在搭建自己的网关前我的后台接口十分散乱，有的部署在云函数的 HTTP 事件触发器上，有的部署在云函数的 Web 云函数上，有的在腾讯云的 API 网关上，有的在 nginx 代理上，这次自己搭建网关主要是整理提供的接口，同时清理不必要的配置。\n如果说单单上面的原因还不至于需要自己再折腾一次，但腾讯这几天取消了云函数的免费额度，而且下个月开始只要使用就会扣除基础服务费 12.8 元，这能忍吗？既然服务可以使用云函数跑，那照样可以在 docker 中跑，所以将云函数中的服务全部迁移到服务器的 docker 上。PS：由于云函数最开始不支持容器部署，所以一些旧的服务都是直接和云厂商的服务绑定的，这些旧服务就暂时停止吧。\n启动 Kong Gateway（docker） kong 作为一个开源的网关服务还是很稳定的，以下是 Kong 的部署方法，注意修改其中的 PASSWORD。\n启动数据库，这个数据库为 Kong 提供服务。\ndocker run -d --name kong-database \\ --network=kong-net \\ -p 5432:5432 \\ -e \u0026#34;POSTGRES_USER=kong\u0026#34; \\ -e \u0026#34;POSTGRES_DB=kong\u0026#34; \\ -e \u0026#34;POSTGRES_PASSWORD=kongpass\u0026#34; \\ postgres:9.6 初始化配置，这里配置数据库。\ndocker run --rm --network=kong-net \\ -e \u0026#34;KONG_DATABASE=postgres\u0026#34; \\ -e \u0026#34;KONG_PG_HOST=kong-database\u0026#34; \\ -e \u0026#34;KONG_PG_PASSWORD=kongpass\u0026#34; \\ kong/kong-gateway:2.8.1.0-alpine kong migrations bootstrap 启动 Kong 网关，因为后续将使用 nginx 代理，SSL 将放到 nginx 中配置，而且使用的是社区版，所以只是用 8001 和 8000 端口即可。\ndocker run -d --name kong-gateway \\ --network=kong-net \\ -e \u0026#34;KONG_DATABASE=postgres\u0026#34; \\ -e \u0026#34;KONG_PG_HOST=kong-database\u0026#34; \\ -e \u0026#34;KONG_PG_USER=kong\u0026#34; \\ -e \u0026#34;KONG_PG_PASSWORD=kongpass\u0026#34; \\ -e \u0026#34;KONG_ADMIN_LISTEN=0.0.0.0:8001\u0026#34; \\ -p 8000:8000 \\ -p 8001:8001 \\ kong/kong-gateway:2.8.1.0-alpine :8000：用于提供网关服务； :8001：用于配置 Kong 监听的管理 API； 现在已经将 Kong 配置完成了，下面启动一个 UI 界面帮助我们管理。\n启动 konga konga 是一个第三方的 GUI 管理页面。\n我们同样使用 docker 配置。\ndocker run -p 1337:1337 \\ --network kong-net \\ --name konga \\ -e \u0026#34;NODE_ENV=production\u0026#34; \\ -e \u0026#34;TOKEN_SECRET=fdasfeag34agft\u0026#34; \\ pantsel/konga 启动之后，只需要开启 1337 端口即可通过 UI 界面配置我们的 kong 网关。\n首次进入需要填写 kong 配置接口，因为以上的服务都加入到了 kong-net 网络中，所以只需要填写 http://kong-gateway:8001 即可。\n配置 nginx 因为需要使用 nginx 配置 SSL 服务，所以这里修改 nginx 配置。\nserver { listen 80; server_name hostname; return 301 https://hostname; } server { listen 443 ssl; server_name hostname; location / { proxy_pass http://localhost:8000; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect off; } ssl_certificate /config/nginx/cert/fullchain.cer; ssl_certificate_key /config/nginx/cert/cert.key; ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; # about 40000 sessions ssl_session_tickets off; # intermediate configuration ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; ssl_prefer_server_ciphers off; # HSTS (ngx_http_headers_module is required) (63072000 seconds) add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; } 添加服务 在 Kong 中，需要区分 services 和 routes，services 是对后端服务的访问设置，routes 是网关对外提供的服务。一个 service 可以有多个 route，而一个 route 只能有一个 service。\n因为我的服务都在一台服务器上，所以为了安全起见我将服务都加入到 kong 同一个网络中，所以在配置 service 时只需要在 HOST 字段填入容器名称即可，同时还可以不必添加端口映射，提高安全性。\nTodo：这里应该填写一些如何添加服务更详细的说明，但不想写了，就这样吧，如果有问题再说。\n","date":"2022-05-20T19:31:35Z","image":"https://static.aecra.cn/cover/build-a-gateway-by-kong.png","permalink":"https://aecra.github.io/article/build-a-gateway-by-kong/","title":"使用 Kong 搭建网关"},{"content":"什么是哈希表 哈希表是键值对映射的数据结构，可以通过键对数据进行存取，其中实现的关键是哈希函数和哈希冲突。\n哈希函数提供了对键的散列编码，可以将存取的数据分散到底层的数据空间中，所以哈希函数的均匀分布可以提高哈希表的读写性能。\n哈希冲突的结果可以使用开放寻址法和拉链法来解决。\n源码位置：go/map.go\n数据结构 哈希表使用 runtime.hmap 表示，其中每个存储桶使用 runtime.bmap 表示。\ntype hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra } type mapextra struct { overflow *[]*bmap // 当前持有的初始化溢出桶 oldoverflow *[]*bmap // 扩容前的初始化溢出桶 nextOverflow *bmap // 下一个待分配的溢出桶 } count 表示当前哈希表中的元素数量； B 表示当前哈希表持有的 buckets 数量，但是因为哈希表中桶扩容为翻倍扩容，所以该字段会存储对数，也就是 len(buckets) == 2^B； noverflow 用于记录当前哈希表的溢出桶数量。 hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入； buckets 是当前桶。 oldbuckets 是哈希在扩容时用于保存之前 buckets 的字段。 nevacuate 表示当前已分流桶的数量。 mapextra 用于存储溢出桶的相关数据，溢出桶是用于解决频繁扩容的有效方法。 type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } 原始的 bmap 只有 topbits 字段，该字段为哈希值的高八位，用于加速键值对的访问。\n其他字段在编译时进行推导，该结构为虚拟结构，实际访问则通过计算内存地址的方式访问。\n溢出桶 由上面可知，哈希表的底层使用的是桶存储数据，每个桶最多可以存储 8 个键值对，其中根据需要可能会多创建不定数量的溢出桶用来承载桶溢出后的数据，溢出桶会添加到桶的 overflow 字段。\n桶数量确定原则：\n哈希表未指定元素数量是默认为 0，然后根据最大负载因子为 6.5、每个存储桶中 8 个元素来确定最小的 B 大小。 溢出桶创建规则：\n当桶的数量小于 2**4 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销； 当桶的数量多于 2**4 时，会额外创建 2**(B-4) 个溢出桶； 在创建时正常桶和溢出桶处于相邻的地址空间，只有在初始化的溢出桶使用完后才会通过 runtime.newobject 创建新的溢出桶。\n数据操作 访问 哈希表的访问步骤如下：\n计算哈希值。 获取存储数据的桶。 依次对比 tophash 与哈希值的高八位，如果相同则对比对应的键值，相同即可返回，否则继续向下寻找，如果当前桶内数据查找完后继续查找溢出桶，直到找到键值对或者数据不存在。 因为哈希表的扩容不具备原子性，所以在扩容过程中进行访问的过程在扩容部分介绍。\n写入/修改 写入与修改在相同过程中实现，步骤如下：\n计算哈希值 获取存储数据的桶 依次对比 tophash 与哈希值的高八位，如果相同则对比对应的键值，相同即可将新数据写入，否则继续向下寻找，如果当前桶内数据查找完后继续查找溢出桶，直到找到键值对或者数据不存在，当数据不存在时会将哈希高八位写入到 tophash 键值对写入对应位置，如果最后的桶已满，则获取新的溢出桶插入到当前桶之后并写入数据。 在扩容期间进行的写入与修改过程将在扩容部分介绍。\n删除 删除操作即删除对应的 tophash 和键值对，但并不会整理内存和释放多余的溢出桶，此部分在扩容部分完成。\n扩容机制 发生条件 装载因子超过 6.5。 哈希表使用了过多的溢出桶。 扩容分类 等量扩容\n等量扩容的原因是使用了过多的溢出桶，扩容方式是创建一组相同数量的桶，随后将原有的桶数组设置到 oldbuckets 上并将新的空桶设置到 buckets 上，溢出桶也使用了相同的逻辑更新。\n翻倍扩容\n翻倍扩容的原因是装载因子已经超过了 6.5，扩容方式是创建一组 2 倍数量的桶和相应的溢出桶，随后将原有的桶数组设置到 oldbuckets 上并将新的空桶设置到 buckets 上，溢出桶也使用了相同的逻辑更新。\n增量扩容 在创建新桶后并没有对原有数据进行分流，数据的分流以桶为单位，分流时机为每次写入操作前和删除操作前。\n分流方式为从旧桶中依次读取数据，计算哈希值和新桶索引，并将数据写入到新桶中，写入方式和上文相同。之后只保留旧桶的 tophash 用于标记该桶已分流，其他内存则进行回收。如果所有的桶都进行了分流则置 oldbuckets 和nevacuate 为空，以回收 tophash 占用的空间。\n在增删改前如果旧桶数据已分流则直接对新桶进行操作，如果旧桶未分流则分流后对新桶进行操作。读操作前如果旧桶未分流则读取旧桶，否则读取新桶。\n参考 理解 Golang 哈希表 Map 的原理 | Go 语言设计与实现 (draveness.me)\nGo 语言如何进行类型检查 | Go 语言设计与实现 (draveness.me)\nGolang 数据结构详解之哈希表 - 知乎 (zhihu.com)\n","date":"2022-04-20T19:51:21Z","image":"https://static.aecra.cn/cover/hash-table-implementation-in-go.png","permalink":"https://aecra.github.io/article/hash-table-implementation-in-go/","title":"GO 中哈希表的实现"},{"content":"光标移动 注：一般模式下，任意一个动作都可以重复。\nh # 光标左移，同 \u0026lt;Left\u0026gt; 键 j # 光标下移，同 \u0026lt;Down\u0026gt; 键 k # 光标上移，同 \u0026lt;Up\u0026gt; 键 l # 光标右移，同 \u0026lt;Right\u0026gt; 键 Ctrl+e # 向上滚动一行 Ctrl+y # 向下滚动一行 Ctrl+u # 向上滚动半屏 --\u0026gt; move up 1/2 a screen Ctrl+d # 向下滚动半屏 --\u0026gt; move down 1/2 a screen Ctrl+f # 向下滚动一屏 --\u0026gt; move forward one full screen Ctrl+b # 向上滚动一屏 --\u0026gt; move back one full screen 0 # 跳到行首（是数字零，不是字母O），效用等同于 \u0026lt;Home\u0026gt; 键 ^ # 跳到从行首开始第一个非空白字符 $ # 跳到行尾，效用等同于 \u0026lt;End\u0026gt; 键 gg # 跳到第一行，效用等同于 Ctrl+\u0026lt;Home\u0026gt; G # 跳到最后一行，效用等同于 Ctrl+\u0026lt;End\u0026gt; nG # 跳到第n行，比如 10G 是移动到第十行 :n # 跳到第n行，比如 :10\u0026lt;回车\u0026gt; 是移动到第十行 10% # 移动到文件 10% 处 15| # 移动到当前行的 15列 w # 跳到下一个单词开头 (word: 标点或空格分隔的单词) W # 跳到下一个单词开头 (WORD: 空格分隔的单词) e # 跳到下一个单词尾部 (word: 标点或空格分隔的单词) E # 跳到下一个单词尾部 (WORD: 空格分隔的单词) b # 跳到上一个单词开头 (word: 标点或空格分隔的单词) B # 跳到上一个单词开头 (WORD: 空格分隔的单词) ge # 跳到前一个单词结尾 ) # 向前移动一个句子（句号分隔） ( # 向后移动一个句子（句号分隔） } # 向前移动一个段落（空行分隔） { # 向后移动一个段落（空行分隔） \u0026lt;enter\u0026gt; # 移动到下一行首个非空字符 n\u0026lt;enter\u0026gt; # 光标向下移动 n 行 + # 移动到下一行首个非空字符（同回车键） - # 移动到上一行首个非空字符 H # 移动到屏幕上部 M # 移动到屏幕中部 L # 移动到屏幕下部 \u0026lt;S+Left\u0026gt; # 按住 SHIFT 按左键，向左移动一个单词 \u0026lt;S+Right\u0026gt; # 按住 SHIFT 按右键，向右移动一个单词 \u0026lt;S+Up\u0026gt; # 按住 SHIFT 按上键，向上翻页 \u0026lt;S+Down\u0026gt; # 按住 SHIFT 按下键，向下翻页 gm # 移动到行中 gj # 光标向下移动一个屏幕行（忽略自动换行） gk # 光标向上移动一个屏幕行（忽略自动换行） zz # 调整光标所在行到屏幕中央 zt # 调整光标所在行到屏幕上部 zb # 调整光标所在行到屏幕下部 插入模式 i # 在光标处进入插入模式 I # 在行首进入插入模式 a # 在光标后进入插入模式 A # 在行尾进入插入模式 o # 在下一行插入新行并进入插入模式 O # 在上一行插入新行并进入插入模式 gi # 进入到上一次插入模式的位置 \u0026lt;esc\u0026gt; # 退出插入模式 Ctrl+[ # 退出插入模式（等价于 esc 键） 插入模式的命令 注：由 i, I, a, A, o, O 等命令进入插入模式\n\u0026lt;Up\u0026gt; # 光标向上移动 \u0026lt;Down\u0026gt; # 光标向下移动 \u0026lt;Left\u0026gt; # 光标向左移动 \u0026lt;Right\u0026gt; # 光标向右移动 \u0026lt;S+Left\u0026gt; # 按住 SHIFT 按左键，向左移动一个单词 \u0026lt;S+Right\u0026gt; # 按住 SHIFT 按右键，向右移动一个单词 \u0026lt;S+Up\u0026gt; # 按住 SHIFT 按上键，向上翻页 \u0026lt;S+Down\u0026gt; # 按住 SHIFT 按下键，向下翻页 \u0026lt;PageUp\u0026gt; # 上翻页 \u0026lt;PageDown\u0026gt; # 下翻页 \u0026lt;Delete\u0026gt; # 删除光标处字符 \u0026lt;BS\u0026gt; # Backspace 向后删除字符 \u0026lt;Home\u0026gt; # 光标跳转行首 \u0026lt;End\u0026gt; # 光标跳转行尾 Ctrl+d # 减少缩进 Ctrl+f # 减少缩进 Ctrl+t # 增加缩进 Ctrl+h # 删除前一个字符，相当于回格键backspace Ctrl+o # 临时退出插入模式，执行单条命令又返回插入模式 Ctrl+u # 当前行删除到行首所有字符 Ctrl+w # 删除光标前的一个单词 Ctrl+\\ Ctrl+O # 临时退出插入模式（光标保持），执行单条命令又返回插入模式 Ctrl+R 0 # 插入寄存器（内部 0号剪贴板）内容，Ctrl+R 后可跟寄存器名 Ctrl+R \u0026#34; # 插入匿名寄存器内容，相当于插入模式下 p粘贴 Ctrl+R = # 插入表达式计算结果，等号后面跟表达式 Ctrl+R : # 插入上一次命令行命令 Ctrl+R / # 插入上一次搜索的关键字 Ctrl+v {char} # 插入非数字的字面量 Ctrl+v {code} # 插入用三位数字表示的ascii/unicode字符编码，如Ctrl+v 065 Ctrl+v 065 # 插入 10进制 ascii 字符（两数字） 065 即 A字符 Ctrl+v x41 # 插入 16进制 ascii 字符（三数字） x41 即 A字符 Ctrl+v o101 # 插入 8进制 ascii 字符（三数字） o101 即 A字符 Ctrl+v u1234 # 插入 16进制 unicode 字符（四数字） Ctrl+v U12345678 # 插入 16进制 unicode 字符（八数字） Ctrl+K {ch1} {ch2} # 插入 digraph（见 :h digraph），快速输入日文或符号等 自动补全 在插入模式下，最常用的补全\nCtrl+n # 插入模式下文字自动补全 Ctrl+P # 插入模式下文字自动补全 Ctrl+e # 有补全列表时，终止这次补全，继续输入 智能补全\nCtrl+X # 进入补全模式 Ctrl+X Ctrl+L # 整行补全 Ctrl+X Ctrl+N # 插入模式下，根据当前文件里关键字补全 Ctrl+X Ctrl+K # 根据字典补全 Ctrl+X Ctrl+T # 根据同义词字典补全 Ctrl+X Ctrl+F # 插入模式下补全文件名 Ctrl+X Ctrl+I # 根据头文件内关键字补全 Ctrl+X Ctrl+] # 根据标签补全 Ctrl+X Ctrl+D # 补全宏定义 Ctrl+X Ctrl+V # 补全vim命令 Ctrl+X Ctrl+U # 用户自定义补全方式 Ctrl+X Ctrl+S # 拼写建议，例如：一个英文单词 Ctrl+X Ctrl+O # 插入下 Omnifunc 补全 文本编辑 r # 替换当前字符 R # 进入替换模式，直至 ESC 离开 s # 替换字符（删除光标处字符，并进入插入模式，前可接数量） S # 替换行（删除当前行，并进入插入模式，前可接数量） cc # 改写当前行（删除当前行并进入插入模式），同 S cw # 改写光标开始处的当前单词 ciw # 改写光标所处的单词 caw # 改写光标所处的单词，并且包括前后空格（如果有的话） c0 # 改写到行首 c^ # 改写到行首（第一个非零字符） c$ # 改写到行末 C # 改写到行尾（同c$） ci\u0026#34; # 改写双引号中的内容 ci\u0026#39; # 改写单引号中的内容 cib # 改写小括号中的内容 cab # 改写小括号中的内容（包含小括号本身） ci) # 改写小括号中的内容 ci] # 改写中括号中内容 ciB # 改写大括号中内容 caB # 改写大括号中的内容（包含大括号本身） ci} # 改写大括号中内容 cit # 改写 xml tag 中的内容 cis # 改写当前句子 c2w # 改写下两个单词 ct( # 改写到小括号前 x # 删除当前字符，前面可以接数字，3x代表删除三个字符 X # 向前删除字符 dd # 删除(剪切)当前行 --\u0026gt; delete (cut) a line d0 # 删除(剪切)到行首 d^ # 删除(剪切)到行首（第一个非零字符） d$ # 删除(剪切)到行末 D # 删除(剪切)到行末（同 d$） dw # 删除(剪切)当前单词 diw # 删除(剪切)光标所处的单词 daw # 删除(剪切)光标所处的单词，并包含前后空格（如果有的话） di\u0026#34; # 删除双引号中的内容 di\u0026#39; # 删除单引号中的内容 dib # 删除小括号中的内容 di) # 删除小括号中的内容 dab # 删除小括号内的内容（包含小括号本身） di] # 删除中括号中内容 diB # 删除大括号中内容 di} # 删除大括号中内容 daB # 删除大括号内的内容（包含大括号本身） dit # 删除 xml tag 中的内容 dis # 删除当前句子 d2w # 删除下两个单词 dt( # 删除到小括号前 dgg # 删除到文件头部 dG # 删除到文件尾部 d} # 删除下一段 d{ # 删除上一段 10d # 删除当前行开始的10行 :10d # 删除第10行 :1,10d # 删除1-10行 J # 链接多行为一行 . # 重复上一次操作 ~ # 替换大小写 g~iw # 替换当前单词的大小写 gUiw # 将单词转成大写 guiw # 将当前单词转成小写 guu # 全行转为小写 gUU # 全行转为大写 \u0026lt;\u0026lt; # 减少缩进 \u0026gt;\u0026gt; # 增加缩进 == # 自动缩进 Ctrl+A # 增加数字 Ctrl+X # 减少数字 复制粘贴 copy 命令的格式为：\n:[range]copy{address} 参数说明：\n[range] 表示要复制的行范围，其中 copy 可缩写为 :co 或 :t {address} 表示复制的目标位置，这两个参数都可以缺省，用于表示 Vim 光标所在当前行。 例如，:5copy. 表示复制 Vim 当前打开的文件的第 5 行到当前行 (用 . 表示)，即为第 5 行创建一份副本，并放到当前行下方。\n下标列出了使用 copy 命令的缩写形式 t 进行文件复制的一些实例及用途，用于理解复制命令 copy 的用途。\n:3,5t. # 把第 3 行到第 5 行的内容复制到当前行下方 :t5 # 把当前行复制到第 5 行下方 :t. # 复制当前行到当前行下方 (等价于普通模式下的 yyp) :t$ # 把当前行复制到文本结尾 :\u0026#39;\u0026lt;,\u0026#39;\u0026gt;t0 # 把高亮选中的行复制到文件开头 常用复制粘贴命令：\np # 粘贴到光标后 P # 粘贴到光标前 v # 开始标记 y # 复制标记内容 V # 开始按行标记 Ctrl+V # 开始列标记 y$ # 复制当前位置到本行结束的内容 yy # 复制当前行 --\u0026gt; yank (copy) a line Y # 复制当前行，同 yy yiw # 复制当前单词 3yy # 复制光标下三行内容 v0 # 选中当前位置到行首 v$ # 选中当前位置到行末 viw # 选中当前单词 vib # 选中小括号内的东西 vi) # 选中小括号内的东西 vi] # 选中中括号内的东西 viB # 选中大括号内的东西 vi} # 选中大括号内的东西 vis # 选中句子中的东西 vab # 选中小括号内的东西（包含小括号本身） va) # 选中小括号内的东西（包含小括号本身） va] # 选中中括号内的东西（包含中括号本身） vaB # 选中大括号内的东西（包含大括号本身） va} # 选中大括号内的东西（包含大括号本身） :set paste # 允许粘贴模式（避免粘贴时自动缩进影响格式） :set nopaste # 禁止粘贴模式 \u0026#34;?yy # 复制当前行到寄存器 ? ，问号代表 0-9 的寄存器名称 \u0026#34;?d3j # 删除光标下三行内容，并放到寄存器 ? ，问号代表 0-9 的寄存器名称 \u0026#34;?p # 将寄存器 ? 的内容粘贴到光标后 \u0026#34;?P # 将寄存器 ? 的内容粘贴到光标前 :registers # 显示所有寄存器内容 :[range]y # 复制范围，比如 :20,30y 是复制20到30行，:10y 是复制第十行 :[range]d # 删除范围，比如 :20,30d 是删除20到30行，:10d 是删除第十行 ddp # 交换两行内容：先删除当前行复制到寄存器，并粘贴 \u0026#34;_[command] # 使用[command]删除内容，并且不进行复制（不会污染寄存器） \u0026#34;*[command] # 使用[command]复制内容到系统剪贴板（需要vim版本有clipboard支持） 文本编辑、复制粘贴中的内容可以简单总结为：\nci\u0026#39;、ci\u0026#34;、ci(、ci[、ci{、ci\u0026lt; # 分别更改这些配对标点符号中的文本内容 di\u0026#39;、di\u0026#34;、di(或dib、di[、di{或diB、di\u0026lt; # 分别删除这些配对标点符号中的文本内容 yi\u0026#39;、yi\u0026#34;、yi(、yi[、yi{、yi\u0026lt; # 分别复制这些配对标点符号中的文本内容 vi\u0026#39;、vi\u0026#34;、vi(、vi[、vi{、vi\u0026lt; # 分别选中这些配对标点符号中的文本内容 cit、dit、yit、vit，分别操作一对标签之间的内容，编辑 html、xml 很好用！\n另外，如果把上面的 i 改成 a 可以同时操作配对标点和配对标点内的内容。\n移动文本 :[range]move{address} 参数说明：\n[range] 表示要移动的行范围 {address} 表示移动的目标位置，这两个参数都可以缺省 例如：\n:m+1 # 下移1行 :m-2 # 上移1行 :8,10m2 # 把当前打开文件的第8~10行内容移动到第 2 行下方 文本对象 $ # 到行末 0 # 到行首 ^ # 到行首非空字符 iw # 整个单词（不包括分隔符） aw # 整个单词（包括分隔符） iW # 整个 WORD（不包括分隔符） aW # 整个 WORD（包括分隔符） is # 整个句子（不包括分隔符） ib # 小括号内 ab # 小括号内（包含小括号本身） iB # 大括号内 aB # 大括号内（包含大括号本身） i) # 小括号内 a) # 小括号内（包含小括号本身） i] # 中括号内 a] # 中括号内（包含中括号本身） i} # 大括号内 a} # 大括号内（包含大括号本身） i\u0026#39; # 单引号内 a\u0026#39; # 单引号内（包含单引号本身） i\u0026#34; # 双引号内 a\u0026#34; # 双引号内（包含双引号本身） 2i) # 往外两层小括号内 2a) # 往外两层小括号内（包含小括号本身） 2f) # 到第二个小括号处 2t) # 到第二个小括号前 撤销与恢复 u # 撤销命令可以组合，例如Nu N是任意整数，表示撤销N步操作，下同 U # 撤销整行操作 Ctrl+r # 撤销上一次 u 命令 Ctrl+R # 回退前一个命令 查找替换 一般模式下的查找命令：\n/pattern # 从光标处向文件尾搜索 pattern ?pattern # 从光标处向文件头搜索 pattern n # 向同一方向执行上一次搜索 N # 向相反方向执行上一次搜索 * # 向前搜索光标下的单词 # # 向后搜索光标下的单词 f\u0026lt;char\u0026gt; # 向后搜索当前行第一个为 \u0026lt;char\u0026gt; 的字符，2fv 可以找到第二个v字符 F\u0026lt;char\u0026gt; # 向前搜索当前行第一个为 \u0026lt;char\u0026gt; 的字符 t\u0026lt;char\u0026gt; # 向后搜索当前行第一个为 \u0026lt;char\u0026gt; 的字符前 T\u0026lt;char\u0026gt; # 向前搜索当前行第一个为 \u0026lt;char\u0026gt; 的字符前 ; # 重复上次的字符查找命令(f/t命令) , # 反转方向查找上次的字符查找命令(f/t命令) tx # 搜索当前行到指定 字符串 之前 fx # 搜索当前行到指定 字符串 之处 一般模式下的替换命令：\n:[range]s[ubstitute]/{pattern}/{string}/[flags] 参数说明：\npattern：就是要被替换掉的字串，可以用 regexp 來表示 string：將 pattern 由 string 所取代 [range]：有以下一些取值： [range]取值 含义 无 默认光标所在行 . 光标所在当前行 N 第 N 行 $ 最后一行 \u0026lsquo;a 标记 a 所在的行（之前要用 ma 做过标记） $-1 倒数第二行，可以对某一行加减某个数值获得确定的某行 1,10 第 1~10 行 1,$ 第一行到最后一行 1,. 第一行到当前行 .,$ 当前行到最后一行 \u0026lsquo;a,\u0026lsquo;b 标记 a 所在的行 到 标记 b 所在的行（之前要用 ma、mb 做过标记） % 所有行（和 1,$ 等价） ?str? 从当前位置向上搜索，找到第一个 str 的行（str 可以是正则） /str/ 从当前位置向下搜索，找到第一个 str 的行（str 可以是正则） 注意，上面的所有用于 range 的表示方法都可以通过 +、- 操作来设置相对偏移量。\n[flags]有以下一些取值： [flags]取值 含义 g 对指定范围内的所有匹配项（global）进行替换 c 在替换前请求用户进行确认（confirm） e 忽略执行过程中的错误 i 不区分大小写 无 只在指定范围内的第一个匹配项进行替换 举例：\n:s/p1/p2/g # 将当前行中全替换p1为p2 :%s/p1/p2/g # 将当前文件中全替换p1为p2 :%s/p1/p2/gc # 将当前文件中全替换p1为p2，并且每处询问你是否替换 :10,20s/p1/p2/g # 将第10到20行中所有p1替换为p2 :%s/1\\\\2\\/3/123/g # 将“1\\2/3” 替换为 “123”（特殊字符使用反斜杠标注） :%s/\\r//g # 删除 DOS 换行符 ^M :%s///gn # 统计某个模式的匹配个数 :%s/^\\s*$\\n//g # 删除Vim打开文件中所有空白行 :g/^\\s*$/d # 删除Vim打开文件中所有空白行 :%s/^M$//g # 删除Vim文件中显式的 ^M 符号（操作系统换行符问题） 可视模式 注：Vim 可视模式下可以选择一块编辑区域，然后对选中的文件内容执行插入、删除、替换、改变大小写等操作。！\nv # 切换到面向字符的可视模式 V # 切换到面向行的可视模式 Ctrl-V # 切换到面向列块的可视模式 \u0026gt; # 增加缩进 \u0026lt; # 减少缩进 d # 删除高亮选中的文字 x # 删除高亮选中的文字 c # 改写文字，即删除高亮选中的文字并进入插入模式 s # 改写文字，即删除高亮选中的文字并进入插入模式 y # 拷贝文字 ~ # 转换大小写 o # 跳转到标记区的另外一端 O # 跳转到标记块的另外一端 u # 标记区转换为小写 U # 标记区转换为大写 gv # 重选上次的高亮选区 g Ctrl+G # 显示所选择区域的统计信息 ggVG # 选择全文 esc # 按esc键退出可视模式 此外： Vim normal 命令可以在命令行模式执行普通模式下的命令，当 normal 命令与 Vim 可视化模式结合时，只需很少的操作就能完成大量重复性工作。\n注释命令 多行注释\nCtrl+v # 进入命令行模式，按Ctrl + v进入可视模式，然后按j, 或者k选中多行，把需要注释的行标记起来 I # 按大写字母I，再插入注释符，例如#、// esc # 按esc键就会全部注释了 取消多行注释\nCtrl+v # 进入命令行模式，按Ctrl + v进入可视模式，按字母l横向选中列的个数，例如#、//（需要选中2列） j 或 k # 按字母j，或者k选中注释符号 d # 按d键就可全部取消注释 复杂注释\n:起始行号,结束行号s/^/注释符/g（注意冒号） # 在指定的行首添加注释 :起始行号,结束行号s/^注释符//g（注意冒号） # 在指定的行首取消注释 :3,5 s/^/#/g # 注释第3-5行 :3,5 s/^#//g # 解除3-5行的注释 :1,$ s/^/#/g # 注释整个文档 :1,$ s/^#//g # 取消注释整个文档 :%s/^/#/g # 注释整个文档，此法更快 :%s/^#//g # 取消注释整个文档 位置跳转 Ctrl+O # 跳转到上一个位置 Ctrl+I # 跳转到下一个位置 Ctrl+^ # 跳转到 alternate file (当前窗口的上一个文件） % # 跳转到 {} () [] 的匹配 gd # 跳转到局部定义（光标下的单词的定义） gD # 跳转到全局定义（光标下的单词的定义） gf # 打开名称为光标下文件名的文件 [[ # 跳转到上一个顶层函数（比如C语言以大括号分隔） ]] # 跳转到下一个顶层函数（比如C语言以大括号分隔） [m # 跳转到上一个成员函数 ]m # 跳转到下一个成员函数 [{ # 跳转到上一处未匹配的 { ]} # 跳转到下一处未匹配的 } [( # 跳转到上一处未匹配的 ( ]) # 跳转到下一处未匹配的 ) [c # 上一个不同处（diff时） ]c # 下一个不同处（diff时） [/ # 跳转到 C注释开头 ]/ # 跳转到 C注释结尾 `` # 回到上次跳转的位置 \u0026#39;\u0026#39; # 回到上次跳转的位置 `. # 回到上次编辑的位置 \u0026#39;. # 回到上次编辑的位置 文件操作 :w # 保存文件（会修改文件的时间戳） :w \u0026lt;filename\u0026gt; # 按名称保存文件 :x # 保存文件并退出（不会修改文件的时间戳） :e \u0026lt;filename\u0026gt; # 打开文件并编辑 :saveas \u0026lt;filename\u0026gt; # 另存为文件 :o \u0026lt;filename\u0026gt; # 在当前窗口打开另一个文件 :r \u0026lt;filename\u0026gt; # 读取文件并将内容插入到光标后 :r !dir # 将 dir 命令的输出捕获并插入到光标后 :only # 关闭除光标所在的窗口之外的其他窗口 :close # 关闭光标所在窗口的文件 :q # 关闭光标所在的窗口并退出 :q! # 强制退出 :qa！ # 关闭所有窗口(不保存) :qall # 放弃所有操作并退出 :wa # 保存所有文件 :wall # 保存所有 :wqall # 保存所有并退出。 :cd \u0026lt;path\u0026gt; # 切换 Vim 当前路径 :pwd # 显示 Vim 当前路径 :new # 打开一个新的窗口编辑新文件 :enew # 在当前窗口创建新文件 :vnew # 在左右切分的新窗口中编辑新文件 :tabnew # 在新的标签页中编辑新文件 :version # 查看Vim版本 ZZ # 保存文件（如果有改动的话），并关闭窗口 ZQ # 不保存文件关闭窗口 打开文件 vim filename # 打开或新建文件，并将光标置于第一行首 vim + filename # 打开文件，并将光标置于最后一行首 vim +n filename # 打开文件，并将光标置于第 n 行首 vim -c cmd file # 在打开文件 file 前，先执行指定的Vim命令cmd vim -b file # 以二进制模式打开文件，该模式某些特殊字符 (如换行符 ^M) 都可以显示出来 vim -d file1 file2 # 使用Vim同时打开 file1 和 file2 文件并diff两个文件的差异 vim -r filename # 在上次正用 vim编辑时发生系统崩溃，恢复文件 vim -R file # 以只读形式打开文件，但是仍然可以使用 :wq! 写入 vim -M file # 强制性关闭修改功能，无法使用 :wq! 写入 vim -o file1 file2 # 终端中要打开vim文件时，横向分割显示多个文件 vim -O file1 file2 # 终端中要打开vim文件时，纵向分割显示多个文件 vim -x file # 以加密方式打开文件 vim +/target file # 打开 file 并将光标移动到找到的第一个 target 字符串上 已打开文件操作 :ls # 查案缓存列表 :bn # 切换到下一个缓存 :bp # 切换到上一个缓存 :bd # 删除缓存 :b 1 # 切换到1号缓存 :b abc # 切换到文件名为 abc 开头的缓存 :badd \u0026lt;filename\u0026gt; # 将文件添加到缓存列表 :set hidden # 设置隐藏模式（未保存的缓存可以被切换走，或者关闭） :set nohidden # 关闭隐藏模式（未保存的缓存不能被切换走，或者关闭） n Ctrl+^ # 切换缓存，先输入数字的缓存编号，再按 Ctrl + 6 窗口操作 :sp \u0026lt;filename\u0026gt; # 上下切分窗口并在新窗口打开文件 filename :vs \u0026lt;filename\u0026gt; # 左右切分窗口并在新窗口打开文件 filename :split # 将当前窗口再复制一个纵向窗口出来，内容同步，游标可以不同 :vsplit # 将当前窗口再复制一个横向窗口出来，内容同步，游标可以不同 Ctrl+W s # 上下切分窗口 Ctrl+W v # 左右切分窗口 Ctrl+W w # 循环切换到下一个窗口 Ctrl+W W # 循环切换到上一个窗口 Ctrl+W p # 跳到上一个访问过的窗口 Ctrl+W c # 关闭当前窗口 Ctrl+W o # 关闭其他窗口 Ctrl+W h # 跳到左边的窗口 Ctrl+W j # 跳到下边的窗口 Ctrl+W k # 跳到上边的窗口 Ctrl+W l # 跳到右边的窗口 Ctrl+W + # 增加当前窗口的行高，前面可以加数字 Ctrl+W - # 减少当前窗口的行高，前面可以加数字 Ctrl+W \u0026lt; # 减少当前窗口的列宽，前面可以加数字 Ctrl+W \u0026gt; # 增加当前窗口的列宽，前面可以加数字 Ctrl+W = # 让所有窗口宽高相同 Ctrl+W H # 将当前窗口移动到最左边 Ctrl+W J # 将当前窗口移动到最下边 Ctrl+W K # 将当前窗口移动到最上边 Ctrl+W L # 将当前窗口移动到最右边 Ctrl+W x # 交换窗口 Ctrl+W f # 在新窗口中打开名为光标下文件名的文件 Ctrl+W gf # 在新标签页中打开名为光标下文件名的文件 Ctrl+W R # 旋转窗口 Ctrl+W T # 将当前窗口移到新的标签页中 Ctrl+W P # 跳转到预览窗口 Ctrl+W z # 关闭预览窗口 Ctrl+W _ # 纵向最大化当前窗口 Ctrl+W | # 横向最大化当前窗口 标签页 :tabs # 显示所有标签页 :tabe \u0026lt;filename\u0026gt; # 在新标签页中打开文件 filename :tabn # 下一个标签页 :tabp # 上一个标签页 :tabc # 关闭当前标签页 :tabo # 关闭其他标签页 :tabn n # 切换到第n个标签页，比如 :tabn 3 切换到第三个标签页 :tabm n # 标签移动 :tabfirst # 切换到第一个标签页 :tablast # 切换到最后一个标签页 :tab help # 在标签页打开帮助 :tab drop \u0026lt;file\u0026gt; # 如果文件已被其他标签页和窗口打开则跳过去，否则新标签打开 :tab split # 在新的标签页中打开当前窗口里的文件 :tab ball # 将缓存中所有文件用标签页打开 :set showtabline=? # 设置为 0 就不显示标签页标签，1会按需显示，2会永久显示 ngt # 切换到第n个标签页，比如 2gt 将会切换到第二个标签页 gt # 下一个标签页 gT # 上一个标签页 书签 :marks # 显示所有书签 ma # 保存当前位置到书签 a ，书签名小写字母为文件内，大写全局 \u0026#39;a # 跳转到书签 a所在的行 `a # 跳转到书签 a所在位置 `. # 跳转到上一次编辑的行 \u0026#39;A # 跳转到全文书签 A [\u0026#39; # 跳转到上一个书签 ]\u0026#39; # 跳转到下一个书签 \u0026#39;\u0026lt; # 跳到上次可视模式选择区域的开始 \u0026#39;\u0026gt; # 跳到上次可视模式选择区域的结束 帮助信息 :h tutor # 入门文档 :h quickref # 快速帮助 :h index # 查询 Vim 所有键盘命令定义 :h summary # 帮助你更好的使用内置帮助系统 :h Ctrl+H # 查询普通模式下 Ctrl+H 是干什么的 :h i_Ctrl+H # 查询插入模式下 Ctrl+H 是干什么的 :h i_\u0026lt;Up\u0026gt; # 查询插入模式下方向键上是干什么的 :h pattern.txt # 正则表达式帮助 :h eval # 脚本编写帮助 :h function-list # 查看 VimScript 的函数列表 :h windows.txt # 窗口使用帮助 :h tabpage.txt # 标签页使用帮助 :h +timers # 显示对 +timers 特性的帮助 :h :! # 查看如何运行外部命令 :h tips # 查看 Vim 内置的常用技巧文档 :h set-termcap # 查看如何设置按键扫描码 :viusage # NORMAL 模式帮助 :exusage # EX 命令帮助 :version # 显示当前 Vim 的版本号和特性 外部命令 :!command # 执行一次性shell命令，如下命令：:!pwd :shell # 启动一个交互的 shell 执行多个命令，exit命令退出并返回 Vim :!ls # 运行外部命令 ls，并等待返回 :r !ls # 将外部命令 ls 的输出捕获，并插入到光标后 :w !sudo tee % # sudo以后保存当前文件 :call system(\u0026#39;ls\u0026#39;) # 调用 ls 命令，但是不显示返回内容 :!start notepad # Windows 下启动 notepad，最前面可以加 silent :sil !start cmd # Windows 下当前目录打开 cmd :%!prog # 运行文字过滤程序，如整理 json格式 :%!python -m json.tool Quickfix 窗口 :copen # 打开 quickfix 窗口（查看编译，grep等信息） :copen 10 # 打开 quickfix 窗口，并且设置高度为 10 :cclose # 关闭 quickfix 窗口 :cfirst # 跳到 quickfix 中第一个错误信息 :clast # 跳到 quickfix 中最后一条错误信息 :cc [nr] # 查看错误 [nr] :cnext # 跳到 quickfix 中下一个错误信息 :cprev # 跳到 quickfix 中上一个错误信息 拼写检查 :set spell # 打开拼写检查 :set nospell # 关闭拼写检查 ]s # 下一处错误拼写的单词 [s # 上一处错误拼写的单词 zg # 加入单词到拼写词表中 zug # 撤销上一次加入的单词 z= # 拼写建议 代码折叠 za # 切换折叠 zA # 递归切换折叠 zc # 折叠光标下代码 zC # 折叠光标下所有代码 zd # 删除光标下折叠 zD # # 递归删除所有折叠 zE # 删除所有折叠 zf # 创建代码折叠 zF # 指定行数创建折叠 zi # 切换折叠 zm # 所有代码折叠一层 zr # 所有代码打开一层 zM # 折叠所有代码，设置 foldlevel=0，设置 foldenable zR # 打开所有代码，设置 foldlevel 为最大值 zn # 折叠 none，重置 foldenable 并打开所有代码 zN # 折叠 normal，重置 foldenable 并恢复所有折叠 zo # 打开一层代码 zO # 打开光标下所有代码折叠 文档加密解密 文档加密\n加密方式打开文件时，并在屏幕左下角提示输入密码两次才可进行操作，保存文件退出后必须输入正常密码才能正确打开文件，否则会显示乱码。\nvim -x file_name # 输入加密密码 -\u0026gt; 确认密码! 注意：不修改内容也要保存。:wq，不然密码设定不会生效。 :X # 命令行模式下，输入加密密码 -\u0026gt; 确认密码! 注意：不修改内容也要保存。:wq，不然密码设定不会生效。 :set key=密码 # 命令行模式下，输入加密密码 -\u0026gt; 确认密码! 注意：不修改内容也要保存。:wq，不然密码设定不会生效。 文档解密\n:X # 命令行模式下，提示输入密码，不输入而是按 Enter。注意：不修改内容也要保存。:wq，不然解密设定不会生效。 :set key= # 命令行模式下，设置key的密码为空。注意：不修改内容也要保存。:wq，不然密码设定不会生效。 宏录制 qa # 开始录制名字为 a 的宏 q # 结束录制宏 @a # 播放名字为 a 的宏 @@ # 播放上一个宏 @: # 重复上一个ex命令（即冒号命令） 其他命令 Ctrl+X Ctrl+E # 插入模式下向上滚屏 Ctrl+X Ctrl+Y # 插入模式下向下滚屏 Ctrl+G # 显示正在编辑的文件名，以及大小和位置信息 g Ctrl+G # 显示文件的：大小，字符数，单词数和行数，可视模式下也可用 ga # 显示光标下字符的 ascii 码或者 unicode 编码 g8 # 显示光标下字符的 utf-8 编码字节序 gi # 回到上次进入插入的地方，并切换到插入模式 K # 查询光标下单词的帮助 Ctrl+PgUp # 上个标签页，GVim OK，部分终端软件需设置对应键盘码 Ctrl+PgDown # 下个标签页，GVim OK，部分终端软件需设置对应键盘码 Ctrl+R Ctrl+W # 命令模式下插入光标下单词 Ctrl+Insert # 复制到系统剪贴板（GVIM） Shift+Insert # 粘贴系统剪贴板的内容（GVIM） :set ff=unix # 设置换行为 unix :set ff=dos # 设置换行为 dos :set ff? # 查看换行设置 :set nohl # 清除搜索高亮 :set termcap # 查看会从终端接收什么以及会发送给终端什么命令 :set guicursor= # 解决 SecureCRT/PenguiNet 中 NeoVim 局部奇怪字符问题 :set t_RS= t_SH= # 解决 SecureCRT/PenguiNet 中 Vim8.0 终端功能奇怪字符 :set fo+=a # 开启文本段的实时自动格式化 :earlier 15m # 回退到15分钟前的文件内容 :map # 来查看当前 Vim 配置的 map 快捷键 :inoremap # 来查看当前 Vim 配置的 inoremap 快捷键 :nnoremap # 来查看当前 Vim 配置的 nnoremap 快捷键 :.!date # 在当前窗口插入时间 :%!xxd # 开始二进制编辑 :%!xxd -r # 保存二进制编辑 :r !curl -sL {URL} # 读取 url 内容添加到光标后 :g/^\\s*$/d # 删除空行 :g/green/d # 删除所有包含 green 的行 :v/green/d # 删除所有不包含 green 的行 :g/gladiolli/# # 搜索单词打印结果，并在结果前加上行号 :g/ab.*cd.*efg/# # 搜索包含 ab,cd 和 efg 的行，打印结果以及行号 :v/./,/./-j # 压缩空行 :Man bash # 在 Vim 中查看 man，先调用 :runtime! ftplugin/man.vim 激活 /fred\\|joe # 搜索 fred 或者 joe /\\\u0026lt;\\d\\d\\d\\d\\\u0026gt; # 精确搜索四个数字 /^\\n\\{3} # 搜索连续三个空行 查看命令历史 命令行模式下：\n:history # 查看所有命令行模式下输入的命令历史 :history search或 / 或？ # 查看搜索历史 普通模式下：\nq/ # 查看使用/输入的搜索历史 q? # 查看使用？输入的搜索历史 q: # 查看命令行历史 寄存器 查看寄存器值\n:reg # 查看所有寄存器值 :reg \u0026#34;{register_name} # 查看指定寄存器值 调取寄存器值\n\u0026#34;{register_name} # 普通模式下调取寄存器值 :Ctrl+r \u0026#34;寄存器名称 # 命令模式下（输入 Ctrl+r 后Vim会自动打出\u0026#34;寄存器引用符号） Ctrl+r 寄存器名称 # 插入模式下（无需输入寄存器引用符号\u0026#34;） Vim 寄存器分类\n名称 引用方式 说明 无名寄存器 \u0026quot;\u0026quot; 默认寄存器，所有的复制和修改操作（x、s、d、c、y）都会将该数据复制到无名寄存器 字母寄存器 \u0026ldquo;a - \u0026ldquo;z 或 \u0026ldquo;A - \u0026ldquo;Z {register_name}只能是一位的 26 个英文字母，从 a-z，A-Z 寄存器内容将会合并到对应小写字母内容后边 复制专用寄存器 \u0026ldquo;0（数字 0） 仅当使用复制操作(y)时，该数据将会同时被复制到无名寄存器和复制专用寄存器 逐级临时缓存寄存器 \u0026ldquo;1 - \u0026ldquo;9 所有不带范围（‘(’，‘)’，‘{’，‘}’）、操作涉及 1 行以上的删除修改操作（x、s、d、c）的数据都会复制到逐级临时缓存寄存器，并在新的数据加入时，逐级先后推移。1 的数据复制到 2，2 的复制到 3，最后的 9 寄存器内容将会被删除 黑洞寄存器 \u0026ldquo;_ 几乎所有的操作涉及的数据都会被复制到寄存器，如果想让操作的数据不经过寄存器，可以指定黑洞寄存器，数据到该寄存器就会消失掉，不能显示，也不存在 系统剪切板 \u0026ldquo;+ 或\u0026rdquo;* 与 Vim 外部的 GUI 交互数据时，需要使用专用的系统剪切板 表达式寄存器 \u0026ldquo;= 所有寄存器里最特殊的一个，用于计算表达式。输入完该寄存器应用后，会在命令行里提示“=”，按需输入表达式，结果将会显示到光标处 其他寄存器 Vim 设置 编辑 Vim 配置文件：\n:edit $MYVIMRC # 在Vim的命令模式下使用该命令打开 vim 配置文件 :source $MYVIMRC # Vim 配置文件的改动后，使用该命令为vim配置文件加载新的配置选项，如果vimrc文件恰好是当前活动的缓冲区，则可把此命令简化为:so %。 Vim 配置说明：\n注：Vim 配置可以在命令模式下单个设置，只在当前窗口生效！\nsyntax # 列出已经定义的语法项 syntax clear # 清除已定义的语法规则 syntax on # 允许语法高亮 syntax off # 禁止语法高亮 set history=200 # 记录 200 条历史命令 set bs=? # 设置BS键模式，现代编辑器为 :set bs=eol,start,indent set sw=4 # 设置缩进宽度为 4 set ts=4 # 设置制表符宽度为 4 set noet # 设置不展开 tab 成空格 set et # 设置展开 tab 成空格 set winaltkeys=no # 设置 GVim 下正常捕获 ALT 键 set nowrap # 关闭自动换行 set ttimeout # 允许终端按键检测超时（终端下功能键为一串ESC开头的扫描码） set ttm=100 # 设置终端按键检测超时为100毫秒 set term=? # 设置终端类型，比如常见的 xterm set ignorecase # 设置搜索是否忽略大小写 set smartcase # 智能大小写，默认忽略大小写，除非搜索内容里包含大写字母 set list # 设置显示制表符和换行符 set nu # 设置显示行号，禁止显示行号可以用 :set nonu set number # 设置显示行号，禁止显示行号可以用 :set nonumber set relativenumber # 设置显示相对行号（其他行与当前行的距离） set paste # 进入粘贴模式（粘贴时禁用缩进等影响格式的东西） set nopaste # 结束粘贴模式 set spell # 允许拼写检查 set hlsearch # 设置高亮查找 set ruler # 总是显示光标位置 set nocompatible # 设置不兼容原始 vi 模式（必须设置在最开头） set incsearch # 查找输入时动态增量显示查找结果 set insertmode # Vim 始终处于插入模式下，使用 Ctrl+o 临时执行命令 set all # 列出所有选项设置情况 Vim 模式 普通模式 # 按 Esc 或 Ctrl+[ 进入，左下角显示文件名或为空 插入模式 # 按i进入，左下角显示 --INSERT-- 可视模式 # 按v进入，左下角显示 --VISUAL-- 替换模式 # 按r或R开始，左下角显示 --REPLACE-- 命令行模式 # 按 : 或者 / 或者 ? 开始 网络资源 最新版本 https://github.com/vim/vim Windows 最新版 https://github.com/vim/vim-win32-installer/releases 插件浏览 http://vimawesome.com 正确设置 ALT/BS 键 http://www.skywind.me/blog/archives/2021 视频教程 http://vimcasts.org/ 中文帮助 http://vimcdoc.sourceforge.net/doc/help.html 中文版入门到精通 https://github.com/wsdjeg/vim-galore-zh_cn 五分钟脚本入门 http://www.skywind.me/blog/archives/2193 脚本精通 http://learnvimscriptthehardway.stevelosh.com/ 十六年使用经验 http://zzapper.co.uk/vimtips.html 配色方案 http://vimcolors.com/ TIPS 永远不要用 Ctrl+C 代替 完全不同的含义，容易错误中断运行的后台脚本 很多人使用 Ctrl+[ 代替 ，左手小指 Ctrl，右手小指 [ 熟练后很方便 某些终端中使用 Vim 8 内嵌终端如看到奇怪字符，使用 :set t_RS= t_SH= 解决 某些终端中使用 NeoVim 如看到奇怪字符，使用 :set guicursor= 解决 多使用 ciw, ci[, ci\u0026rdquo;, ci( 以及 diw, di[, di\u0026rdquo;, di( 命令来快速改写/删除文本 在行内左右移动光标时，多使用 w b e 或 W B E，而不是 h l 或方向键，这样会快很多 Shift 相当于移动加速键， w b e 移动光标很慢，但是 W B E 走的很快 自己要善于总结新技巧，比如移动到行首非空字符时用 0w 命令比 ^ 命令更容易输入 在空白行使用 dip 命令可以删除所有临近的空白行，viw 可以选择连续空白 缩进时使用 \u0026gt;8j \u0026gt;} ap =i} == 会方便很多 插入模式下，当你发现一个单词写错了，应该多用 Ctrl+W 这比 快 y d c 命令可以很好结合 f t 和 /X 比如 dt) 和 y/end c d x 命令会自动填充寄存器 \u0026ldquo;1 到 \u0026ldquo;9 , y 命令会自动填充 \u0026ldquo;0 寄存器 用 v 命令选择文本时，可以用 o 掉头选择，有时很有用 写文章时，可以写一段代码块，然后选中后执行 :!python 代码块就会被替换成结果 搜索后经常使用 :nohl 来消除高亮，使用很频繁，可以 map 到 上 搜索时可以用 Ctrl+R Ctrl+W 插入光标下的单词，命令模式也能这么用 映射按键时，应该默认使用 noremap ，只有特别需要的时候使用 map 当你觉得做某事很低效时，你应该停下来，然后思考正确的高效方式来完成 用 y 复制文本后，命令模式中 Ctrl+R 然后按双引号 0 可以插入之前复制内容 Windows 下的 GVim 可以设置 set rop=type:directx,renmode:5 增强显示 ","date":"2022-04-04T15:51:45Z","permalink":"https://aecra.github.io/article/vim-command-manual/","title":"Vim 命令速查表"},{"content":"前言 摘要 OAuth2.0 授权框架允许第三方应用获取对 HTTP 服务的有限的访问权限，既可以以资源所有者名义在资源所有者和 HTTP 服务之间进行允许的交互，也可以允许第三方应用以自己的名义进行访问。本规范取代并淘汰 RFC 5849 中描述的 OAuth 1.0 协议。\n本备忘录状态 这是一个互联网标准化过程文档。\n本文档是互联网工程任务组（IETF）的作品。它代表了 IETF 社区的一致看法。它已接受公开审阅并由互联网工程指导小组（IESG）批准公布。有关互联网标准的进一步信息可在 RFC 5741 的第 2 节找到。\n有关本文档的当前状态、勘误表以及如何对它提供反馈可参见 http://www.rfc-editor.org/info/rfc6749。\n版权声明 IETF 信托及标识为本文档的作者的个人版权所有（c）2012。保留所有权利。\n本文档受 BCP78 和 IETF 信托有关 IETF 文档的法律条款 (http://trustee.ietf.org/license-info)的约束，自本文档发布之日起生效。请仔细查阅这些文件，因为它们描述了与本文档有关的权利和限制。从本文档中提取的代码片段必须按信托法律条款 4.e 节所述包括简化 BSD 许可证文本；并且按简化 BSD 许可证中所述不附带质量保证。\n目录 [toc]\n1. 简介 在传统的客户端-服务器身份验证模式中，客户端请求服务器上限制访问的资源（受保护资源）时，需要使用资源所有者的凭据在服务器上进行身份验证。资源所有者为了给第三方应用提供受限资源的访问，需要与第三方共享它的凭据。 这造成一些问题和局限：\n需要第三方应用存储资源所有者的凭据，以供将来使用，通常是明文密码。\n需要服务器支持密码身份认证，尽管密码认证天生就有安全缺陷。\n第三方应用获得的资源所有者的受保护资源的访问权限过于宽泛，从而导致资源所有者失去对资源使用时限或使用范围的控制。\n资源所有者不能在不撤销对所有第三方的访问权限的情况下撤销对单个第三方的访问权限，而且必须通过更改第三方的密码来这样做。\n与任何第三方应用的让步导致对终端用户的密码及该密码所保护的所有数据的让步。\nOAuth 通过引入授权层以及分离客户端角色和资源所有者角色来解决这些问题。在 OAuth 中，客户端在请求受资源所有者控制并托管在资源服务器上的资源的访问权限时，将被颁发一组不同于资源所有者所拥有凭据的凭据。\n客户端获得一个访问令牌（一个代表特定作用域、生命期以及其他访问属性的字符串），用以代替使用资源所有者的凭据来访问受保护资源。访问令牌由授权服务器在资源所有者认可的情况下颁发给第三方客户端。客户端使用访问令牌访问托管在资源服务器的受保护资源。\n例如，终端用户（资源所有者）可以授权一个打印服务（客户端）访问她存储在图片分享服务（资源服务器）上的受保护图片，而无需与打印服务分享自己的用户名和密码。反之，她直接与图片分享服务信任的服务器（授权服务器）进行身份验证，该服务器颁发给打印服务具体委托凭据（访问令牌）。\n本规范是为 HTTP（[RFC2616]）协议定制。在任何非 HTTP 协议上使用 OAuth 不在本规范的范围之内。\nOAuth 1.0 协议（[RFC5849]）作为一个指导性文档发布，是一个小社区的工作成果。本标准化规范在 OAuth 1.0 的部署经验之上构建，也包括其他使用案例以及从更广泛的 IETF 社区收集到的可扩展性需求。OAuth 2.0 协议不向后兼容 OAuth 1.0。这两个版本可以在网络上共存，实现者可以选择同时支持他们。然而，本规范的用意是新的实现支持按本文档指定的 Auth 2.0，OAuth 1.0 仅用于支持现有的部署。OAuth 2.0 协议与 OAuth 1.0 协议实现细节没有太多关联。熟悉 OAuth 1.0 的实现者应该学习本文档，而不对有关 OAuth 2.0 的结构和细节做任何假设。\n1.1. 角色 OAuth 定义了四种角色：\n资源所有者\n能够授予对受保护资源访问权限的实体。当资源所有者是一个人时，它被称为终端用户。\n资源服务器\n托管受保护资源的服务器，能够接收和响应使用访问令牌对受保护资源的请求。\n客户端\n代表资源所有者并经其授权请求受保护资源的应用程序。术语\u0026quot;客户端\u0026quot;并不意味着任何特定的实现特征（例如，应用程序是否在服务器、桌面或其他设备上执行）。\n授权服务器\n在成功验证资源所有者且获得授权后颁发访问令牌给客户端的服务器。\n授权服务器和资源服务器之间的交互超出了本规范的范围。授权服务器和资源服务器可以是同一台服务器，也可以是分离的个体。一个授权服务器可以颁发多个资源服务器接受的访问令牌。\n1.2. 协议流程 +--------+ +---------------+\r| |--(A)- Authorization Request -\u0026gt;| Resource |\r| | | Owner |\r| |\u0026lt;-(B)-- Authorization Grant ---| |\r| | +---------------+\r| |\r| | +---------------+\r| |--(C)-- Authorization Grant --\u0026gt;| Authorization |\r| Client | | Server |\r| |\u0026lt;-(D)----- Access Token -------| |\r| | +---------------+\r| |\r| | +---------------+\r| |--(E)----- Access Token ------\u0026gt;| Resource |\r| | | Server |\r| |\u0026lt;-(F)--- Protected Resource ---| |\r+--------+ +---------------+\r图 1：抽象的协议流程\n图 1 中所示的抽象 OAuth 2.0 流程描述了四个角色之间的交互，包括以下步骤：\n（A）客户机向资源所有者请求授权。可以直接向资源所有者发出授权请求(如图所示) ，或者最好是通过作为中介的授权服务器间接发出。\n（B）客户端收到授权许可，这是一个代表资源所有者的授权的凭据，使用本规范中定义的四种许可类型之一或者使用扩展许可类型表示。授权许可类型取决于客户端请求授权所使用的方式以及授权服务器支持的类型。\n（C）客户机通过与授权服务器进行身份验证并显示授权许可，从而请求访问令牌。\n（D）授权服务器验证客户端身份和授权许可，若有效则颁发访问令牌。\n（E）客户端从资源服务器请求受保护资源并出示访问令牌进行身份验证。\n（F）资源服务器验证访问令牌，若有效则满足该请求。\n客户端用于从资源所有者获得授权许可（步骤（A）和（B）所示）的更好方法是使用授权服务器作为中介，如 4.1 节 图 3 所示。\n1.3. 授权许可 授权许可是一个代表资源所有者授权（访问受保护资源）的凭据，客户端用它来获取访问令牌。本规范定义了四种许可类型——授权码、隐式授权、资源所有者密码凭据和客户端凭据——以及用于定义其他类型的扩展性机制。\n1.3.1. 授权码 授权码是通过使用授权服务器做为客户端与资源所有者的中介而获得。客户端不是直接从资源所有者请求授权，而是引导资源所有者至授权服务器（由在 [RFC2616] 中定义的用户代理），授权服务器之后引导资源所有者携带授权码回到客户端。\n在引导资源所有者携带授权码返回客户端前，授权服务器会验证资源所有者身份并获得其授权。由于资源所有者只与授权服务器进行身份验证，所以客户端从未获取到资源所有者的凭据。\n授权代码提供了一些重要的安全优势，如验证客户端的能力，以及将访问令牌直接传输给客户端，而不通过资源所有者的用户代理，这避免了将其暴露给其他人，包括资源所有者。\n1.3.2. 隐式授权 隐式授权是一种简化的授权代码流程，为使用脚本语言（如 JavaScript）的浏览器中实现的客户端进行了优化。在隐式流程中，不是向客户发出授权代码，而是直接向客户发出一个访问令牌（作为资源所有者授权的结果）。这种许可类型是隐式的，因为没有中间凭据（如授权码）被颁发（之后用于获取访问令牌）。\n当在隐式授权流程中颁发访问令牌时，授权服务器不对客户端进行身份验证。在某些情况下，客户端身份可以通过用于向客户端传送访问令牌的重定向 URI 验证。访问令牌可能会暴露给资源所有者，或者对资源所有者的用户代理有访问权限的其他应用程序。\n隐式授权提高了一些客户端（如作为浏览器应用的客户端）的响应速度和效率，因为它减少了获取访问令牌所需的往返数量。然而，这种便利应该和采用隐式授权的安全影响作权衡，如那些在 10.3 和 10.16 节中所述的，尤其是当授权码许可类型可用的时候。\n1.3.3. 资源所有者密码凭据 资源所有者的密码凭证（即用户名和密码）可以直接作为授权许可授予来获得访问令牌。只有在资源所有者和客户端之间存在高度信任的情况下（例如，客户端是设备操作系统的一部分或高度特权的应用程序），以及在其他授权授予类型不可用的情况下（如授权码），才应使用该凭证。\n即使这种授予类型要求客户端直接访问资源所有者凭证，但资源所有者凭据仅被用于一次请求并被交换为访问令牌。通过长期有效的访问令牌或刷新令牌，这种许可类型可以消除客户端存储资源所有者凭据供以将来使用的需要。\n1.3.4. 客户端凭据 当授权范围限于客户端控制下的受保护资源或事先与授权服务器商定的受保护资源时客户端凭据可以被用作为一种授权许可。典型的当客户端代表自己操作（客户端也是资源所有者）或者基于与授权服务器事先商定的授权请求对受保护资源的访问权限时，客户端凭据被用作为授权许可。\n1.4. 访问令牌 访问令牌是用于访问受保护资源的凭据。访问令牌是一个字符串，表示发送给客户的授权。字符串对客户端通常是不透明的。令牌代表特定的访问范围和有效时间，由资源所有者授予，并由资源服务器和授权服务器使用。\n令牌可以表示用于检索授权信息的标识符，也可以以可验证的方式自包含授权信息(即由一些数据和签名组成的令牌字符串)。为了让客户端使用令牌，可能需要额外的身份验证凭据，这超出了本规范的范围。\n访问令牌提供了一个抽象层，将不同的授权结构（例如用户名和密码）替换为资源服务器可以理解的单个令牌。这种抽象使得发行的访问令牌比用于获得这些令牌的授权许可更加严格，同时也消除了资源服务器理解各种认证方法的需要。\n基于资源服务器的安全要求访问令牌可以有不同的格式、结构及采用的方法（如加密属性）。访问令牌的属性和用于访问受保护资源的方法超出了本规范的范围，它们在 [RFC6750] 等配套规范中定义。\n1.5. 刷新令牌 刷新令牌是用于获取访问令牌的凭据。刷新令牌由授权服务器发送给客户端，用于在当前访问令牌无效或过期时获取新的访问令牌，或者用于获取具有相同或更窄范围的其他访问令牌(访问令牌的生存期可能短于资源所有者授权的权限)。由授权服务器决定是否发出刷新令牌。如果授权服务器发出刷新令牌，那么在发出访问令牌(即图 1 中的步骤(D))时就会包含这个令牌。\n刷新令牌是表示资源所有者授予客户端授权的字符串。字符串对客户端通常是不透明的。令牌表示用于检索授权信息的标识符。与访问令牌不同，刷新令牌仅用于授权服务器，从不发送到资源服务器。\n+--------+ +---------------+\r| |--(A)------- Authorization Grant ---------\u0026gt;| |\r| | | |\r| |\u0026lt;-(B)----------- Access Token -------------| |\r| | \u0026amp; Refresh Token | |\r| | | |\r| | +----------+ | |\r| |--(C)---- Access Token ----\u0026gt;| | | |\r| | | | | |\r| |\u0026lt;-(D)- Protected Resource --| Resource | | Authorization |\r| Client | | Server | | Server |\r| |--(E)---- Access Token ----\u0026gt;| | | |\r| | | | | |\r| |\u0026lt;-(F)- Invalid Token Error -| | | |\r| | +----------+ | |\r| | | |\r| |--(G)----------- Refresh Token -----------\u0026gt;| |\r| | | |\r| |\u0026lt;-(H)----------- Access Token -------------| |\r+--------+ \u0026amp; Optional Refresh Token +---------------+\r图 2：刷新过期的访问令牌\n图 2 中的所示流程包含以下步骤：\n（A）客户端通过与授权服务器进行身份验证并出示授权许可请求访问令牌。\n（B）授权服务器对客户端进行身份验证并验证授权许可，若有效则颁发访问令牌和刷新令牌。\n（C）客户端通过出示访问令牌向资源服务器请求受保护资源。\n（D）资源服务器验证访问令牌，若有效则满足该请求。\n（E）步骤（C）和（D）重复进行，直到访问令牌到期。如果客户端知道访问令牌已过期，则跳到步骤（G），否则它将继续发起另一个对受保护资源的请求。\n（F）由于访问令牌是无效的，资源服务器返回无效令牌错误。\n（G）客户端通过与授权服务器进行身份验证并出示刷新令牌，请求一个新的访问令牌。客户端请求的身份验证基于客户端类型和授权服务器策略。\n（H）授权服务器对客户端进行身份验证并验证刷新令牌，若有效则颁发一个新的访问令牌（和可选的一个新的刷新令牌）。\n步骤（C）、（D）、（E）和（F）在本规范的范围以外，如第 7 节中所述。\n1.6. TLS 版本 每当本规范使用传输层安全性（TLS）时，TLS 的适当版本（或多个受支持的版本）将随着时间的推移而变化，这取决于广泛的部署和已知的安全漏洞。在撰写本文时，TLS 1.2 版 [RFC5246] 是最新的版本，但部署基础非常有限，可能无法立即实现。TLS 1.0 版 [RFC2246] 是部署最广泛的版本，将提供最广泛的互操作性。\n实现还可以支持满足其安全需求的其他传输层安全机制。\n1.7. HTTP 重定向 该规范广泛使用 HTTP 重定向，其中客户端或授权服务器将资源所有者的用户代理重定向到另一个目标。虽然本规范中的示例显示了 HTTP 302 状态代码的使用，但允许通过用户代理实现此重定向的任何其他方法，并将其视为实现细节。\n1.8. 互操作性 OAuth 2.0 提供了丰富的具有明确的安全性的授权框架。然而，作为一个包含许多可选组件的丰富且高度可扩展的框架，本规范本身可能会产生大量不可互操作的实现。\n此外，本规范保留了一些部分或完全未定义的必需组件（例如，客户端注册、授权服务器功能、端点发现）。如果没有这些组件，则必须针对特定的授权服务器和资源服务器手动和特定地配置客户端，以便进行互操作。\n这一框架的设计明确期望今后的工作将界定实现全面的 web 级互操作性所必需的规范性的配置和扩展。\n1.9. 符号约定 本规范中的关键词“必须”、“不能”、“必需的”、“要”、“不要”、“应该”、“不应该”、“推荐的”、“可以”以及“可选的”按 [RFC2119] 所述解释。\n本规范使用 [RFC5234] 的扩展巴科斯-诺尔范式(ABNF)表示法。此外，来自“统一资源标识符（URI）：通用语法” [RFC3986] 的规则 URI 引用也包含在内。\n某些安全相关的术语按照 [RFC4949] 中定义的意思理解。这些术语包括但不限于：“攻击”、“身份认证”、“授权”、“证书”、“机密”，“凭据”，“加密”，“身份”，“记号”，“签名”，“信任”，“验证”和“核实”。\n除非另有说明，所有协议参数的名称和值是大小写敏感的。\n2.0 客户端注册 在开始协议之前，客户端要向授权服务器注册。客户端向授权服务器注册的方式超出了本规范的范围，但通常涉及终端用户与 HTML 注册表单的互动。\n客户端注册不要求客户端与授权服务器之间的直接交互。在授权服务器支持下，注册可以依靠其他方式来建立信任关系并获取客户端的属性（如重定向 URI、客户端类型）。例如，可以使用自发的或第三方发布的断言完成注册，或者使用可信通道由授权服务器执行客户端发现。\n当注册客户端时，客户端开发者应该：\n指定 2.1 节所述的客户端类型，\n提供它的如 3.1.2 节所述的客户端重定向 URI，且\n包含授权服务器要求的任何其他信息（如，应用名称、网址、描述、Logo 图片、接受法律条款等）。\n2.1. 客户端类型 根据客户端与授权服务器安全地进行身份验证的能力（即维护客户端凭据机密性的能力），OAuth 定义了两种客户端类型：\n机密客户端\n能够维护其凭据保密性的客户端（例如，在安全服务器上运行的客户端，对客户端凭据的访问受到限制），或能够使用其他方式进行安全的客户端认证。\n公开客户端\n不能够维持其凭据的机密性（如客户端执行在由资源所有者使用的设备上，例如已安装的本地应用程序或基于 Web 浏览器的应用），且不能通过其他方式保证客户端身份验证的安全性。\n客户端认证类型是基于授权服务器对安全身份验证的定义及其可接受的客户端凭据公开级别。授权服务器不应该对客户端类型做假设。\n客户机可以实现为一组分布式组件，每个组件具有不同的客户机类型和安全上下文（例如，一个分布式客户端同时具有机密的基于服务器的组件和公开的基于浏览器的组件）。如果授权服务器不提供对这类客户端的支持，或不提供其注册方面的指导，客户端应该注册每个组件为一个单独的客户端。\n本规范是围绕以下的客户端配置设计的：\nWeb 应用程序\nWeb 应用是一个运行在 Web 服务器上的机密客户端。资源所有者通过其使用的设备上的用户代理里渲染的 HTML 用户界面访问客户端。资源所有者可以通过一个 HTML 用户界面访问资源所有者使用的设备上的用户代理客户端。客户端凭据以及发给客户端的任何访问令牌都存储在 web 服务器上，资源所有者无法访问它们。\n基于用户代理的应用程序\n基于用户代理的应用是一个公开客户端，客户端的代码从 Web 服务器下载，并在资源所有者使用的设备上的用户代理（如 Web 浏览器）中执行。协议数据和凭据对于资源所有者是可轻易访问的（且经常是可见的）。由于这些应用驻留在用户代理内，在请求授权时它们可以无缝地使用用户代理的功能。\n本机应用程序\n本机应用是一个安装、运行在资源所有者使用的设备上的公开客户端。协议数据和凭据对于资源所有者是可访问的。假定包含在应用程序中的任何客户端身份认证凭据可以被提取。另一方面，动态颁发的如访问令牌或者刷新令牌等凭据可以达到可接受的保护水平。至少，这些凭证会受到保护，免受应用程序可能与之交互的恶意服务器的攻击。在一些平台上，这些凭证可能被保护免于被驻留在相同设备上的其他应用接触。\n2.2. 客户端标识 授权服务器颁发给已注册客户端客户端标识——一个客户端提供的代表其注册信息的唯一字符串。客户端标识不是一个秘密，它暴露给资源所有者并且不能单独用于客户端身份验证。客户端标识对于授权服务器是唯一的。\n客户端的字符串大小本规范未定义。客户端应该避免对标识大小做假设。授权服务器应记录其发放的任何标识的大小。\n2.3. 客户端身份验证 如果客户端类型是机密的，客户端和授权服务器建立符合授权服务器安全性要求的客户端身份验证方法。授权服务器可以接受符合其安全要求的任何形式的客户端身份验证。\n机密客户端通常颁发（或建立）一组客户端凭据用于与授权服务器进行身份验证（例如，密码、公/私钥）。\n授权服务器可以与公共客户端建立客户端身份验证方法。然而，授权服务器不能依靠公共客户端身份验证达到识别客户端的目的。\n客户端在每次请求中不能使用一个以上的身份验证方法。\n2.3.1. 客户端密码 拥有客户端密码的客户端可以使用 [RFC2617] 中定义的 HTTP 基本身份验证方案与授权服务器进行身份验证。客户端标识使用按照 附录 B 的“application/x-www-form-urlencoded”编码算法编码，编码后的值用作用户名；客户端密码使用相同的算法编码并用作密码。授权服务器必须支持 HTTP 基本身份验证方案，用于验证被颁发客户端密码的客户端的身份。\n例如（额外的换行仅用于显示目的）：\nAuthorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\r此外，授权服务器可以使用下列参数支持在请求正文中包含客户端凭据：\nclient_id\n必需的。如 2.2 节所述的注册过程中颁发给客户端的客户端标识。\nclient_secret\n必需的。客户端密钥。若客户端密钥是一个空字符串则可以忽略该参数。\n不建议使用这两个参数在请求正文中包含客户端凭据，并且应限于无法直接使用 HTTP 基本身份验证方案（或其他基于密码的 HTTP 身份验证方案）的客户端。参数只能在请求正文中传输，不能包含在请求 URI 中。\n例如，一个刷新访问令牌（第 6 节）的请求使用正文参数（额外的换行仅用于显示目的）：\nPOST /token HTTP/1.1\rHost: server.example.com\rContent-Type: application/x-www-form-urlencoded\rgrant_type=refresh_token\u0026amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\u0026amp;client_id=s6BhdRkqt3\u0026amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\r当使用密码身份验证发送请求时，授权服务器必须要求使用如 1.6 所述的 TLS。\n由于此客户端身份验证方法涉及密码，因此授权服务器必须保护使用密码的任何端点免受暴力攻击。\n2.3.2. 其他身份验证方法 授权服务器可以支持任何与其安全要求匹配的合适的 HTTP 身份验证方案。当使用其他身份验证方法时，授权服务器必须定义客户端标识（注册记录）和认证方案之间的映射。\n2.4. 未注册的客户端 本规范不排除使用未注册的客户端。然而，使用这样的客户端超出了本规范的范围，并需要额外的安全性分析并审查其互操作性影响。\n3. 协议端点 授权过程采用了两个授权服务器端点（HTTP 资源）：\n授权端点——客户端用其通过用户代理重定向从资源所有者获取授权。\n令牌端点——客户端用其将授权许可交换为访问令牌，通常伴有客户端身份验证。\n以及一种客户端端点：\n重定向端点——授权服务器用其通过资源所有者用户代理向客户端返回含有授权凭据的响应。 并不是每种授权许可类型都采用两种端点。\n扩展许可类型可以按需定义其他端点。\n3.1. 授权端点 授权端点用于与资源所有者交互来获取授权许可。 授权服务器必须先验证资源所有者的身份。 授权服务器对资源所有者进行身份验证的方式（例如，用户名和密码登录、会话 cookies）超出了本规范的范围。\n客户端获得授权端点位置的方式超出了本文档范围，但该位置通常在服务文档中提供。\n端点 URI 可以包含“application/x-www-form-urlencoded”格式（按附录 B）的查询部分（[RFC3986] 的 3.4 节），当添加额外的查询参数时必须保留该部分。端点 URI 不得包含该部分的任何内容。\n由于对授权端点的请求会导致用户身份验证和明文凭证的传输（在 HTTP 响应中），因此授权服务器在向授权端点发送请求时必须要求使用第 1.6 节所述的 TLS。\n授权服务器对于授权端点必须支持使用 HTTP“GET”方法 [RFC2616]，也可以支持使用“POST”的方法。\n不带值发送的参数必须从请求中省略。授权服务器必须忽略无法识别的请求参数。请求和响应参数不能重复。\n3.1.1. 响应类型 授权端点被授权码类型和隐式授权类型流程使用。客户端使用下列参数通知授权服务器期望的许可类型：\nresponse_type\n必需的。该值必须是第 4.1.1 节所述的用于请求授权码的“代码”、第 4.2.1 节所述的用于请求访问令牌（隐式授权）的“令牌”或第 8.4 节所述的注册扩展值之一。\n扩展响应类型可以包含一个空格（%x20）分隔的值的列表，值的顺序并不重要（例如，响应类型“a b”与“b a”相同）。 这样的复合响应类型的含义由他们各自的规范定义。\n如果授权请求缺少“response_type”参数，或者响应类型不被理解，那么授权服务器必须返回一个 4.1.2.1 所述的错误响应。\n3.1.2. 重定向端点 在完成与资源所有者的交互后，授权服务器引导资源所有者的用户代理返回到客户端。授权服务器重定向用户代理至客户端的重定向端点，该端点是之前在客户端注册过程中或者发起授权请求时与授权服务器建立的。\n重定向端点 URI 必须是如 [RFC3986] 的 3.4 节所述的绝对 URI。端点 URI 可以包含“application/x-www-form-urlencoded”格式（按附录 B）的查询部分（[RFC3986] 的 3.4 节），当添加额外的查询参数时必须保留该部分。端点 URI 不得包含该部分的任何内容。\n3.1.2.1. 端点请求的机密性 当所请求的响应类型是“code”或“token”时，或者当重定向请求将引起在机密凭据通过公开网络传输时，重定向端点应该使用 1.6 节所述的 TLS。本规范没有强制使用 TLS，因为在撰写本规范时，要求客户端部署 TLS 对许多客户端开发人员来说是一个重大障碍。如果 TLS 不可用，授权服务器应该在重定向之前就不安全的端点向资源所有者发出警告（例如，在授权请求期间显示一条信息）。\n传输层安全的缺乏可能对客户端及它被授权访问的受保护资源的安全具有严重影响。当授权过程被客户端用作授权最终用户身份验证的一种形式（例如，第三方登录服务）时，传输层安全性的使用尤为关键。\n3.1.2.2. 注册要求 授权服务器必须要求下列客户端注册它们的重定向端点：\n公开客户端。\n采用隐式授权类型的机密客户端。\n授权服务器应该要求所有客户端在使用授权端点之前注册其重定向端点。\n授权服务器应该要求客户端提供完整的重定向 URI（客户端可以使用“state”请求参数实现每请求自定义）。如果要求完整的重定向 URI 注册不可行，授权服务器应该要求注册 URI 方案、授权和路径（允许客户端在请求授权时仅动态更改重定向 URI 的查询部分）。\n授权服务器可以允许客户端注册多个重定向端点。\n缺少重定向 URI 注册的要求，可能使攻击者如 10.15 所述将授权端点用作自由重定向端点。\n3.1.2.3. 动态配置 客户端注册多个重定向 URI 时，如果只有部分或没有重定向 URI 被注册，客户端必须使用“redirect_uri”请求参数在授权请求中包含重定向 URI。\n当授权请求中包含重定向 URI 时，如果存在已注册的重定向 URI，授权服务器必须将收到的值与 [RFC3986] 第 6 节中定义的至少一个已注册重定向 URI（或 URI 组件）进行比较和匹配。如果客户端注册包含完整重定向 URI，则授权服务器必须使用 [RFC3986] 第 6.2.1 节中定义的简单字符串比较方法来比较这两个 URI。\n3.1.2.4. 无效端点 如果由于缺失、无效或不匹配的重定向 URI 而验证失败，授权服务器应该通知资源所有者该错误且不能重定向用户代理到无效的重定向 URI。\n3.1.2.5. 端点内容 对客户端端点的重定向请求通常会产生一个 HTML 文档响应，该响应由用户代理处理。如果 HTML 响应直接作为重定向请求的结果提供，则 HTML 文档中包含的任何脚本都将在完全访问重定向 URI 及其包含的凭据的情况下执行。\n客户端不应该在重定向端点的响应中包含任何第三方的脚本（例如，第三方数据分析、社交插件、广告网络）。相反，它应该从 URI 中提取凭据，并再次将用户代理重定向到另一个端点，而不暴露凭据（在 URI 中或其他地方）。如果包含第三方脚本，客户端必须确保它自己的脚本（用于从 URI 中提取凭据并从 URI 中删除）将首先执行。\n3.2. 令牌端点 客户端通过提交它的授权许可或刷新令牌从令牌端点获取访问令牌。令牌端点被用于除了隐式授权类型（因为访问令牌是直接颁发的）外的所有授权许可中。\n客户端通过何种方式获取令牌端点的位置超出了本文档范围，但该位置通常在服务文档中提供。\n端点 URI 可以包含“application/x-www-form-urlencoded”格式（按附录 B）的查询部分（[RFC3986] 的 3.4 节），当添加额外的查询参数时必须保留该部分。端点 URI 不得包含该部分的任何内容。\n由于向令牌端点的请求产生明文凭据的传输（在 HTTP 请求和响应中），当向令牌端点发送请求时，授权服务器必须要求使用 1.6 节所述的 TLS。\n当发起访问令牌请求时，客户端必须使用 HTTP “POST”方法。\n不带值发送的参数必须从请求中省略。授权服务器必须忽略无法识别的请求参数。请求和响应参数不能重复。\n3.2.1. 客户端身份验证 在向令牌端点发起请求时，机密客户端或其他被颁发客户端凭据的客户端必须如 2.3 节所述与授权服务器进行身份验证。客户端身份验证用于：\n强制将刷新令牌和授权代码绑定到颁发的客户端。当授权码通过不安全的通道传输到重定向端点，或者重定向 URI 尚未完全注册时，客户端身份验证至关重要。\n通过禁用客户端或更改其凭据来恢复被攻击的客户端，从而防止攻击者滥用窃取的刷新令牌。更改一组客户端凭据要比撤销一整套刷新令牌快得多。\n实现身份验证管理的最佳实践，要求定期轮换令牌。轮换一整套刷新令牌可能会很困难，而轮换一组客户端凭据则要容易得多。\n在向令牌端点发送请求时，客户端可以使用“client_id”请求参数标识自己。向令牌端点的“authorization_code”和“grant_type”请求中，未经身份验证的客户端必须发送它的“client_id”，以防止自己无意中接受一个用于有不同“client_id”的客户端的代码。这保护了客户端免于被替换授权码。（它没有对受保护资源提供额外的安全。）\n3.3. 访问令牌作用域 授权端点和令牌端点允许客户端使用“scope”请求参数指定访问请求的作用域。反过来，授权服务器使用“scope”响应参数通知客户端颁发的访问令牌的作用域。\nscope 参数的值表示为以空格分隔，大小写敏感的字符串。 该字符串由授权服务器定义。如果该值包含多个以空格分隔的字符串，它们的顺序无关紧要，每个字符串都会向请求范围添加一个额外的访问范围。\nscope = scope-token *( SP scope-token )\rscope-token = 1*( %x21 / %x23-5B / %x5D-7E )\r根据授权服务器策略或资源所有者的指示，授权服务器可以完全或部分忽略客户端请求的范围。如果颁发的访问令牌作用域与客户端请求的作用域不同，则授权服务器必须包含“作用域”响应参数，以通知客户端实际许可的作用域。\n如果客户端在请求授权时忽略了 scope 参数，则授权服务器必须使用预定义的默认值处理该请求，或者使请求失败以指示无效作用域。授权服务器应记录其范围要求和默认值（如果定义）。\n4. 获得授权 为了请求访问令牌，客户端从资源所有者处获得授权。授权以授权许可的形式表示，客户端使用授权许可请求访问令牌。OAuth 定义了四种授权类型：授权码、隐式授权、资源所有者密码凭据和客户端凭据。它还提供了一种扩展机制来定义额外的授权类型。\n4.1. 授权码许可 授权码许可类型用于获取访问令牌和刷新令牌，并针对机密客户端进行了优化。由于这是一个基于重定向的流程，客户端必须能够与资源所有者的用户代理（通常是 Web 浏览器）进行交互并能够接收来自授权服务器的传入请求（通过重定向）。\n+----------+\r| Resource |\r| Owner |\r| |\r+----------+\r^\r|\r(B)\r+----|-----+ Client Identifier +---------------+\r| -+----(A)-- \u0026amp; Redirection URI ----\u0026gt;| |\r| User- | | Authorization |\r| Agent -+----(B)-- User authenticates ---\u0026gt;| Server |\r| | | |\r| -+----(C)-- Authorization Code ---\u0026lt;| |\r+-|----|---+ +---------------+\r| | ^ v\r(A) (C) | |\r| | | |\r^ v | |\r+---------+ | |\r| |\u0026gt;---(D)-- Authorization Code ---------' |\r| Client | \u0026amp; Redirection URI |\r| | |\r| |\u0026lt;---(E)----- Access Token -------------------'\r+---------+ (w/ Optional Refresh Token)\r注：说明步骤（A）、（B）和（C）的直线因为通过用户代理而被分为两部分。\n图 3：授权码流程\n在图 3 中所示的流程包括以下步骤：\n（A）客户端通过将资源所有者的用户代理定向到授权端点来开始流程。客户端包括它的客户端标识、请求范围、本地状态和重定向 URI，一旦访问被许可（或拒绝）授权服务器将重定向用户代理回到该 URI。\n（B）授权服务器验证资源拥有者的身份（通过用户代理），并确定资源所有者是否授予或拒绝客户端的访问请求。\n（C）假设资源所有者许可访问，授权服务器使用之前（在请求时或客户端注册时）提供的重定向 URI 重定向用户代理回到客户端。重定向 URI 包括授权码和之前客户端提供的任何本地状态。\n（D）客户端通过包含在上一步中接收的授权代码，从授权服务器的令牌端点请求访问令牌。发出请求时，客户端会和授权服务器进行身份验证。客户端包括用于获取验证授权代码的重定向 URI。\n（E）授权服务器对客户端进行身份验证，验证授权代码，并确保接收的重定向 URI 与在步骤（C）中用于重定向客户端的 URI 相匹配。如果验证成功，授权服务器使用访问令牌和刷新令牌（可选）进行响应。\n4.1.1. 授权请求 客户端通过按 附录 B 使用“application/x-www-form-urlencoded”格式向授权端点 URI 的查询部分添加下列参数构造请求 URI：\nresponse_type\n必需的。值必须被设置为“code”。\nclient_id\n必需的。如 2.2 节所述的客户端标识。\nredirect_uri\n可选的。如 3.1.2 节所述。\nscope\n可选的。如 3.3 节所述的访问请求的作用域。\nstate\n推荐的。客户端用于维护请求和回调之间的状态的不透明值。授权服务器在将用户代理重定向回客户端时包含此值。该参数应用于防止第 10.12 节所述跨域请求伪造。\n客户端使用 HTTP 重定向响应将资源所有者重定向到构造的 URI，或者采用用户代理支持的其他方法 。 例如，客户端重定向用户代理发起下述使用 TLS 的 HTTP 请求（额外的换行仅用于显示目的）：\nGET /authorize?response_type=code\u0026amp;client_id=s6BhdRkqt3\u0026amp;state=xyz\u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\rHost: server.example.com\r授权服务器验证该请求，确保所有需要的参数已提交且有效。如果请求是有效的，授权服务器对资源所有者进行身份验证并获得授权决策（通过询问资源所有者或通过其他方式获得许可）。\n确定决策后，授权服务器使用 HTTP 重定向响应或通过用户代理提供的其他方式将用户代理定向到客户端提供的重定向 URI。\n4.1.2. 授权响应 如果资源所有者许可访问请求，授权服务器将发布一个授权代码，并通过使用“application/x-www-form-urlencoded”格式，按照附录 B 向重定向 URI 的查询部分添加以下参数，并将其发送给客户端：\ncode\n必需的。授权服务器生成的授权代码。授权码必须在发布后不久到期，以降低泄漏风险。建议授权代码的最长生存时间为 10 分钟。客户不得多次使用授权码。如果一个授权码被多次使用，授权服务器必须拒绝该请求，并在可能的情况下撤销之前基于该授权码颁发的所有令牌。授权代码绑定到客户端标识符和重定向 URI。\nstate\n如果客户端授权请求中存在“state”参数，则为必须的。该值从客户端获取。\n例如，授权服务器通过发送以下 HTTP 响应重定向用户代理：\nHTTP/1.1 302 Found\rLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\u0026amp;state=xyz\r客户端必须忽略无法识别的响应参数。本规范未定义授权码字符串大小。客户应该避免对代码值大小进行假设。授权服务器应该记录它发出的任何值的大小。\n4.1.2.1. 错误响应 如果请求因重定向 URI 丢失、无效或不匹配而失败，或者如果客户端标识符丢失或无效，授权服务器应将错误通知资源所有者，并且不得自动将用户代理重定向到无效的重定向 URI。\n如果资源所有者拒绝访问请求，或者请求因缺少或无效的重定向 URI 以外的原因而失败，授权服务器将根据附录 B，通过使用“application/x-www-form-urlencoded”格式向重定向 URI 的查询部分添加以下参数来通知客户端：\nerror\n必需的。下列 ASCII[USASCII] 错误代码之一：\ninvalid_request\n请求缺少必需的参数、包含无效的参数值、包含重复参数或格式不正确。\nunauthorized_client\n客户端未被授权使用此方法请求授权码。\naccess_denied\n资源所有者或授权服务器拒绝该请求。\nunsupported_response_type\n授权服务器不支持使用此方法获得授权码。\ninvalid_scope\n请求的范围无效，未知的或格式不正确。\nserver_error\n授权服务器遇到意外情况，无法满足请求。（之所以需要此错误代码，是因为无法通过 HTTP 重定向将 500 内部服务器错误 HTTP 状态代码返回给客户端。）\ntemporarily_unavailable\n由于服务器临时超载或维护，授权服务器当前无法处理请求。（需要此错误代码，因为无法通过 HTTP 重定向将 503 服务不可用的 HTTP 状态代码返回给客户端。）\n“error”参数的值不能包含集合 ％x20-21 / ％x23-5B / ％x5D-7E 以外的字符。\nerror_description\n可选的。提供额外的人类可读的 ASCII[USASCII] 信息文本，用于协助客户端开发人员理解所发生的错误。\n“error_description”参数的值不能包含集合 ％x20-21 / ％x23-5B / ％x5D-7E 以外的字符。\nerror_uri\n可选的。指向包含有关错误信息的人类可读的网页 URI，用于向客户端开发人员提供关于该错误的额外信息。\n“error_uri”参数值必须符合 URI 参考语法，因此不能包含集合 ％x21 / %x23-5B / ％x5D-7E 以外的字符。\nstate\n如果客户端授权请求中存在“state”参数，则为必须的。该值从客户端获取。\n例如，授权服务器通过发送以下 HTTP 响应重定向用户代理：\nHTTP/1.1 302 Found\rLocation: https://client.example.com/cb?error=access_denied\u0026amp;state=xyz\r4.1.3. 访问令牌请求 客户端通过使用附录 B 中的“application/x-www-form-urlencoded”格式发送以下参数向令牌端点发出请求，HTTP 请求实体体中的字符编码为 UTF-8：\ngrant_type\n必需的。值必须被设置为“authorization_code”。\ncode\n必需的，从授权服务器收到的授权码。\nredirect_uri\n必需的，如第 4.1.1 节所述，如果授权请求中包含“redirect_uri”参数，那么此值必须相同。\nclient_id\n必需的，如果客户端没有如 3.2.1 节所述与授权服务器进行身份认证。\n如果客户端类型是机密的或客户端被颁发了客户端凭据（或选定的其他身份验证要求），客户端必须如按照第 3.2.1 节所述与授权服务器进行身份验证。\n例如，客户端使用 TLS 发起如下的 HTTP 请求（额外的换行符仅用于显示目的）：\nPOST /token HTTP/1.1\rHost: server.example.com\rAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\rContent-Type: application/x-www-form-urlencoded\rgrant_type=authorization_code\u0026amp;code=SplxlOBeZQQYbYS6WxSbIA\u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\r授权服务器必须：\n要求机密客户端或任何被颁发了客户端凭据（或有其他身份验证要求）的客户端进行客户端身份验证，\n如果包含客户端身份验证，则对客户端进行身份验证，\n确保将授权码颁发给经过身份验证的机密客户端，或者如果客户端是公开的，请确保将代码颁发给请求中的“client_id”，\n验证授权码是有效的，并\n如果“redirect_uri”参数包含在第 4.1.1 节所述的初始授权请求中，则确保给出“redirect_uri”参数，且如果包含则确保它们的值相同。\n4.1.4. 访问令牌响应 如果访问令牌请求有效且被授权，授权服务器会发出如第 5.1 节所述的访问令牌和可选的刷新令牌。如果请求客户端身份验证失败或无效，授权服务器将返回如第 5.2 节所述的错误响应。\n一个成功响应的样例：\nHTTP/1.1 200 OK\rContent-Type: application/json;charset=UTF-8\rCache-Control: no-store\rPragma: no-cache\r{\r\u0026quot;access_token\u0026quot;:\u0026quot;2YotnFZFEjr1zCsicMWpAA\u0026quot;,\r\u0026quot;token_type\u0026quot;:\u0026quot;example\u0026quot;,\r\u0026quot;expires_in\u0026quot;:3600,\r\u0026quot;refresh_token\u0026quot;:\u0026quot;tGzv3JOkF0XG5Qx2TlKWIA\u0026quot;,\r\u0026quot;example_parameter\u0026quot;:\u0026quot;example_value\u0026quot;\r}\r4.2. 隐式授权 隐式授权类型用于获取访问令牌（它不支持颁发刷新令牌），并且针对已知可操作特定重定向 URI 的公共客户端进行了优化。这些客户端通常使用 JavaScript 等脚本语言在浏览器中实现。\n由于这是一个基于重定向的流程，客户端必须能够与资源所有者的用户代理（通常是 Web 浏览器）进行交互并能够接收来自授权服务器的传入请求（通过重定向）。\n与授权码许可类型不同，在这种授权类型中，客户端分别发出授权请求和访问令牌请求，客户端接收访问令牌作为授权请求的结果。\n隐式授权类型不包括客户端身份验证，并且依赖于资源所有者的存在和重定向 URI 的注册。 因为访问令牌被编码到重定向 URI 中，所以它可能会暴露给资源所有者和驻留在同一设备上的其他应用程序。\n+----------+\r| Resource |\r| Owner |\r| |\r+----------+\r^\r|\r(B)\r+----|-----+ Client Identifier +---------------+\r| -+----(A)-- \u0026amp; Redirection URI ---\u0026gt;| |\r| User- | | Authorization |\r| Agent -|----(B)-- User authenticates --\u0026gt;| Server |\r| | | |\r| |\u0026lt;---(C)--- Redirection URI ----\u0026lt;| |\r| | with Access Token +---------------+\r| | in Fragment\r| | +---------------+\r| |----(D)--- Redirection URI ----\u0026gt;| Web-Hosted |\r| | without Fragment | Client |\r| | | Resource |\r| (F) |\u0026lt;---(E)------- Script ---------\u0026lt;| |\r| | +---------------+\r+-|--------+\r| |\r(A) (G) Access Token\r| |\r^ v\r+---------+\r| |\r| Client |\r| |\r+---------+\r注：说明步骤（A）和（B）的直线因为通过用户代理而被分为两部分。\n图 4：隐式授权流程\n图 4 中的所示流程包含以下步骤：\n（A）客户端通过将资源所有者的用户代理定向到授权端点来开始流程。客户端包括它的客户端标识、请求范围、本地状态和重定向 URI，一旦访问被许可（或拒绝）授权服务器将重定向用户代理回到该 URI。\n（B）授权服务器验证资源拥有者的身份（通过用户代理），并确定资源所有者是否授予或拒绝客户端的访问请求。\n（C）假设资源所有者授予访问权限，授权服务器使用之前提供的重定向 URI 将用户代理重定向回客户端。重定向 URI 在 URI 片段中包含访问令牌。\n（D）用户代理通过向 Web 托管的客户端资源（不包括根据 [RFC2616] 的片段）发出请求来遵循重定向指令。 用户代理在本地保留片段信息。\n（E）Web 托管的客户端资源返回一个网页（通常是带有嵌入式脚本的 HTML 文档），该网页能够访问包含用户代理保留的片段在内的完整重定向 URI 并提取包含在片段中的访问令牌（和其他参数）。\n（F）用户代理在本地执行由 Web 托管的客户端资源提供的脚本，从而提取访问令牌。\n（G）用户代理传送访问令牌给客户端。\n参见 1.3.2 节和第 9 节了解使用隐式授权的背景。参见 10.3 节和 10.16 节了解当使用隐式授权时重要的安全注意事项。\n4.2.1. 授权请求 客户端通过按 附录 B 使用“application/x-www-form-urlencoded”格式向授权端点 URI 的查询部分添加下列参数构造请求 URI：\nresponse_type\n必需的。值必须设置为“token”。\nclient_id\n必需的。如 2.2 节所述的客户端标识。\nredirect_uri\n可选的。如 3.1.2 节所述。\nscope\n可选的。如 3.3 节所述的访问请求的范围。\nstate\n推荐的。客户端用来维护请求和回调之间状态的不透明值。授权服务器在将用户代理重定向回客户端时包含此值。该参数应该用于防止跨站点请求伪造，如第 10.12 节所述。\n客户端使用 HTTP 重定向响应或通过用户代理可用的其他方式将资源所有者定向到构造的 URI。\n例如，客户端定向用户代理使用 TLS 发出以下 HTTP 请求（额外的换行仅用于显示目的）：\nGET /authorize?response_type=token\u0026amp;client_id=s6BhdRkqt3\u0026amp;state=xyz\u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\rHost: server.example.com\r授权服务器验证请求以确保所有必需的参数都存在且有效。 授权服务器必须验证它将访问令牌重定向到的重定向 URI 是否与第 3.1.2 节所述的客户端注册的重定向 URI 匹配。\n如果请求是有效的，授权服务器对资源所有者进行身份验证并获得授权决策（通过询问资源所有者或通过经由其他方式确定批准）。\n当确定决策后，授权服务器使用 HTTP 重定向响应向提供的客户端重定向 URI 定向用户代理，或者通过经由用户代理至该 URI 的其他可行方法\n当确定决策后，授权服务器使用 HTTP 重定向响应或通过用户代理可用的其他方式将用户代理定向到重定向 URI。\n4.2.2. 访问令牌响应 如果资源所有者许可访问请求，授权服务器颁发访问令牌，通过使用按 附录 B )的“application/x-www-form-urlencoded”格式向重定向 URI 的片段部分添加下列参数传递访问令牌至客户端：\naccess_token\n必需的。授权服务器颁发的访问令牌。\ntoken_type\n必需的。如 7.1 节所述的颁发的令牌的类型。值是大小写敏感的。\nexpires_in\n推荐的。以秒为单位的访问令牌生命周期。例如，值“3600”表示访问令牌将在从生成响应时的 1 小时后到期。如果省略，则授权服务器应该通过其他方式提供过期时间，或者记录默认值。\nscope\n若与客户端请求的范围相同则可选，否则必需。如 3.3 节所述的访问令牌的范围。\nstate\n如果客户端授权请求中存在“state”参数，则必需。从客户端收到的具体值。\n授权服务器不能颁发刷新令牌。\n例如，授权服务器通过发送以下 HTTP 响应重定向用户代理：（额外的换行符仅用于显示目的）：\nHTTP/1.1 302 Found\rLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\u0026amp;state=xyz\u0026amp;token_type=example\u0026amp;expires_in=3600\r开发人员应注意，一些用户代理不支持在 HTTP“Location”响应头字段中包含片段部分。这些客户端需要使用除了 3xx 重定向响应以外的其他方法来重定向客户端——例如，返回一个 HTML 页面，其中包含一个具有链接到重定向 URI 操作的“继续”按钮。\n客户端必须忽略无法识别的响应参数。 本规范未定义访问令牌字符串大小。 客户端应避免对价大小做出假设。 授权服务器应该记录它发出的任何值的大小。\n4.2.2.1. 错误响应 如果请求因重定向 URI 丢失、无效或不匹配而失败，或者如果客户端标识符丢失或无效，授权服务器应将错误通知资源所有者，并且不得自动将用户代理重定向到无效的重定向 URI。\n如果资源所有者拒绝访问请求，或者请求因缺少或无效的重定向 URI 以外的原因而失败，授权服务器将根据附录 B，通过使用“application/x-www-form-urlencoded”格式向重定向 URI 的查询部分添加以下参数来通知客户端：\nerror\n必需的。下列 ASCII[USASCII] 错误代码之一：\ninvalid_request\n请求缺少必需的参数、包含无效的参数值、包含重复参数或格式不正确。\nunauthorized_client\n客户端未被授权使用此方法请求授权码。\naccess_denied\n资源所有者或授权服务器拒绝该请求。\nunsupported_response_type\n授权服务器不支持使用此方法获得授权码。\ninvalid_scope\n请求的范围无效，未知的或格式不正确。\nserver_error\n授权服务器遇到意外情况，无法满足请求。（之所以需要此错误代码，是因为无法通过 HTTP 重定向将 500 内部服务器错误 HTTP 状态代码返回给客户端。）\ntemporarily_unavailable\n由于服务器临时超载或维护，授权服务器当前无法处理请求。（需要此错误代码，因为无法通过 HTTP 重定向将 503 服务不可用的 HTTP 状态代码返回给客户端。）\n“error”参数的值不能包含集合 ％x20-21 / ％x23-5B / ％x5D-7E 以外的字符。\nerror_description\n可选的。提供额外信息的人类可读的 ASCII[USASCII]文本，用于协助客户端开发人员理解所发生的错误。\n“error_description”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E 以外的字符。\nerror_uri\n可选的。指向包含有关错误信息的人类可读的网页 URI，用于向客户端开发人员提供关于该错误的额外信息。\n“error_uri”参数值必须符合 URI 参考语法，因此不能包含集合 ％x21 / %x23-5B /％x5D-7E 以外的字符。\nstate 如果客户端授权请求中存在“state”参数，则为必须的。该值从客户端获取。\n例如，授权服务器通过发送以下 HTTP 响应重定向用户代理：\nHTTP/1.1 302 Found\rLocation: https://client.example.com/cb#error=access_denied\u0026amp;state=xyz\r4.3. 资源所有者密码凭据许可 资源所有者密码凭证授予类型适用于资源所有者与客户端具有信任关系的情况，例如设备操作系统或高特权应用程序。授权服务器在启用此授权类型时应特别小心，并且仅在其他流程不可行时才允许它。\n此授权类型适用于能够获取资源所有者凭据（用户名和密码，通常使用交互式表单）的客户端。它还用于使用直接身份验证方案（例如 HTTP Basic 或 Digest 身份验证）将现有客户端迁移到 OAuth，方法是将存储的凭据转换为访问令牌。\n+----------+\r| Resource |\r| Owner |\r| |\r+----------+\rv\r| Resource Owner\r(A) Password Credentials\r|\rv\r+---------+ +---------------+\r| |\u0026gt;--(B)---- Resource Owner -------\u0026gt;| |\r| | Password Credentials | Authorization |\r| Client | | Server |\r| |\u0026lt;--(C)---- Access Token ---------\u0026lt;| |\r| | (w/ Optional Refresh Token) | |\r+---------+ +---------------+\r图 5：资源所有者密码凭据流程\n图 5 中的所示流程包含以下步骤：\n（A）资源所有者提供给客户端它的用户名和密码。\n（B）客户端通过携带从资源所有者收到的凭据，从授权服务器的令牌端点请求访问令牌。发出请求时，客户端向授权服务器进行身份验证。\n（C）授权服务器对客户端进行身份验证，验证资源所有者的凭证，如果有效，颁发访问令牌。\n4.3.1. 授权请求和响应 客户端获取资源所有者凭据的方法超出了本规范的范围。 一旦获得访问令牌，客户端必须丢弃凭据。\n4.3.2. 访问令牌请求 客户端通过使用按 附录 B “application/x-www-form-urlencoded”格式在 HTTP 请求实体正文中发送下列 UTF-8 字符编码的参数向令牌端点发起请求：\ngrant_type\n必需的。值必须设置为“password”。\nusername\n必需的。资源所有者的用户名。\npassword\n必需的。资源所有者的密码。\nscope\n可选的。如 3.3 节所述的访问请求的范围。\n如果客户端类型是机密的或客户端被颁发了客户端凭据（或选定的其他身份验证要求），客户端必须如 3.2.1 节所述与授权服务器进行身份验证。\n例如，客户端在传输层安全下发起如下 HTTP 请求（额外的换行仅用于显示目的）：\nPOST /token HTTP/1.1\rHost: server.example.com\rAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\rContent-Type: application/x-www-form-urlencoded\rgrant_type=password\u0026amp;username=johndoe\u0026amp;password=A3ddj3w\r授权服务器必须：\n要求对机密客户端或任何已颁发客户端凭据（或具有其他身份验证要求）的客户端进行客户端身份验证，\n若包括了客户端身份验证，验证客户端身份，并\n使用其现有的密码验证算法验证资源所有者的密码凭据。\n由于这种访问令牌请求使用了资源所有者的密码，授权服务器必须保护端点抵御暴力攻击（例如，使用速率限制或生成警报）\n4.3.3. 访问令牌响应 如果访问令牌请求有效且被授权，授权服务器会如第 5.1 节所述发出访问令牌和可选的刷新令牌。 如果请求未通过客户端身份验证或无效，授权服务器将如第 5.2 节所述返回错误响应。\n一个成功响应的样例：\nHTTP/1.1 200 OK\rContent-Type: application/json;charset=UTF-8\rCache-Control: no-store\rPragma: no-cache\r{\r\u0026quot;access_token\u0026quot;:\u0026quot;2YotnFZFEjr1zCsicMWpAA\u0026quot;,\r\u0026quot;token_type\u0026quot;:\u0026quot;example\u0026quot;,\r\u0026quot;expires_in\u0026quot;:3600,\r\u0026quot;refresh_token\u0026quot;:\u0026quot;tGzv3JOkF0XG5Qx2TlKWIA\u0026quot;,\r\u0026quot;example_parameter\u0026quot;:\u0026quot;example_value\u0026quot;\r}\r4.4. 客户端凭据许可 当客户端请求访问它所控制的，或者事先与授权服务器协商（所采用的方法超出了本规范的范围）的其他资源所有者的受保护资源时，客户端可以只使用它的客户端凭据（或者其他受支持的身份验证方法）请求访问令牌。\n客户端凭据许可类型必须只能由机密客户端使用。\n+---------+ +---------------+\r| | | |\r| |\u0026gt;--(A)- Client Authentication ---\u0026gt;| Authorization |\r| Client | | Server |\r| |\u0026lt;--(B)---- Access Token ---------\u0026lt;| |\r| | | |\r+---------+ +---------------+\r图 6：客户端凭证流程\n图 6 中的所示流程包含以下步骤：\n（A）客户端与授权服务器进行身份验证并向令牌端点请求访问令牌。\n（B）授权服务器对客户端进行身份验证，如果有效，则颁发访问令牌。\n4.4.1. 授权请求和响应 由于客户端身份验证被用作授权许可，所以不需要额外的授权请求。\n4.4.2. 访问令牌请求 客户端通过使用附录 B 中的“application/x-www-form-urlencoded”格式发送以下参数向令牌端点发出请求，HTTP 请求实体体中的字符编码为 UTF-8：\ngrant_type\n必需的。值必须设置为“client_credentials”。\nscope\n可选的。如 3.3 节所述的访问请求的范围。\n客户端必须如 3.2.1 所述与授权服务器进行身份验证。\n例如，客户端在传输层安全下发起如下 HTTP 请求（额外的换行仅用于显示目的）：\nPOST /token HTTP/1.1\rHost: server.example.com\rAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\rContent-Type: application/x-www-form-urlencoded\rgrant_type=client_credentials\r授权服务器必须对客户端进行身份验证。\n4.4.3. 访问令牌响应 如果访问令牌请求有效且已授权，则授权服务器会如第 5.1 节所述颁发访问令牌和可选的刷新令牌。 如果请求未通过客户端身份验证或无效，授权服务器将返回如第 5.2 节所述的错误响应。\n一个成功响应的样例：\nHTTP/1.1 200 OK\rContent-Type: application/json;charset=UTF-8\rCache-Control: no-store\rPragma: no-cache\r{\r\u0026quot;access_token\u0026quot;:\u0026quot;2YotnFZFEjr1zCsicMWpAA\u0026quot;,\r\u0026quot;token_type\u0026quot;:\u0026quot;example\u0026quot;,\r\u0026quot;expires_in\u0026quot;:3600,\r\u0026quot;example_parameter\u0026quot;:\u0026quot;example_value\u0026quot;\r}\r4.5. 扩展许可 客户端通过使用绝对 URI（由授权服务器定义）作为令牌端点的“grant_type”参数的值来指定授权类型，并通过添加任何必要的附加参数来使用扩展授权类型。\n例如，要使用 [OAuth-SAML2] 定义的安全断言标记语言 (SAML) 2.0 断言授权类型请求访问令牌，客户端可以使用 TLS 发出以下 HTTP 请求（额外的换行符仅用于显示目的）：\nPOST /token HTTP/1.1\rHost: server.example.com\rContent-Type: application/x-www-form-urlencoded\rgrant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2bearer\u0026amp;assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU[...为简洁起见省略...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-\r如果访问令牌请求是有效的且被授权，授权服务器如 5.1 节所述颁发访问令牌以及可选的刷新令牌。如果请求因客户端身份验证失败或无效，授权服务器如 5.2 节所述的返回错误响应。\n5. 颁发访问令牌 如果访问令牌请求是有效的且被授权，授权服务器如 5.1 节所述颁发访问令牌以及可选的刷新令牌。如果请求因客户端身份验证失败或无效，授权服务器如 5.2 节所述的返回错误响应。\n5.1. 成功的响应 授权服务器颁发访问令牌和可选的刷新令牌，通过向 HTTP 响应实体正文中添加下列参数并使用 200（OK）状态码构造响应：\naccess_token\n必需的。授权服务器颁发的访问令牌。\ntoken_type\n必需的。如 7.1 节所述的颁发的令牌的类型。值是大小写敏感的。\nexpires_in\n推荐的。以秒为单位的访问令牌生命周期。例如，值“3600”表示访问令牌将在从生成响应时的 1 小时后到期。如果省略，则授权服务器应该通过其他方式提供过期时间，或者记录默认值。\nrefresh_token\n可选的。刷新令牌，可以用于如第 6 节所述使用相同的授权许可获得新的访问令牌。\nscope\n可选的，若与客户端请求的范围相同；否则，必需的。如 3.3 节所述的访问令牌的范围。\n这些参数使用 [RFC4627] 定义的“application/json”媒体类型包含在 HTTP 响应实体正文中。将每个参数添加到最高结构级别并序列化为 JavaScript 对象表示法（JSON）的结构。参数名称和字符串值作为 JSON 字符串类型包含。数值的值作为 JSON 数字类型包含。参数顺序无关且可以变化。\n在任何包含令牌、凭据或其他敏感信息的响应中，授权服务器必须在其中包含值为“no-store”的 HTTP“Cache-Control”响应头 [RFC2616]，和值为“no-cache”的“Pragma”响应头 [RFC2616]。例如：\nHTTP/1.1 200 OK\rContent-Type: application/json;charset=UTF-8\rCache-Control: no-store\rPragma: no-cache\r{\r\u0026quot;access_token\u0026quot;:\u0026quot;2YotnFZFEjr1zCsicMWpAA\u0026quot;,\r\u0026quot;token_type\u0026quot;:\u0026quot;example\u0026quot;,\r\u0026quot;expires_in\u0026quot;:3600,\r\u0026quot;refresh_token\u0026quot;:\u0026quot;tGzv3JOkF0XG5Qx2TlKWIA\u0026quot;,\r\u0026quot;example_parameter\u0026quot;:\u0026quot;example_value\u0026quot;\r}\r客户端必须忽略无法识别的响应参数。令牌大小和从授权服务器接收到的值的大小未定义。客户端应该避免对值的大小做假设。授权服务器应记录其发放的任何值的大小。\n5.2. 错误响应 授权服务器使用 HTTP 400（错误请求）状态码（除非指定其他的）响应，在响应中包含下列参数：\nerror\n必需的。下列 ASCII[USASCII] 错误代码之一：\ninvalid_request\n请求缺少必需的参数、包含不支持的参数值（除了许可类型）、重复参数、包含多个凭据、采用多种客户端身份验证机制或其他不规范的格式。\ninvalid_client\n客户端身份验证失败（例如，未知的客户端，不包含客户端身份验证，或不支持的身份验证方法）。授权服务器可以返回 HTTP 401（未授权）状态码来指出支持的 HTTP 身份验证方案。如果客户端试图通过“Authorization”请求头进行身份验证，授权服务器必须响应 HTTP 401（未授权）状态码，并包含与客户端使用的身份验证方案匹配的“WWW-Authenticate”响应头。\ninvalid_grant\n提供的授权许可（如授权码、资源所有者凭据）或刷新令牌无效、过期、吊销、与在授权请求使用的重定向 URI 不匹配或被颁发给其他客户端。\nunauthorized_client\n进行身份验证的客户端没有被授权使用这种授权许可类型。\nunsupported_grant_type\n授权许可类型不被授权服务器支持。\ninvalid_scope\n请求的范围无效、未知的、格式不正确或超出资源所有者许可的范围。\n“error”参数的值不能包含集合 ％x20-21 / ％x23-5B / ％x5D-7E 以外的字符。\nerror_description\n可选的。提供额外的人类可读的 ASCII[USASCII] 信息文本，用于协助客户端开发人员理解所发生的错误。“error_description”参数的值不能包含集合 ％x20-21 / ％x23-5B / ％x5D-7E 以外的字符。\nerror_uri\n可选的。指向包含有关错误信息的人类可读的网页 URI，用于向客户端开发人员提供关于该错误的额外信息。\n“error_uri”参数值必须符合 URI 参考语法，因此不能包含集合 ％x21 / %x23-5B / ％x5D-7E 以外的字符。\n这些参数使用 [RFC4627] 定义的“application/json”媒体类型包含在 HTTP 响应实体正文中。将每个参数添加到最高结构级别并序列化为 JavaScript 对象表示法（JSON）的结构。参数名称和字符串值作为 JSON 字符串类型包含。数值的值作为 JSON 数字类型包含。参数顺序无关且可以变化。\n例如：\nHTTP/1.1 400 Bad Request\rContent-Type: application/json;charset=UTF-8\rCache-Control: no-store\rPragma: no-cache\r{\r\u0026quot;error\u0026quot;:\u0026quot;invalid_request\u0026quot;\r}\r6. 刷新访问令牌 若授权服务器给客户端颁发了刷新令牌，客户端通过使用按 附录 B “application/x-www-form-urlencoded”格式在 HTTP 请求实体正文中发送下列 UTF-8 字符编码的参数向令牌端点发起刷新请求：\ngrant_type\n必需的。值必须设置为“refresh_token”。\nrefresh_token\n必需的。颁发给客户端的刷新令牌。\nscope\n可选的。如 3.3 节所述的访问请求的范围。请求的范围不能包含任何不是由资源所有者原始许可的范围，若省略，则被视为与资源所有者原始许可的范围相同。\n因为刷新令牌通常是用于请求额外的访问令牌的持久凭证，刷新令牌绑定颁发的客户端。如果客户端类型是机密的或客户端被颁发了客户端凭据（或选定的其他身份验证要求），客户端必须如 3.2.1 节所述与授权服务器进行身份验证。\n例如，客户端在传输层安全下发起如下 HTTP 请求（额外的换行仅用于显示目的）：\nPOST /token HTTP/1.1\rHost: server.example.com\rAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\rContent-Type: application/x-www-form-urlencoded\rgrant_type=refresh_token\u0026amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\r授权服务器必须：\n要求对机密客户端或任何已获得客户端凭据（或具有其他身份验证要求）的客户端进行客户端身份验证，\n如果包含客户端身份验证，则对客户端进行身份验证，并确保将刷新令牌颁发给经过身份验证的客户端，以及\n验证刷新令牌。\n如果有效并获得授权，授权服务器会如第 5.1 节所述颁发访问令牌。 如果请求验证失败或无效，授权服务器将返回如第 5.2 节所述的错误响应。\n授权服务器可以发布一个新的刷新令牌，在这种情况下，客户端必须丢弃旧的刷新令牌并用新的刷新令牌替换它。 授权服务器可以在向客户端发出新的刷新令牌后撤销旧的刷新令牌。 如果发布了新的刷新令牌，则刷新令牌范围必须与客户端在请求中包含的刷新令牌的范围相同。\n7. 访问受保护资源 客户端通过向资源服务器提供访问令牌来访问受保护的资源。 资源服务器必须验证访问令牌并确保它没有过期并且其范围涵盖了所请求的资源。 资源服务器用于验证访问令牌（以及任何错误响应）的方法超出了本规范的范围，但通常涉及资源服务器和授权服务器之间的交互或协调。\n客户端使用访问令牌与资源服务器进行身份验证的方法取决于授权服务器颁发的访问令牌的类型。 通常，它涉及使用 HTTP“Authorization”请求头字段 [RFC2617] 和由所使用的访问令牌类型规范定义的身份验证方案，例如 [RFC6750]。\n7.1. 访问令牌类型 访问令牌类型给客户端提供了成功使用该访问令牌（以及特定于类型的属性）发起受保护资源请求所需的信息。若客户端不理解令牌类型，则不能使用该访问令牌。\n例如，[RFC6750] 中定义的“bearer”令牌类型通过简单地在请求中包含访问令牌字符串来使用：：\nGET /resource/1 HTTP/1.1\rHost: example.com\rAuthorization: Bearer F_9.B5f-4.1JqM\r而在 [OAuth-HTTP-MAC] 中定义的“mac”令牌类型通过发布消息验证码 (MAC) 密钥与用于签名某些 HTTP 请求的组件一起使用：\nGET /resource/1 HTTP/1.1\rHost: example.com\rAuthorization: MAC id=\u0026quot;h480djs93hd8\u0026quot;,nonce=\u0026quot;274312:dj83hs9s\u0026quot;,mac=\u0026quot;kDZvddkndxvhGRXZhvuDjEWhGeE=\u0026quot;\r提供上面的例子仅作说明用途。建议开发人员在使用前查阅 [RFC6750] 和 [OAuth-HTTP-MAC] 规范。\n每一种访问令牌类型的定义指定了与“access_token”响应参数一起发送到客户端的额外属性。它还定义了用于在发出受保护资源请求时包含访问令牌的 HTTP 身份验证方法。\n7.2. 错误响应 如果资源访问请求失败，资源服务器应该通知客户端该错误。虽然此类错误响应的细节超出了本规范的范围，但本文档在第 11.4 节中建立了一个公共注册表，用于在 OAuth 令牌身份验证方案之间共用错误值。\n主要为 OAuth 令牌身份认证设计的新认证方案应该定义一种机制，用于向客户端提供错误状态代码，其中允许的错误值注册在本规范建立的错误注册表中。\n此类方案可以将有效错误代码集限制为注册值的子集。 如果使用命名参数返回错误代码，则参数名称应为“error”。\n其他能够用于 OAuth 令牌身份验证的方案，即使其不是专门为此目的而设计的，也可以以相同的方式将它们的错误值绑定到注册表。\n新的身份验证方案也可以选择指定使用“error_description”和“error_uri”参数，以与本规范中相同的方式返回错误信息。\n8. 可扩展性 8.1. 定义访问令牌类型 访问令牌类型可以通过以下两种方式之一定义：在访问令牌类型注册表中注册（遵循 11.1 节中的过程），或者使用唯一的绝对 URI 作为其名称。\n采用 URI 命名的类型应该限定于特定供应商的实现，它们不是普遍适用的并且特定于使用它们的资源服务器的实现细节。\n所有其他类型都必须注册。类型名称必需符合 type-name ANBF。如果类型定义包含了一种新的 HTTP 身份验证方案，该类型名称应该与该 HTTP 身份验证方案名称一致（如 [RFC2617] 的定义）。令牌类型“example”被保留用于样例中。\ntype-name = 1*name-char\rname-char = \u0026quot;-\u0026quot; / \u0026quot;.\u0026quot; / \u0026quot;_\u0026quot; / DIGIT / ALPHA\r8.2. 定义新的端点参数 用于授权端点或令牌端点的新的请求或响应参数按照 11.2 节中的过程在 OAuth 参数注册表中定义和注册。\n参数名称必须符合 param-name ABNF，并且参数值的语法必须是明确定义的（例如，使用 ABNF，或现有参数的语法的引用）。\nparam-name = 1*name-char\rname-char = \u0026quot;-\u0026quot; / \u0026quot;.\u0026quot; / \u0026quot;_\u0026quot; / DIGIT / ALPHA\r未注册的特定于供应商的扩展参数通常不适用，它们特定于使用它们的授权服务器的实现细节，应该使用不太可能与其他注册值冲突的供应商特定前缀（例如，以\u0026rsquo;companyname_\u0026lsquo;开头）。\n8.3. 定义新的授权许可类型 可以通过为它们分配一个唯一的绝对 URI 以与“grant_type”参数一起使用来定义新的授权许可类型。 如果扩展授权类型需要额外的令牌端点参数，它们必须如第 11.2 节所述在 OAuth 参数注册表中注册。\n8.4. 定义新的授权端点响应类型 按照第 11.3 节中的过程，在授权端点响应类型注册表中定义和注册与授权端点一起使用的新响应类型。 响应类型名称必须符合 response-type ABNF。\nresponse-type = response-name *( SP response-name )\rresponse-name = 1*response-char\rresponse-char = \u0026quot;_\u0026quot; / DIGIT / ALPHA\r如果响应类型包含一个或多个空格字符 (%x20)，则将其作为以空格分隔的值列表进行比较，其中值的顺序无关紧要。只能注册一个值的顺序，它涵盖了同一组值的所有其他排列。\n例如，响应类型“token code”未由本规范定义。然而，一个扩展可以定义和注册“token code”响应类型。 一旦注册，相同的组合“code token”便不能被注册，但是这两个值都可以用于表示相同的响应类型。\n8.5. 定义其他错误代码 在协议扩展（例如，访问令牌类型、扩展参数或扩展许可类型等）需要其他错误码用于授权码许可错误响应（ 4.1.2.1 节）、隐式授权错误响应（ 4.2.2.1 节）、令牌错误响应（ 5.2 节）或资源访问错误响应（ 7.2 节）的情况下，这些错误代码可以被定义。\n如果与它们一起使用的扩展是已注册的访问令牌类型、已注册的端点参数或扩展许可类型，则必须注册扩展错误代码（遵循第 11.4 节中的过程）。可以注册用于未注册扩展的错误代码。\n错误代码必须符合 error ABNF，且可能的话应该以一致的名称作前缀。例如，给扩展参数“example”设置了无效值的错误应该被命名为“example_invalid”。\nerror = 1*error-char\rerror-char = %x20-21 / %x23-5B / %x5D-7E\r9. 本机应用程序 本机应用程序是安装和执行在资源所有者使用的设备上的客户端（例如，桌面程序，本机移动应用）。本机应用程序需要对安全、平台能力和整体最终用户体验特殊考虑。\n授权端点需要在客户端和资源所有者用户代理之间进行交互。本机应用程序可以调用外部的用户代理，或在应用程序中嵌入用户代理。例如：\n外部用户代理——本机应用程序可以捕获来自授权服务器的响应。它可以使用操作系统已注册方案来调用客户端作为处理程序，手动复制粘贴凭据，运行本地 Web 服务器，安装用户代理扩展，或者通过提供重定向 URI 来指定客户端控制下的服务器托管资源，这反过来使响应可用于本机应用程序。\n嵌入式用户代理——本机应用程序通过监视资源加载期间发出的状态更改或访问用户代理的 cookie 存储直接与嵌入式用户代理通信来获取响应。\n当在外部或嵌入式用户代理中选择时，开发者应该考虑如下：\n外部用户代理可能会提高完成率，因为资源所有者可能已经有了与授权服务器的活动会话，避免了重新进行身份验证的需要。它提供了熟悉的最终用户体验和功能。资源所有者可能也依赖于用户代理的功能或扩展帮助他进行身份验证（例如密码管理器、双因子验证器）\n嵌入式用户代理可能会提供更好的可用性，因为它避免了切换上下文和打开新窗口的需要。\n嵌入式用户代理构成了安全挑战，因为资源所有者在一个未知的窗口中进行身份验证，无法获得在大多数外部用户代理中的视觉体验保护。嵌入式用户代理要求用户信任未标识身份的验证请求（使钓鱼攻击更易于实施）。\n当在隐式授权类型和授权码许可类型中选择时，下列应该被考虑：\n由于本机应用程序无法对客户端凭据保密，因此使用授权代码授权类型的本机应用程序应该在不使用客户端凭据的情况下这样做。\n当使用隐式授权类型流程时，不会返回刷新令牌，这就要求一旦访问令牌过期就要重复授权过程。\n10. 安全考量 作为一个灵活可扩展的框架，OAuth 的安全性考量依赖于许多因素。 以下小节提为实现者提供了如 2.1 节所述的三种客户端配置上的安全指南：Web 应用、基于用户代理的应用和本地应用程序。\n全面的 OAuth 安全模型和分析以及该协议设计的背景在 [OAuth-THREATMODE] 中提供。\n10.1. 客户端身份验证 授权服务器与 Web 应用程序客户端建立客户端凭据以进行客户端身份验证。 鼓励授权服务器考虑比客户端密码更强的客户端身份验证方式。Web 应用程序客户端必须确保客户端密码和其他客户端凭据的机密性。\n授权服务器不得出于客户端身份验证的目的向本地应用程序或基于用户代理的应用程序客户端颁发客户端密码或其他客户端凭据。授权服务器可以为专用设备上的本地应用程序客户端的特定安装发布客户端密码或其他凭据。\n当客户端身份验证不可用时，授权服务器应该采用其他方式来验证客户端的身份-例如，通过要求客户端重定向 URI 的注册或者引入资源所有者来确认身份。当请求资源所有者授权时，有效的重定向 URI 是不足以验证客户端的身份，但可以用来防止在获得资源所有者授权后将凭据传递给假冒的客户端。\n授权服务器必须考虑与未进行身份验证的客户端交互的安全实现，并采取措施限制颁发给这些客户端的其他凭据（如刷新令牌）的潜在泄露。\n10.2. 客户端仿冒 如果被冒充的客户端未能或无法对其客户端凭据保密，则恶意客户端可以冒充另一个客户端并获得对受保护资源的访问权限。\n授权服务器必须尽可能对客户端进行身份验证。如果授权服务器由于客户端的性质而无法对客户端进行身份验证，则授权服务器必须要求注册任何用于接收授权响应的重定向 URI，并且应该使用其他方式来保护资源所有者免受此类潜在恶意客户端的侵害。例如，授权服务器可以引入资源所有者来帮助识别客户端及其来源。\n授权服务器应该实施显式的资源所有者身份验证并且告知资源所有者有关客户端及其请求的授权范围和生命周期。由资源所有者在当前客户端上下文中审查信息并授权或拒绝请求。\n授权服务器不应该自动处理重复的授权请求（没有显示地与资源所有者交互）而不验证客户端或依赖其他措施来确保重复的请求来自原始客户端而不是伪造客户端。\n10.3. 访问令牌 访问令牌凭据（以及任何机密的访问令牌属性）在传输和储存时必须保持机密性，并只与授权服务器、访问令牌生效的资源服务器和访问令牌被颁发的客户端共享。访问令牌凭据必须只能用 1.6 节所述的 TLS 与 [RFC2818] 定义授权服务器进行传输。\n当使用隐式授权许可类型时，访问令牌在 URI 片段中传输，这可能泄露访问令牌给未授权的一方。\n授权服务器必须确保访问令牌不能被未经授权方生成、修改或猜测以产生有效的访问令牌。\n客户端应该以最小需求范围请求访问令牌。授权服务器在选择如何兑现请求的范围时应该将客户端身份考虑在内，且可以颁发具有比请求权限更小的访问令牌。\n本规范没有为资源服务器提供任何方法来确保特定客户端提供给它的访问令牌是由授权服务器颁发给该客户端的。\n10.4. 刷新令牌 授权服务器可以给 Web 应用客户端和本机应用程序客户端颁发刷新令牌。\n刷新令牌在传输和储存时必须保持机密性，并只与授权服务器和刷新令牌被颁发的客户端共享。授权服务器必须维护刷新令牌和颁发的客户端之间的绑定信息。访问令牌凭据必须只能用 1.6 节所述的 TLS 与 [RFC2818] 定义授权服务器进行传输。\n每当可以验证客户端身份时，授权服务器必须验证刷新令牌和客户端身份之间的绑定。当客户端身份验证不可行时，授权服务器应该部署其他方法来检测刷新令牌是否被滥用。\n例如，授权服务器可以使用刷新令牌轮换机制，随着每次访问令牌刷新响应，新的刷新令牌被颁发。旧的刷新令牌作废但是由授权服务器保留。如果刷新令牌被泄露，随后同时被攻击者和合法客户端使用，他们中一人将提交被作废的刷新令牌，该入侵将通知给授权服务器。\n授权服务器必须确保刷新令牌不能被未经授权方生成、修改或猜测以产生有效的访问令牌。\n10.5. 授权码 授权码的传输应该建立在安全通道上，如果重定向 URI 指向了一个网络资源，那么客户端应该要求使用 TLS。由于授权码由用户代理重定向传输，它们可能潜在地通过用户代理历史记录和 HTTP referrer 请求头被泄露。\n授权码作为文本形式的凭据，用于验证在授权服务器给予授权许可和返回授权许可给客户端以完成授权过程的是同一资源所有者。因此，如果客户端依赖于授权码作为它自己的资源所有者身份验证，客户端重定向端点必须要求使用 TLS。\n授权码必须是短暂及单用户的。如果授权服务器观察到多次用授权码交换访问令牌的尝试，授权服务器应该试图吊销所有基于泄露的授权码颁发的访问令牌。\n如果客户端可以进行身份验证，授权服务器必须验证客户端身份，并确该保授权码颁发给了此客户端。\n10.6. 授权码重定向 URI 伪造 当使用授权码许可类型请求授权时，客户端可以通过“redirect_uri”参数指定重定向 URI。 如果攻击者能够伪造重定向 URI 的值，这可能导致授权服务器重定向资源所有者的用户代理到攻击者控制的 URI，同时将授权码加入到 URI 中。\n攻击者可以在合法客户端上创建一个帐户，并开始授权流程。当攻击者的用户代理被发送到授权服务器授予访问权限时，攻击者会抓取合法客户端提供的授权 URI，并将客户端的重定向 URI 替换为攻击者控制下的 URI。攻击者然后诱使受害者跟随被操纵的链接以授权访问合法客户端。\n一旦到达授权服务器后，受害者会被提示代表合法且受信任的客户端发出正常、有效的请求，并授权该请求。然后，受害者带着授权码重定向到受攻击者控制的端点。攻击者通过使用客户端提供的原始重定向 URI 向客户端发送授权码来完成授权流程。客户端用授权码交换访问令牌并与将它与攻击者的客户端账号关联，然后，该账户现在能获得受害者授权的（通过客户端）对访问受保护资源的访问权限。\n为了防止这种攻击，授权服务器必须确保用于获得授权码的重定向 URI 与用授权码交换访问令牌时提供的重定向 URI 相同。授权服务器必须要求公共客户端，并且应该要求机密客户注册它们的重定向 URI。如果请求中提供了重定向 URI，授权服务器必须根据注册值对其进行验证。\n10.7. 资源所有者密码凭据 资源所有者密码凭据许可类型通常用于遗留或迁移原因。它降低了由客户端存储用户名和密码的整体风险，但并没有消除泄露高度特权的凭证给客户端的需求。\n这种许可类型比其他许可类型承载了更高的风险，因为它保留了本协议寻求避免密码的反模式。客户端可能滥用密码或密码可能会无意中被泄露给攻击者（例如，通过客户端保存的日志文件或其他记录）。\n此外，由于资源所有者无法控制授权过程（资源所有者的参与在将其凭据移交给客户端时结束），因此客户端可以获得比资源所有者预期的具有更大范围的访问令牌。授权服务器应该考虑由这种许可类型颁发的访问令牌的范围和生命周期。\n授权服务器和客户端应该尽量减少这种许可类型的使用，并尽可能采用其他许可类型。\n10.8. 请求机密性 访问令牌、刷新令牌、资源所有者密码和客户端凭据不得以明文形式传输。授权代码不应以明文形式传输。\n“state”和“scope”参数不应该包含敏感的客户端或资源所有者的纯文本信息，因为它们可能在不安全的通道上被传输或被不安全地存储。\n10.9. 确保端点真实性 为了防止中间人攻击，对于发送到授权和令牌端点的任何请求，授权服务器必须要求使用 TLS 和 [RFC2818] 定义的服务器身份验证。客户端必须按照 [RFC6125] 的定义并根据其对服务器身份验证的要求来验证授权服务器的 TLS 证书。\n10.10. 凭据猜测攻击 授权服务器必须防止攻击者猜测访问令牌、授权码、刷新令牌、资源所有者密码和客户端凭据。\n攻击者猜测已生成令牌（和其它不打算被最终用户掌握的凭据）的概率必须小于或等于 2 ^（-128），并且应该小于或等于 2 ^（-160）。\n授权服务器必须使用其他方式来保护旨在供最终用户使用的凭据。\n10.11. 钓鱼攻击 此协议和类似协议的广泛部署可能会导致最终用户习惯于被重定向到要求他们输入密码的网站的做法。如果最终用户在输入凭据之前不认真地验证这些网站的真实性，攻击者就有可能利用这种做法窃取资源所有者的密码。\n服务提供商应尝试向最终用户宣传网络钓鱼攻击所带来的风险，并应提供使最终用户能够轻松确认其网站真实性的机制。客户端开发人员应该考虑他们如何与用户代理（例如，外部、嵌入式）交互的安全含义，以及最终用户验证授权服务器真实性的能力。\n为了降低网络钓鱼攻击的风险，授权服务器必须要求在用于最终用户交互的每个端点上使用 TLS。\n10.12. 跨站请求伪造 跨站点请求伪造 （CSRF） 是一种漏洞，攻击者利用此漏洞使受害最终用户的用户代理将恶意 URI（例如，作为误导性链接、图像或重定向提供给用户代理）跟踪到信任服务器（通常通过有效会话 cookie 的存在建立）。\n针对客户端的重定向 URI 的 CSRF 攻击允许攻击者注入自己的授权码或访问令牌，这将导致在客户端中使用与攻击者的受保护资源关联的访问令牌而非受害者的（例如，将受害者的银行账户信息保存到攻击者控制的受保护资源上）。\n客户端必须为它的重定向 URI 实现 CSRF 保护。这通常通过要求向重定向 URI 端点发送的任何请求包含一个与用户代理身份认证状态绑定的值（例如，用于对用户代理进行身份验证的会话 Cookie 的哈希值）来实现。客户端应该使用“state”请求参数在发起授权请求时向授权服务器传送该值。\n一旦从最终用户获得授权，授权服务器将最终用户的用户代理重定向回客户端，并在“state”参数中包含所需的绑定值。绑定值使客户端能够通过将绑定值与用户代理的身份验证状态对比来验证请求的有效性。用于 CSRF 保护的绑定值必须包含不可猜测的值（如 10.10 节所述）且用户代理的身份验证状态（例如会话 Cookie、HTML5 本地存储）必须保存在只能被客户端和用户代理访问的地方（即受同源策略保护）。\n针对授权服务器的授权端点的 CSRF 攻击可能导致攻击者在不涉及或警告最终用户的情况下获得恶意客户端的最终用户授权。\n授权服务器必须为它的授权端点实现 CSRF 保护并且确保在资源所有者未意识到且无显式同意时恶意客户端不能获得授权\n授权服务器必须为其授权端点实施 CSRF 保护，并确保恶意客户端在没有资源所有者的察觉和明确同意的情况下无法获得授权。\n10.13. 点击劫持 在点击劫持攻击中，攻击者注册一个合法客户端，然后构建一个恶意站点，在该站点中，它将授权服务器的授权端点网页加载到覆盖在一组虚拟按钮之上的透明 iframe 中，这些虚拟按钮经过精心构造，可以直接放置在授权页面的重要按钮下。当最终用户单击一个误导性的可见按钮时，最终用户实际上是在单击授权页面上的一个不可见按钮（例如“授权”按钮）。这允许攻击者在最终用户不知情的情况下诱骗资源所有者授予其客户端访问权限。\n为了防止这种形式的攻击，本机应用程序在请求最终用户授权时应该使用外部浏览器而不是在应用程序中嵌入浏览器。对于大多数较新的浏览器，授权服务器可以使用（非标准）“x-frame-options”标头强制避免 iframe。这个标头可以有两个值，“deny”和“sameorigin”，它们将分别阻止任何框架，或由具有不同来源的站点组成的框架。对于较旧的浏览器，可以使用 JavaScript 框架破坏技术，但可能并非在所有浏览器中都有效。\n10.14. 代码注入和输入验证 当输入或其他外部变量被未经过滤的应用程序使用并导致对应用程序逻辑的修改时，就会发生代码注入攻击。这可能允许攻击者访问应用程序设备或其数据，导致拒绝服务，或引入广泛的恶意副作用。\n授权服务器和客户端必须过滤（并在可能的情况下验证）收到的任何值——特别是，“state”和“redirect_uri”参数的值。\n10.15. 自由重定向器 授权服务器、授权端点和客户端重定向端点可能被不当配置，被作为自由重定向器。自由重定向器是一个使用参数自动地向参数值指定而无任何验证的地址重定向用户代理的端点。\n自由重定向器可被用于钓鱼攻击，或者被攻击者通过使用熟悉的受信任的目标地址的 URI 授权部分使最终用户访问恶意站点。此外，如果授权服务器允许客户端只注册部分的重定向 URI，攻击者可以使用客户端操作的自由重定向器构造重定向 URI，该 URI 将通过授权服务器验证，但会发送授权码或访问令牌到攻击者控制下的端点。\n10.16. 在隐式授权流程中滥用访问令牌假冒资源所有者 对于使用隐式授权流程的公共客户端，本规范没有为客户端提供任何方法来决定访问令牌颁发给的是哪个的客户端。\n资源所有者可能通过给攻击者的恶意客户端许可访问令牌来自愿委托对资源的访问。这可能是由于钓鱼或一些其他借口。攻击者也可能通过其他机制窃取令牌。然后，攻击者可能会尝试通过向合法公开客户端提供该访问令牌假冒资源拥有者。\n在隐式流程（response_type=token）中，攻击者可以轻易切换来自授权服务器的响应中的令牌，用事先颁发给攻击者的令牌替换真实的访问令牌。\n与本机应用程序通信的服务器依赖于在后台通道中传递一个访问令牌来识别客户端用户，攻击者创建一个可以注入任意被盗访问令牌的受攻击应用程序，可能会对这些服务器造成类似的威胁。\n任何假设只有资源所有者才能向其提供资源的有效访问令牌的公共客户端都容易受到此类攻击。\n这种类型的攻击可能会将合法客户端的资源所有者信息暴露给攻击者（恶意客户端）。这也将允许攻击者以与最初授予访问令牌或授权代码的资源所有者相同的权限在合法客户端执行操作。\n客户端对资源拥有者进行身份验证超出了本规范的范围。任何使用授权过程作为客户端对受委托的最终用户进行身份验证的形式的规范（例如，第三方登录服务）不得在没有额外的安全机制的情况下使用隐式流程，这些安全机制使客户端能够确定是否访问颁发令牌供其使用（例如，限制访问令牌的受众）。\n11. IANA 考量 11.1. OAuth 访问令牌类型注册表 本规范建立 OAuth 访问令牌类型注册表。\n在 oauth-ext-review@ietf.org 邮件列表上经过两周的审查期且在一个或多个指定专家的建议下，以规范要求（[RFC5226]）注册访问令牌类型。但是，为了允许在发布之前分配值，指定专家可以在他们对将发布的规范感到满意后批准注册。\n注册请求必须发送到 oauth-ext-review@ietf.org 邮件列表进行审查和评论，并附上适当的主题（例如，“Request for access token type: example”）。\n在审查期内，指定专家（们）将批准或拒绝注册请求，并将此决定传达给审核名单和 IANA。 拒绝应包括解释，如果可能的话，还应包括有关如何修正请求的建议。\nIANA 必须只接受指定专家（们）的注册更新，并应将所有注册请求发送至审核邮件列表。\n11.1.1. 注册模板 Type name：\n请求的名称（例如，“example”）。\nAdditional Token Endpoint Response Parameters:\n与“access_token”参数一起返回的附加响应参数。 如第 11.2 节所述，新参数必须在 OAuth 参数注册表中单独注册。\nHTTP Authentication Scheme(s):\nHTTP 身份验证方案名称（如果有），用于使用此类型的访问令牌对受保护的资源请求进行身份验证。\nChange controller：\n对于标准过程的 RFC，请注明“IETF”。 对于其他人，请提供责任方的名称。 还可能包括其他详细信息（例如，邮政地址、电子邮件地址、主页 URI）。\nSpecification document(s):\n指定参数的文档的引用文献，最好包括可以用于检索文档副本的 URI。 也可以包括相关章节的说明，但不是必需的。\n11.2. OAuth 参数注册表 本规范建立 OAuth 参数注册表。\n授权端点请求、授权端点响应、令牌端点请求和令牌端点响应中包含的其他参数在 oauth-ext-review@ietf.org 邮件列表上经过两周审查后，根据一名或多名指定专家的建议，按照所需规范（[RFC5226]）注册。但是，为了允许在发布之前分配值，指定专家可以在他们对将发布的规范感到满意后批准注册。\n注册请求必须发送到 oauth-ext-review@ietf.org 邮件列表进行审查和评论，并附上适当的主题（例如，“Request for parameter: example”）。\n在审查期间，指定的专家（们）将批准或拒绝注册请求，并将此决定传达给审核名单和 IANA。拒绝应包括解释，如果可能的话，还应包括有关如何修正请求的建议。\nIANA 必须只接受指定专家（们）的注册更新，并应将所有注册请求发送至审核邮件列表。\n11.2.1. 注册模板 Parameter name:\n请求的名称（例如，“example”）。\nParameter usage location:\n参数可以使用的位置。可能的位置为授权请求、授权响应、令牌请求或令牌响应。\nChange controller:\n对于标准化过程的 RFC，指定为“IETF”。对于其他人，请提供责任方的名称。 还可能包括其他详细信息（例如，邮政地址、电子邮件地址、主页 URI）。\nSpecification document(s):\n指定参数的文档的引用文献，最好包括可以用于检索文档副本的 URI。 也可以包括相关章节的说明，但不是必需的。\n11.2.2. 初始的注册表内容 OAuth 参数注册表中的初始内容：\nParameter name: client_id Parameter usage location: authorization request, token request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: client_secret Parameter usage location: token request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: response_type Parameter usage location: authorization request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: redirect_uri Parameter usage location: authorization request, token request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: scope Parameter usage location: authorization request, authorization response, token request, token response Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: state Parameter usage location: authorization request, authorization response Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: code Parameter usage location: authorization response, token request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: error_description Parameter usage location: authorization response, token response Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: error_uri Parameter usage location: authorization response, token response Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: grant_type Parameter usage location: token request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: access_token Parameter usage location: authorization response, token response Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: token_type Parameter usage location: authorization response, token response Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: expires_in Parameter usage location: authorization response, token response Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: username Parameter usage location: token request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: password Parameter usage location: token request Change controller: IETF Specification document(s): RFC 6749 .\nParameter name: refresh_token Parameter usage location: token request, token response Change controller: IETF Specification document(s): RFC 6749 11.3. OAuth 授权端点响应类型注册表 本规范建立 OAuth 授权端点响应类型注册表。\n用于授权端点的其他响应类型在 oauth-ext-review@ietf.org 邮件列表上经过两周审查后，根据一名或多名指定专家的建议，按照所需规范（[RFC5226]）注册。但是，为了允许在发布之前分配值，指定专家可以在他们对将发布的规范感到满意后批准注册。\n注册请求必须发送到 oauth-ext-review@ietf.org 邮件列表进行审查和评论，并附上适当的主题（例如，“Request for parameter: example”）。\n在审查期间，指定的专家（们）将批准或拒绝注册请求，并将此决定传达给审核名单和 IANA。拒绝应包括解释，如果可能的话，还应包括有关如何修正请求的建议。\nIANA 必须只接受指定专家（们）的注册更新，并应将所有注册请求发送至审核邮件列表。\n11.3.1. 注册模板 Response type name:\n请求的名称（例如，“example”）。\nChange controller:\n对于标准化过程的 RFC，指定为“IETF”。对于其他人，请提供责任方的名称。 还可能包括其他详细信息（例如，邮政地址、电子邮件地址、主页 URI）。\nSpecification document(s):\n指定参数的文档的引用文献，最好包括可以用于检索文档副本的 URI。 也可以包括相关章节的说明，但不是必需的。\n11.3.2. 初始的注册表内容 OAuth 授权端点响应类型注册表的初始内容：\nResponse type name: code Change controller: IETF Specification document(s): RFC 6749 .\nResponse type name: token Change controller: IETF Specification document(s): RFC 6749 11.4. OAuth 扩展错误注册表 本规范建立 OAuth 扩展错误注册表。\n与其他协议扩展一起使用的附加错误代码（即扩展授权类型、访问令牌类型或扩展参数）在 oauth-ext-review@ietf.org 邮件列表上经过两周审查后，根据一名或多名指定专家的建议，按照所需规范（[RFC5226]）注册。但是，为了允许在发布之前分配值，指定专家可以在他们对将发布的规范感到满意后批准注册。\n注册请求必须发送到 oauth-ext-review@ietf.org 邮件列表进行审查和评论，并附上适当的主题（例如，“Request for parameter: example”）。\n在审查期间，指定的专家（们）将批准或拒绝注册请求，并将此决定传达给审核名单和 IANA。拒绝应包括解释，如果可能的话，还应包括有关如何修正请求的建议。\nIANA 必须只接受指定专家（们）的注册更新，并应将所有注册请求发送至审核邮件列表。\n11.4.1. 注册模板 Error name:\n请求的名称（例如，“example”）。错误名称的值不能包含集合 %x20-21 / %x23-5B / %x5D-7E 以外的字符。\nError usage location:\n错误使用的位置。可能的位置是授权代码许可错误响应（ 4.1.2.1 节），隐式授权错误响应（ 4.2.2.1 节），令牌错误响应（ 5.2 节），或资源访问错误的响应（ 7.2 节）。\nRelated protocol extension:\n与错误代码一起使用的扩展许可类型、访问令牌类型或扩展参数的名称。\nChange controller:\n对于标准化过程的 RFC，指定为“IETF”。对于其他人，请提供责任方的名称。 还可能包括其他详细信息（例如，邮政地址、电子邮件地址、主页 URI）。\nSpecification document(s):\n指定参数的文档的引用文献，最好包括可以用于检索文档副本的 URI。 也可以包括相关章节的说明，但不是必需的。\n12. 参考文献 12.1. 规范性参考文件 [RFC2119]\nBradner, S., \u0026ldquo;Key words for use in RFCs to Indicate Requirement Levels\u0026rdquo;, BCP 14,RFC 2119, March 1997.\n[RFC2246]\nDierks, T. and C. Allen, \u0026ldquo;The TLS Protocol Version 1.0\u0026rdquo;, RFC 2246, January 1999.\n[RFC2616]\nFielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \u0026ldquo;Hypertext Transfer Protocol \u0026ndash; HTTP/1.1\u0026rdquo;, RFC 2616, June 1999.\n[RFC2617]\nFranks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, \u0026ldquo;HTTP Authentication: Basic and Digest Access Authentication\u0026rdquo;, RFC 2617, June 1999.\n[RFC2818]\nRescorla, E., \u0026ldquo;HTTP Over TLS\u0026rdquo;, RFC 2818, May 2000.\n[RFC3629]\nYergeau, F., \u0026ldquo;UTF-8, a transformation format of ISO 10646\u0026rdquo;, STD 63, RFC 3629, November 2003.\n[RFC3986]\nBerners-Lee, T., Fielding, R., and L. Masinter, \u0026ldquo;Uniform Resource Identifier (URI): Generic Syntax\u0026rdquo;, STD 66, RFC 3986, January 2005.\n[RFC4627]\nCrockford, D., \u0026ldquo;The application/json Media Type for JavaScript Object Notation (JSON)\u0026rdquo;, RFC 4627, July 2006.\n[RFC4949]\nShirey, R., \u0026ldquo;Internet Security Glossary, Version 2\u0026rdquo;, RFC 4949, August 2007.\n[RFC5226]\nNarten, T. and H. Alvestrand, \u0026ldquo;Guidelines for Writing an IANA Considerations Section in RFCs\u0026rdquo;, BCP 26,RFC 5226, May 2008.\n[RFC5234]\nCrocker, D. and P. Overell, \u0026ldquo;Augmented BNF for Syntax Specifications: ABNF\u0026rdquo;, STD 68, RFC 5234, January 2008.\n[RFC5246]\nDierks, T. and E. Rescorla, \u0026ldquo;The Transport Layer Security (TLS) Protocol Version 1.2\u0026rdquo;, RFC 5246, August 2008.\n[RFC6125]\nSaint-Andre, P. and J. Hodges, \u0026ldquo;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\u0026rdquo;, RFC 6125, March 2011.\n[USASCII]\nAmerican National Standards Institute, \u0026ldquo;Coded Character Set \u0026ndash; 7-bit American Standard Code for Information Interchange\u0026rdquo;, ANSI X3.4, 1986.\n[W3C.REC-html401-19991224]\nRaggett, D., Le Hors, A., and I. Jacobs, \u0026ldquo;HTML 4.01 Specification\u0026rdquo;, World Wide Web Consortium Recommendation REC-html401-19991224, December 1999, http://www.w3.org/TR/1999/REC-html401-19991224.\n[W3C.REC-xml-20081126]\nBray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and F. Yergeau, \u0026ldquo;Extensible Markup Language (XML) 1.0 (Fifth Edition)\u0026rdquo;, World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, http://www.w3.org/TR/2008/REC-xml-20081126.\n12.2. 参考性引用文献 [OAuth-HTTP-MAC]\nHammer-Lahav, E., Ed., \u0026ldquo;HTTP Authentication: MAC Access Authentication\u0026rdquo;, Work in Progress, February 2012.\n[OAuth-SAML2]\nCampbell, B. and C. Mortimore, \u0026ldquo;SAML 2.0 Bearer Assertion Profiles for OAuth 2.0\u0026rdquo;, Work in Progress, September 2012.\n[OAuth-THREATMODEL]\nLodderstedt, T., Ed., McGloin, M., and P. Hunt, \u0026ldquo;OAuth 2.0 Threat Model and Security Considerations\u0026rdquo;, Work in Progress, October 2012.\n[OAuth-WRAP]\nHardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, \u0026ldquo;OAuth Web Resource Authorization Profiles\u0026rdquo;, Work in Progress, January 2010.\n[RFC5849]\nHammer-Lahav, E., \u0026ldquo;The OAuth 1.0 Protocol\u0026rdquo;, RFC 5849, April 2010.\n[RFC6750]\nJones, M. and D. Hardt, \u0026ldquo;The OAuth 2.0 Authorization Framework: Bearer Token Usage\u0026rdquo;, RFC 6750, October 2012.\n附录 A. 扩充巴库斯-瑙尔形式 (ABNF) 语法 本节使用 [RFC5234] 的表示法为本规范中定义的元素提供扩充巴科斯-瑙尔形式 (ABNF) 语法描述。下面的 ABNF 是根据 Unicode 代码点 [W3C.REC-xml-20081126] 定义的；这些字符通常以 UTF-8 编码。元素按首先定义的顺序呈现。\n下面的一些定义使用 [RFC3986] 中的“URI-reference”定义。\n下面的一些定义使用这些通用定义：\nVSCHAR = %x20-7E\rNQCHAR = %x21 / %x23-5B / %x5D-7E\rNQSCHAR = %x20-21 / %x23-5B / %x5D-7E\rUNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF / %xE000-FFFD / %x10000-10FFFF\r（UNICODECHARNOCRLF 定义基于 [W3C.REC-xml-20081126] 第 2.2 节中的 Char 定义，但省略了回车符和换行符。）\nA.1. \u0026ldquo;client_id\u0026rdquo; 语法 \u0026ldquo;client_id\u0026rdquo; 元素在 2.3.1 节定义:\nclient-id =*VSCHAR\rA.2. \u0026ldquo;client_secret\u0026rdquo; 语法 \u0026ldquo;client_secret\u0026rdquo; 元素在 2.3.1 节定义:\nclient-secret = *VSCHAR\rA.3. \u0026ldquo;response_type\u0026rdquo; 语法 \u0026ldquo;response_type\u0026rdquo; 元素在 3.1.1 和 8.4 节定义：\nresponse-type = response-name*( SP response-name )\rresponse-name = 1*response-char\rresponse-char = \u0026quot;_\u0026quot; / DIGIT / ALPHA\rA.4. \u0026ldquo;scope\u0026rdquo; 语法 \u0026ldquo;scope\u0026rdquo; 元素在 3.3 节定义：\nscope = scope-token *( SP scope-token )\rscope-token = 1*NQCHAR\rA.5. \u0026ldquo;state\u0026rdquo; 语法 \u0026ldquo;state\u0026rdquo; 元素在 4.1.1, 4.1.2, 4.1.2.1, 4.2.1, 4.2.2, 和 4.2.2.1 节定义：\nstate = 1*VSCHAR\rA.6. \u0026ldquo;redirect_uri\u0026rdquo; 语法 \u0026ldquo;redirect_uri\u0026rdquo; 元素在 4.1.1, 4.1.3, 和 4.2.1 节定义：\nredirect-uri = URI-reference\rA.7. \u0026ldquo;error\u0026rdquo; 语法 \u0026ldquo;error\u0026rdquo; 元素在 4.1.2.1, 4.2.2.1, 5.2, 7.2, 和 8.5 节定义：\nerror = 1*NQSCHAR\rA.8. \u0026ldquo;error_description\u0026rdquo; 语法 \u0026ldquo;error_description\u0026rdquo; 元素在 4.1.2.1, 4.2.2.1, 5.2, 和 7.2 节定义：\nerror-description = 1*NQSCHAR\rA.9. \u0026ldquo;error_uri\u0026rdquo; 语法 \u0026ldquo;error_uri\u0026rdquo; 元素在 4.1.2.1, 4.2.2.1, 5.2, 和 7.2 节定义：\nerror-uri = URI-reference\rA.10. \u0026ldquo;grant_type\u0026rdquo; 语法 \u0026ldquo;grant_type\u0026rdquo; 元素在 4.1.3, 4.3.2, 4.4.2, 4.5, 和 6 节定义：\ngrant-type = grant-name / URI-reference\rgrant-name = 1*name-char\rname-char = \u0026quot;-\u0026quot; / \u0026quot;.\u0026quot; / \u0026quot;_\u0026quot; / DIGIT / ALPHA\rA.11. \u0026ldquo;code\u0026rdquo; 语法 \u0026ldquo;code\u0026rdquo; 元素在 4.1.3 节定义：\ncode = 1*VSCHAR\rA.12. \u0026ldquo;access_token\u0026rdquo; 语法 \u0026ldquo;access_token\u0026rdquo; 元素在 4.2.2 和 5.1 节定义：\naccess-token = 1*VSCHAR\rA.13. \u0026ldquo;token_type\u0026rdquo; 语法 \u0026ldquo;token_type\u0026rdquo; 元素在 4.2.2, 5.1, 和 8.1 节定义：\ntoken-type = type-name / URI-reference\rtype-name = 1*name-char\rname-char = \u0026quot;-\u0026quot; / \u0026quot;.\u0026quot; / \u0026quot;_\u0026quot; / DIGIT / ALPHA\rA.14. \u0026ldquo;expires_in\u0026rdquo; 语法 \u0026ldquo;expires_in\u0026rdquo; 元素在 4.2.2 和 5.1 节定义：\nexpires-in = 1*DIGIT\rA.15. \u0026ldquo;username\u0026rdquo; 语法 \u0026ldquo;username\u0026rdquo; 元素在 4.3.2 节定义：\nusername = *UNICODECHARNOCRLF\rA.16. \u0026ldquo;password\u0026rdquo; 语法 \u0026ldquo;password\u0026rdquo; 元素在 4.3.2 节定义：\npassword =*UNICODECHARNOCRLF\rA.17. \u0026ldquo;refresh_token\u0026rdquo; 语法 \u0026ldquo;refresh_token\u0026rdquo; 元素在 5.1 和 6 节定义：\nrefresh-token = 1*VSCHAR\rA.18. Endpoint Parameter 语法 新端点参数的语法在 8.2 节定义:\nparam-name = 1*name-char\rname-char = \u0026quot;-\u0026quot; / \u0026quot;.\u0026quot; / \u0026quot;_\u0026quot; / DIGIT / ALPHA\r附录 B. application/x-www-form-urlencoded 媒体类型的使用 在本规范发布时，“application/x-www-form-urlencoded”媒体类型在 [W3C.REC-html401-19991224] 的第 17.13.4 节中定义，但未在 IANA MIME 媒体类型注册表中注册 （http://www.iana.org/assignments/media-types）。 此外，该定义是不完整的，因为它没有考虑非 US-ASCII 字符。\n为了在使用这种媒体类型生成有效负载时解决这个缺点，必须首先使用 UTF-8 字符编码方案 [RFC3629] 对名称和值进行编码； 然后需要使用 [W3C.REC-html401-19991224] 中定义的转义规则对生成的八位字节序列进行进一步编码。\n当从使用这种媒体类型的有效载荷中解析数据时，由于转换名称/值编码而产生名称和值，因此需要被视为八位字节序列，以使用 UTF-8 字符编码方案进行解码。\n例如，值中包含这六种 Unicode 编码点 (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN), (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN), (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) 将被编码到下面的八位字节序列中（使用十六进制表示法）:\n20 25 26 2B C2 A3 E2 82 AC\r然后在有效载荷中表示为:\n+%25%26%2B%C2%A3%E2%82%AC\r附录 C. 致谢 最初的 OAuth 2.0 协议规范由 David Recordon 编辑，基于之前的两个出版物：OAuth 1.0 社区规范 [RFC5849] 和 OAuth WRAP（OAuth Web Resource Authorization Profiles）[OAuth-WRAP]。 然后，Eran Hammer 编辑了许多演变成该 RFC 的中间草案。 安全注意事项部分由 Torsten Lodderstedt、Mark McGloin、Phil Hunt、Anthony Nadalin 和 John Bradley 起草。 关于使用“application/x-www-form-urlencoded”媒体类型的部分由 Julian Reschke 起草。 ABNF 部分由 Michael B. Jones 起草。\nOAuth 1.0 社区规范由 Eran Hammer 编辑并由 Mark Atwood、Dirk Balfanz、Darren Bounds、Richard M. Conlan、Blaine Cook、Leah Culver、Breno de Medeiros、Brian Eaton、Kellan Elliott-McCrea、Larry Halff、Eran Hammer、Ben Laurie、Chris Messina、John Panzer、Sam Quigley、David Recordon、Eran Sandler、Jonathan Sergent、Todd Sieling、Brian Slesinsky 和 Andy Smith 撰写。\nOAuth WRAP 规范由 Dick Hardt 编辑，由 Brian Eaton、Yaron Y. Goland、Dick Hardt 和 Allen Tom 撰写。\n该规范是 OAuth 工作组的工作，该工作组包括数十名积极和专注的参与者。特别是，以下个人提供了形成最终规范的想法、反馈和措辞：\nMichael Adams、Amanda Anganes、Andrew Arnott、Dirk Balfanz、Aiden Bell、John Bradley、Marcos Caceres、Brian Campbell、Scott Cantor、Blaine Cook、Roger Crew、Leah Culver、Bill de hOra、Andre DeMarre、Brian Eaton、Wesley Eddy、Wolter Eldering、Brian Ellin、Igor Faynberg、George Fletcher、Tim Freeman、Luca Frosini、Evan Gilbert、Yaron Y. Goland、Brent Goldman、Kristoffer Gronowski、Eran Hammer、Dick Hardt、Justin Hart、Craig Heath、Phil Hunt、Michael B. Jones、Terry Jones、John Kemp、Mark Kent、Raffi Krikorian、Chasen Le Hara、Rasmus Lerdorf、Torsten Lodderstedt、Hui-Lan Lu、Casey Lucas、Paul Madsen、Alastair Mair、Eve Maler、James Manger、Mark McGloin、Laurence Miao、William Mills、Chuck Mortimore、Anthony Nadalin、Julian Reschke、Justin Richer、Peter Saint-Andre、Nat Sakimura、Rob Sayre、Marius Scurtescu、Naitik Shah、Luke Shepard、Vlad Skvortsov、Justin Smith、Haibin Song、Niv Steingarten、Christian Stuebner、Jeremy Suriel、Paul Tarjan、Christopher Thomas、Henry S. Thompson、Allen Tom、Franklin Tse、Nick Walker、Shane Weeden 和 Skylar Woodward。\n本文件是在 Blaine Cook、Peter Saint-Andre、Hannes Tschofenig、Barry Leiba 和 Derek Atkins 的主持下编写的。 区域主管包括 Lisa Dusseault、Peter Saint-Andre 和 Stephen Farrell。\n作者地址 Dick Hardt (editor) Microsoft EMail: dick.hardt@gmail.com URI: http://dickhardt.org/\n","date":"2022-02-21T22:44:13Z","image":"https://static.aecra.cn/cover/The-OAuth-2.0-Authorization-Framework-in-Chinese.png","permalink":"https://aecra.github.io/article/the-oauth-2.0-authorization-framework-in-chinese/","title":"RFC6749 | OAuth 2.0 授权框架 中文版"},{"content":"Vmware 虚拟机开发的缘由 Windows 开发有时总是那么地不尽人意，尤其是当开发的服务需要在 Linux 中运行时，如果使用 Windows 开发，总是会出现一些莫名其妙的问题，所以使用 Linux 开发就很有必要。\nWindows 中使用 Linux 开发环境目前有 WSL2、Hyper-V、VitualBox、Vmware 这几种方案，其中 WSL2 和 Windows 系统的羁绊太深了，以至于许多配置不能随心所欲；Hyper-V 虽然灵活度更高一些，但经过实际使用发现它的启动与关闭耗时很长，性能也不是很好，更突出的问题是我至今尚未知晓其网络拓扑如何，这对实际使用造成了很大的困扰；VirtualBox 没有使用过，但因其开源免费的原因以后可能会切换到这个；Vmware 是独立性最好的，虚拟机的配置和存储都以独立文件的形式保存，方便移植和备份，同时其网络配置较为灵活，所以成了 Linux 开发的首选。\nVmware 虚拟机的启动与关闭 这里创建一个启动脚本和一个关闭脚本，两个脚本内容如下：\n启动脚本：\n\u0026#34;C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun.exe\u0026#34; start \u0026#34;D:\\virtual machine\\ubuntu20.04\\Ubuntu 20.04 64 位.vmx\u0026#34; nogui 关闭脚本：\n\u0026#34;C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun.exe\u0026#34; stop \u0026#34;D:\\virtual machine\\ubuntu20.04\\Ubuntu 20.04 64 位.vmx\u0026#34; soft 这里采用无 GUI 的方式启动，同时开启 ssh 服务以远程连接，这样就可以通过 ssh 远程连接到虚拟机进行开发了。\nVmware 虚拟机的无感运行 Windows 中设置开机自启动可以使用 Startup 文件夹或计划任务，但这里使用组策略。\n设置方式：\nwin + R 打开运行。 输入 gpedit.msc 打开本地组策略编辑器。 找到 用户配置-\u0026gt;Windows 设置 -\u0026gt; 脚本(登录/注销)。 在登陆和注销中分别添加上一小结的脚本。 经过重启与关闭可发现虚拟机已无感运行。\n","date":"2022-02-13T20:19:13Z","image":"https://static.aecra.cn/cover/VMware-development-virtual-machine-starts-and-shuts-down-with-the-system.jpg","permalink":"https://aecra.github.io/article/vmware-development-virtual-machine-starts-and-shuts-down-with-the-system/","title":"Vmware 开发虚拟机随系统启动与关闭"},{"content":"插入排序 Java\npublic class Insertion { private Insertion() { } public static void sort(Comparable[] a) { int n = a.length; for (int i = 1; i \u0026lt; n; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; less(a[j], a[j-1]); j--) { exch(a, j, j-1); } } } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } Go\nfunc InsertionSort(A []int) { for i := 1; i \u0026lt; len(A); i++ { for j := i; j \u0026gt; 0 \u0026amp;\u0026amp; A[j] \u0026lt; A[j-1]; j-- { A[j], A[j-1] = A[j-1], A[j] } } } 自顶向下归并排序 Java\npublic class Merge { private Merge() { } private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { for (int k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid+1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); merge(a, aux, lo, mid, hi); } public static void sort(Comparable[] a) { Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length-1); } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } } Go\nfunc MergeSort(A []int) { if len(A) \u0026lt;= 1 { return } mid := len(A) / 2 L := A[:mid] R := A[mid:] MergeSort(L) MergeSort(R) merge(L, R, A) } func merge(L, R, A []int) { C := make([]int, len(A)) i := 0 j := 0 for k := 0; k \u0026lt; len(C); k++ { if i \u0026gt;= len(L) { C[k] = R[j] j++ } else if j \u0026gt;= len(R) { C[k] = L[i] i++ } else if L[i] \u0026lt; R[j] { C[k] = L[i] i++ } else { C[k] = R[j] j++ } } copy(A, C) } 自底向上归并排序 Java\npublic class MergeBU { private MergeBU() { } private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { for (int k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid+1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } public static void sort(Comparable[] a) { int n = a.length; Comparable[] aux = new Comparable[n]; for (int len = 1; len \u0026lt; n; len *= 2) { for (int lo = 0; lo \u0026lt; n-len; lo += len+len) { int mid = lo+len-1; int hi = Math.min(lo+len+len-1, n-1); merge(a, aux, lo, mid, hi); } } } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } } Go\nfunc MergeBUSort(A []int) { for length := 1; length \u0026lt; len(A); length *= 2 { for lo := 0; lo \u0026lt; len(A)-length; lo += length * 2 { mid := lo + length var hi int if lo+length*2-1 \u0026lt; len(A)-1 { hi = lo + length*2 } else { hi = len(A) } merge(A[lo:mid], A[mid:hi], A[lo:hi]) } } } func merge(L, R, A []int) { C := make([]int, len(A)) i := 0 j := 0 for k := 0; k \u0026lt; len(C); k++ { if i \u0026gt;= len(L) { C[k] = R[j] j++ } else if j \u0026gt;= len(R) { C[k] = L[i] i++ } else if L[i] \u0026lt; R[j] { C[k] = L[i] i++ } else { C[k] = R[j] j++ } } copy(A, C) } 随机快速排序 Java\npublic class Quick { private Quick() { } public static void sort(Comparable[] a) { shuffle(a); sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } private static int partition(Comparable[] a, int lo, int hi) { int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) { if (i == hi) break; } while (less(v, a[--j])) { if (j == lo) break; } if (i \u0026gt;= j) break; exch(a, i, j); } exch(a, lo, j); return j; } private static boolean less(Comparable v, Comparable w) { if (v == w) return false; return v.compareTo(w) \u0026lt; 0; } private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } private static void shuffle(Object[] a) { validateNotNull(a); int n = a.length; for (int i = 0; i \u0026lt; n; i++) { int r = i + uniform(n-i); // between i and n-1 Object temp = a[i]; a[i] = a[r]; a[r] = temp; } } private static void validateNotNull(Object x) { if (x == null) { throw new IllegalArgumentException(\u0026#34;argument must not be null\u0026#34;); } } private static int uniform(int n) { if (n \u0026lt;= 0) throw new IllegalArgumentException(\u0026#34;argument must be positive: \u0026#34; + n); return random.nextInt(n); } } Go\nfunc QuickSort(A []int) { shuffle(A) quickSort(A) } func quickSort(A []int) { j := partition(A, 0, len(A)) if j \u0026gt; 0 { quickSort(A[:j]) } if j \u0026lt; len(A)-1 { quickSort(A[j+1:]) } } func partition(A []int, lo, hi int) int { pivot := A[lo] i := lo + 1 for j := lo + 1; j \u0026lt; hi; j++ { if A[j] \u0026lt; pivot { A[i], A[j] = A[j], A[i] i++ } } A[lo], A[i-1] = A[i-1], A[lo] return i - 1 } func shuffle(slice []int) { r := rand.New(rand.NewSource(time.Now().Unix())) for len(slice) \u0026gt; 0 { n := len(slice) randIndex := r.Intn(n) slice[n-1], slice[randIndex] = slice[randIndex], slice[n-1] slice = slice[:n-1] } } Dijkstra 3-路划分快速排序 Java\npublic class Quick3way { private Quick3way() { } public static void sort(Comparable[] a) { shuffle(a); sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo + 1; while (i \u0026lt;= gt) { int cmp = a[i].compareTo(v); if (cmp \u0026lt; 0) exch(a, lt++, i++); else if (cmp \u0026gt; 0) exch(a, i, gt--); else i++; } sort(a, lo, lt-1); sort(a, gt+1, hi); } private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } private static void shuffle(Object[] a) { validateNotNull(a); int n = a.length; for (int i = 0; i \u0026lt; n; i++) { int r = i + uniform(n-i); // between i and n-1 Object temp = a[i]; a[i] = a[r]; a[r] = temp; } } private static void validateNotNull(Object x) { if (x == null) { throw new IllegalArgumentException(\u0026#34;argument must not be null\u0026#34;); } } private static int uniform(int n) { if (n \u0026lt;= 0) throw new IllegalArgumentException(\u0026#34;argument must be positive: \u0026#34; + n); return random.nextInt(n); } } Go\nfunc Quick3WaySort(A []int) { shuffle(A) quick3WaySort(A, 0, len(A)) } func quick3WaySort(A []int, lo, hi int) { if hi-lo \u0026lt; 2 { return } lt := lo gt := hi - 1 i := lo pivot := A[lo] for i \u0026lt;= gt { if A[i] \u0026lt; pivot { A[lt], A[i] = A[i], A[lt] lt++ i++ } else if A[i] \u0026gt; pivot { A[i], A[gt] = A[gt], A[i] gt-- } else { i++ } } quick3WaySort(A, lo, lt) quick3WaySort(A, gt+1, hi) } func shuffle(slice []int) { r := rand.New(rand.NewSource(time.Now().Unix())) for len(slice) \u0026gt; 0 { n := len(slice) randIndex := r.Intn(n) slice[n-1], slice[randIndex] = slice[randIndex], slice[n-1] slice = slice[:n-1] } } ","date":"2022-02-13T11:58:25Z","image":"https://static.aecra.cn/cover/Sorting-algorithm.png","permalink":"https://aecra.github.io/article/sorting-algorithm/","title":"排序算法"},{"content":"编译安装 Nginx 上接 NGINX 入门指导,由于安装版本号为 1.20.1 所以不考虑旧版适配问题，其中编译选项增加的模块 --with-stream 和 --with-stream_ssl_preread_module 就是本次需要的功能模块。\n配置 Nginx 由于是转发的 TCP 连接，所以不再使用在 http 模块中添加内容，而是在 stream 中添加，如下是简单的 TCP 连接转发配置：\nstream {\rserver {\rlisten 7854;\rproxy_connect_timeout 3s;\rproxy_timeout 3600s;\rproxy_pass 127.0.0.1:3306;\r}\r} 本次使用 ssl_preread 功能实现依据域名转发 TCP 连接。\nstream {\rmap $ssl_preread_server_name $name {\rgit.aecra.cn git_ssh_backend;\rdefault ssh_default_backend;\r}\rupstream git_ssh_backend {\rserver 127.0.0.1:7022;\r}\rupstream ssh_default_backend {\rserver 127.0.0.1:1022;\r}\rserver {\rlisten 22;\rproxy_connect_timeout 3s;\rproxy_timeout 36000s;\rproxy_pass $name;\rssl_preread on;\r}\r} 其中 7022 端口是 Git 服务，1022 端口是 ssh 服务。通过 Nginx 的转发我们可以在一个 22 端口上实现多个 ssh 服务。\n","date":"2022-02-11T17:08:45Z","image":"https://static.aecra.cn/cover/Forwarding-TCP-connections-by-domain-name-in-Nginx.png","permalink":"https://aecra.github.io/article/forwarding-tcp-connections-by-domain-name-in-nginx/","title":"Nginx 中按域名转发 TCP 连接"},{"content":"简要说明 这篇文章本来是没有的，但之前突发奇想在 Windows上整了一个 Oh My Zsh，见文章Windows 中使用 Oh My Zsh 的各种方式，可 TMD 第二天就卡的要死，打开稳定耗时八九秒，输入命令真成了打字机，也没找到解决方案，又不甘心放弃 ys 主题，但还好找到了美化 power shell 输出提示的方法。\n最终效果如下：\nPrompts Prompts 函数可以用来创建自定义提示，这样就能替换下面这样的古董级终端命令提示。\nPS C:\\\u0026gt; 第一步，生成 power shell 配置文件。\nnotepad $Profile 该文件一般在用户的文档目录中，在其中增加函数 Prompts 即可实现命令提示的自定义。如果没有 return 则以最后一个字符串作为返回值。\nfunction Prompt { \u0026#34;command prompts \u0026gt;\u0026#34; } 之后我们对其做需要的修改即可。\nVT 转义字符 转义字符只有 power shell 5 才开始支持，不过一般电脑也就是这个版本的，有关转义字符的介绍可以参见 ANSI 转义序列以及输出颜色字符详解，我们用到的是使用转义字符设置前景色。如下是示例。\n$esc = [char]27 $at = \u0026#34;$esc[38;2;189;189;219m@$esc[0m\u0026#34; 输出效果是颜色为 rgb(189,189,219) 的 @，依照此格式我们可以设置我们需要的命令提示的颜色。\nys 主题仿制 如上面图片所示，只实现了提示内容及颜色、Git 分支提示的支持，更多功能尚不支持，如果需要可以自己依据开发思路去自定义，如此也可实现自己喜欢的bash主题。\nfunction Prompt { # 转义规则参见 https://www.cnblogs.com/xiaoqiangink/p/12718524.html $esc = [char]27 $jing = \u0026#34;$esc[38;2;189;189;219m#$esc[0m\u0026#34; $at = \u0026#34;$esc[38;2;158;158;158m@$esc[0m\u0026#34; $on = \u0026#34;$esc[38;2;158;158;158mon$esc[0m\u0026#34; $in = \u0026#34;$esc[38;2;158;158;158min$esc[0m\u0026#34; $nl = [Environment]::NewLine $user = \u0026#34;$esc[38;2;122;184;184m$env:username$esc[0m\u0026#34; $hostname = \u0026#34;$esc[38;2;122;184;122m$env:ComputerName$esc[0m\u0026#34; $localtime = \u0026#34;$esc[38;2;158;158;158m[$(Get-Date -Format \u0026#39;hh:mm:ss\u0026#39;)]$esc[0m\u0026#34; $pattern = $env:userprofile -replace \u0026#39;\\\\\u0026#39;, \u0026#39;\\\\\u0026#39; $promptString = \u0026#34;$(Get-Location)\u0026#34; -replace $pattern, \u0026#34;~\u0026#34; $promptString = $promptString -replace \u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39; $promptString = \u0026#34;$esc[38;2;219;219;189m$promptString$esc[0m\u0026#34; $git_branch = \u0026#34;\u0026#34; git rev-parse | Out-Null if ($?) { $branch = $(git branch --show-current --no-color) $branch = \u0026#34;$esc[38;2;122;184;184m$branch$esc[0m\u0026#34; $gitm = \u0026#34;$esc[38;2;217;230;242mgit:$esc[0m\u0026#34; $git_branch = \u0026#34; $on $gitm$branch\u0026#34; } \u0026#34;$jing $user $at $hostname $in $promptString$git_branch $localtime $nl\u0026#34; } Windows terminal 主题 我使用的主题配置如下：\n{ \u0026#34;background\u0026#34;: \u0026#34;#0D1926\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#7A7AB8\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#535353\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#BDBDDB\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#BDDBDB\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#BDDBBD\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#DBBDDB\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#DBBDBD\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#DBDBBD\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#7AB8B8\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#D9E6F2\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#7AB87A\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Blazer\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#B87AB8\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#B87A7A\u0026#34;, \u0026#34;selectionBackground\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#D9D9D9\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#B8B87A\u0026#34; }, terminal 配色可以从 iTerm2-Color-Schemes 和 Windows Terminal Themes 获取。\n","date":"2021-12-12T17:06:38Z","image":"https://static.aecra.cn/cover/powershell-beautification-for-ys-themes.png","permalink":"https://aecra.github.io/article/powershell-beautification-for-ys-themes/","title":"PowerShell 美化之 ys 主题"},{"content":"方式介绍 首先需要明确的是 zsh 不存在 Windows 版本的命令工具。所以在实现上都需要我们有一个 Linux 系统。在 Windows 中既有 WSL2 这种 Windows 支持的 Linux 子系统，也可以使用 cygwin 和 MSYS2 这类对 Linux 系统的模拟软件，所以我们得解决方案有以下三种，不排除有其他方法。\nWSL2 MSYS2 cygwin WSL2 安装 Oh My Zsh 在 WSL2 中安装 Oh My Zsh 的方法和 Linux 基本没有太大差别，WSL2 如何安装请自行搜索相关资料，先安装 zsh。\napt-get install zsh 然后需要安装 oh my zsh，在官网中提供了如下几种安装方式，如果你所在的地区可以正常访问 Github 则请用这种方法，如果不行请见下文。\nMethod Command curl sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; wget sh -c \u0026quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; fetch sh -c \u0026quot;$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 不能访问 Github 可以下载这个压缩包 ohmyzsh ，将其中的 .oh-my-zsh.zip 解压后放到 WSL2 用户根目录下，并在用户根目录下执行 omz.sh 文件，其中修改了需要克隆的文件资源过程。执行中可选择将 zsh 设置为默认 bash。\n之后修改 .zshrc 即可配置 oh my zsh，这里给出常用的配置修改。\n# 修改主题 ZSH_THEME=\u0026#34;ys\u0026#34; # 增加插件 plugins=( git zsh-syntax-highlighting zsh-autosuggestions ) 默认是不带 zsh-syntax-highlighting 和 zsh-autosuggestions 的可以使用如下命令获取，如果添加的是我提供的文件夹，那么这两个已经附带了。\n# zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM}/plugins/zsh-syntax-highlighting # zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM}/plugins/zsh-autosuggestions 到现在我们的 oh my zsh 已经可用了。对于需要使用 Linux 子系统开发的人来说还需要在 Linux 子系统中安装环境支持，这里不再赘述。\n通过 MSYS2 使用 Oh My Zsh MSYS2 is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.\nMSYS2 提供了了本地工具集，我们可以使用它来安装 Oh My Zsh，从 MSYS2 下载并安装 MSYS2，可以选择安装目录，这里如果是选择Windows的用户目录效果更好，如此便不需要修改用户目录；首次运行需要执行 pacman -Syu 更新包数据库和基本包。之后从启动菜单开启，运行 pacman-Su 来更新其他包。\n使用 pacman -S zsh 来安装 zsh，之后采用和上一节一样的方法安装即可。\n如果选择安装目录不是用户根目录，则最好将目录改为 Windows 用户根目录，先生成 passwd 文件，这一步需要在 MSYS2 中运行。\n/usr/bin/mkpasswd.exe \u0026gt; /etc/passwd 生成文件之后，修改文件中指定用户的根目录即可，一般修改为 /c/Users/用户名，然后将 MSYS2 用户根目录中的 .zshrc 复制到 Windows 用户根目录中即可。\n需要注意的是，把 MSYS2 中 /usr/bin 目录添加到 Windows 环境变量中就能使用各种支持的工具，另外，这种方法中使用 zsh 可以同时使用 Windows 的各种工具和 Linux 系列的工具，不需要额外配置开发工具了。\n注意：两天后因卡顿已放弃，既然因为颜值而折腾为什么就不能美化 power shell 呢？参见 PowerShell 美化之 ys 主题。\n通过 cygwin 使用 Oh My Zsh a large collection of GNU and Open Source tools which provide functionality similar to a Linux distribution on Windows. a DLL (cygwin1.dll) which provides substantial POSIX API functionality.\n我没用这个东西，但使用上应该和 MSYS2 差不太多，可以参照官网使用或者自行搜索相关方法。\n问题集合 WSL2 中 Windows 文件夹背景色问题 在 WSL2 中切换到用户根目录，执行如下指令。\ndircolors -p \u0026gt; .dircolors 在文件 .dircolors 中找到 OTHER_WRITABLE 字段，修改其后的第二个数字为 49，保存。\n在 .zshrc 中添加如下内容。\n# enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026amp;\u0026amp; eval \u0026#34;$(dircolors -b ~/.dircolors)\u0026#34; || eval \u0026#34;$(dircolors -b)\u0026#34; alias ls=\u0026#39;ls --color=auto\u0026#39; #alias dir=\u0026#39;dir --color=auto\u0026#39; #alias vdir=\u0026#39;vdir --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; fi 重新 source 之后即可消除背景色。\nzsh 中中文乱码问题 在 .zshrc 中添加如下内容。\nexport LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 重新 source 之后即可正常显示中文。\nterminal 推荐 在 Windows 中推荐使用 Windows terminal，其可以支持各种 bash 和 shell 工具，在设置中可以将 MSYS2 安装的 zsh 添加进去并设置为默认。\nterminal 配色可以从 iTerm2-Color-Schemes 和 Windows Terminal Themes 获取。\n","date":"2021-12-10T16:00:28Z","image":"https://static.aecra.cn/cover/use-oh-my-zsh-in-windows.png","permalink":"https://aecra.github.io/article/use-oh-my-zsh-in-windows/","title":"Windows 中使用 Oh My Zsh 的各种方式"},{"content":"Git 设置用户名和邮箱 既然要做多人开发，那么必然要设置不同的用户名和邮箱，下面是设置的命令。\n# 全局设置 git config --global user.name \u0026lt;username\u0026gt; git config --global user.email \u0026lt;email\u0026gt; # 分支设置 git config user.name \u0026lt;username\u0026gt; git config user.email \u0026lt;email\u0026gt; 如上，我们可以对每个人设置一个分支，在不同分支中使用不同的用户名和邮箱。\n安装 git-filter-repo git-filter-repo 的项目地址在 git-filter-repo ，安装要求是 Git 版本不低于 2.22.0，python3 版本不低于3.5。python3 一般是 Linux 平台中使用并于python2 区分的，但在 Windows 中是不可用的。在 INSTALL.md 中有 Windows 用户须知，但令人难受的是这一小节并没有说如何安装这个 python 脚本，另外见到代码目录中 git_filter_repo.py 文件最近修改时间是三年前，也i就没尝试这个脚本，话说，他就不能写清楚吗？\n虽然不能直接在 Windows 直接使用，但我们有 WSL2 啊，在 INSTALL.md 中有以下 bash指令：\nPACKAGE_TOOL install git-filter-repo 我们 WSL2 中有 apt-get 啊，当把命令输进去后，竟然显示没有 git-filter-repo 这个东西，What Fuck! 只能使用 pip 安装了，但它提示这个并不会把这个脚本自动添加到 PATH 中，不过没关系，到这一步了也不在乎这么一点小缺点了,安装后添加按照如下命令添加 PATH。\n# 当前终端有效 export PATH=$PATH:/xxx/xxx # 永久有效 # 最后一行添加上面的指令 vi .bashrc 现在我们终于把这玩意装好了。\n修改用户信息 第一步，我们需要克隆一份干净的仓库，切换的新目录并克隆。\n在仓库目录下执行如下命令。\n#将所有用户名中包含的old 替换成 new（注意，不支持中文) git filter-repo --name-callback \u0026#39;return name.replace(b\u0026#34;old\u0026#34;, b\u0026#34;new\u0026#34;)\u0026#39; #将所有 commit 信息的 email中包含的 old@example.com 替换成 new@example.com git filter-repo --email-callback \u0026#39;return email.replace(b\u0026#34;old@example.com\u0026#34;, b\u0026#34;new@example.com\u0026#34;)\u0026#39; 当中指令执行完之后所有作者信息就都被修改了，就可以把这个本地仓库提交到我们希望的远程仓库了。\n因为信息修改了，所以远程仓库同步地消失了，这时需要手动添加远程仓库 git remote add origin \u0026lt;repo.git\u0026gt;，然后强制提交更新。\ngit push --force --tags origin \u0026#39;refs/heads/*\u0026#39; 需要注意的是，不要修改已提交到远程仓库的 commit 的作者信息，这会产生大量冲突，对项目管理十分不友好。\n所以在使用多个账号提交 GIt 记录时，一定要事先设置用户名和邮箱。\n","date":"2021-12-09T21:01:46Z","image":"https://static.aecra.cn/cover/change-author-in-git-commit.png","permalink":"https://aecra.github.io/article/change-author-in-git-commit/","title":"修改 Git 记录中的作者信息"},{"content":"事由 在开发微信小程序的过程中，因为要维护全局用户数据，所以各个页面都要从 app.js 同步用户数据；另外在一些其他的全局数据中也需要使用此功能。\n在微信开发文档中只有通过 app.globalData 实现数据获取全局数据的方法。因为全局数据是从后端获取的，所以页面加载过程中不知晓全局数据什么时候准备好，所以在同步数据过程中只能延时获取，但该方法时间长了影响用户体验，时间短了并不能获取到数据；还可以循环调用直到数据完成同步，但这种方法需要检测数据内容，对数据有强依赖。\n在今天查找解决方案的时候，才发现 JavaScript 中发布订阅的使用方法。\n代码实现 class Event { /** on 方法把订阅者所想要订阅的事件及相应的回调函数记录在 Event 对象的 cbs 属性中并调用 */ on(event, fn) { if (typeof fn !== \u0026#39;function\u0026#39;) { // eslint-disable-next-line no-console console.error(\u0026#39;fn must be a function\u0026#39;); return; } this.cbs = this.cbs || {}; this.data = this.data || {}; (this.cbs[event] = this.cbs[event] || []).push(fn); if (this.data[event]) { const callbacks = this.cbs[event]; callbacks?.forEach((callback) =\u0026gt; { callback(this.data[event]); }); } } /** emit 方法接受一个事件名称参数，在 Event 对象的 cbs 属性中取出对应的数组，并逐个执行里面的回调函数 */ emit(event, data) { this.cbs = this.cbs || {}; this.data = this.data || {}; this.data[event] = data; const callbacks = this.cbs[event]; callbacks?.forEach((callback) =\u0026gt; { callback(data); }); } /** off 方法接受事件名称和当初注册的回调函数作参数，在 Event 对象的 cbs 属性中删除对应的回调函数。 */ off(event, fn) { this.cbs = this.cbs || {}; this.data = this.data || {}; // all if (!arguments.length) { this.cbs = {}; return; } const callbacks = this.cbs[event]; if (!callbacks) return; const data = this.data[event]; if (!data) return; // remove all handlers if (arguments.length === 1) { delete this.cbs[event]; delete this.data[event]; return; } // remove specific handler let cb; for (let i = 0, len = callbacks.length; i \u0026lt; len; i += 1) { cb = callbacks[i]; if (cb === fn || cb.fn === fn) { callbacks.splice(i, 1); break; } } } } export default Event; ","date":"2021-12-05T21:38:25Z","image":"https://static.aecra.cn/cover/implementation-publish-and-subscription-by-javascript.png","permalink":"https://aecra.github.io/article/implementation-publish-and-subscription-by-javascript/","title":"JavaScript 实现发布订阅"},{"content":"结构体 Golang 中没有类，但可以定义类型上的方法，同时有接口，可以通过接口定义对象的要求。也可以通过类型定义对象的构造方法及行为。\n什么是结构体？在 Go 结构体是字段的集合。\ntype Vertex struct { X int Y int } 访问方法 对于结构体对象可以使用 . 访问对象成员。在使用指针时，虽然可以使用 (*p) 来访问对象成员，但在 Go 中可以直接使用 指针.成员变量 的方式访问成员变量。\n结构体对象的定义 结构体对象有多种定义方法，以上文的结构体来举例。\nv1 = Vertex{1, 2} v2 = Vertex{X: 1} v3 = Vertex{} p = \u0026amp;Vertex{1, 2} 方法 方法是一个具有特殊接收器参数的函数。其中方法的调用变量在函数名之前，示例如下。\ntype Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 这里的方法与 Go 的函数只有接收对象的区别，其他和不同函数相同。\n前面说到但可以定义类型上的方法，这里需要指出，方法的定义只能与变量声明在一个包中，不能定义在其他包中定义的变量类型的方法，同样内置变量类型也是不可以的，但可以通过 type MyFloat float64 方式来定义自己的变量类型之后添加方法。\n指针接收器 在 Go 中所有的对象复制都是拷贝，所以在声明方法时使用的不是指针变量，那么在方法中对变量的操作都是无法修改原变量的，可以使用指针接收器来修改原变量。\n那么值接收器改为了指针接收器，调用时也必须使用指针变量吗？当然不是，在 Go 中为方便，会自动将 p 转换成 (\u0026amp;p) 因为 p 有一个指针接收器。同样的，如果声明的是值接收器，可以直接使用指针调用方法。\n需要注意的是，同一个方法只能设置一种接收器，即不可同时声明值接收器和指针接收器。\n接口 接口定义了一组方法的集合。\n和其他语一样，接口类型的值可以保存实现这些方法的任何值。\n需要注意的是，接口类型的值如果需要保存一个值变量或指针变量，那么该值类型必须实现接口定义的值接收器方法或指针接收器方法。如果函数定义在值类型上，那么接口类型的值可以保存指针变量（解除指针）。但是定义了指针接收器方法的值类型不能赋值给接口，因为 Golang 中赋值是拷贝，虽然可以把接口中保存的值的指针给到函数，但这个值已经不是原来的那个值了，如此毫无意义，甚至会让新手写出许多隐性 Bug。\n接口的实现是隐式的，不需要 implements 等关键字，隐式接口将接口的定义与其实现分离开来，然后接口可以不需要预先书写就出现在任何包中。\n接口类型的值保存了实现接口的值类型的值及其类型。\n(value, type) 空指针异常的处理 在 Go 中通过 nil 接收器处理处理空指针异常的情况。当接口保存的对象值为空时，指针接收器中判断接收对象是否为 nil 即可处理空指针异常。\n需要注意的是，这种空指针异常的处理方法针对的是接口内部保存的是空值的情况，如果接口本身是空值是会报错的。\n类型断言 类型断言提供对接口值的底层具体值的访问。\nt := i.(T) 如果接口保存的值与指定的值类型不同，则会产生 panic。\n可以通过指定第二个参数来获取断言的正确性，此时不会产生 panic。\ns, ok := i.(string) 嵌入 嵌入实现了部分类继承的需求。\n用类型声明但没有显式字段名称的字段称为嵌入字段。嵌入字段必须指定为类型名 t 或指向非接口类型名 * t 的指针，而且 t 本身可能不是指针类型。未限定的类型名充当字段名。\nstruct { T1 // field name is T1 *T2 // field name is T2 P.T3 // field name is T3 *P.T4 // field name is T4 x, y int // field names are x and y } 在创建有嵌入的结构体的对象时，必须显式地初始化嵌入类型。\nco := container{ base: base{ num: 1, }, str: \u0026#34;some name\u0026#34;, } 含有嵌入类型的结构体会继承嵌入类型上所定义的方法，同样地会实现相关接口，对于嵌入类型的成员变量可以通过完整的变量寻址路径来获取，也可以直接通过 . 来获取。\n","date":"2021-11-22T18:11:40Z","image":"https://static.aecra.cn/cover/object-oriented-in-go.png","permalink":"https://aecra.github.io/article/object-oriented-in-go/","title":"Go 中的面向对象"},{"content":"问题描述 该问题是 Windows 和 Linux 双系统中，因先安装 Windows 后安装 Linux 而导致 Linux 引导 Windows。该情况下系统可以正常启动，无论启动 Windows 还是 Linux 都是没问题的，至于为什么说这是问题呢？因为个人觉得 Linux 的启动引导太丑了，和 Windows 的风格差异过于巨大。 另外，我以为先装 Linux 后装 Windows 可以实现 Windows 引导 Linux，但看过些不知道对不对的资料，说是 Windows 系统无法识别 Linux 的启动项，可能会覆盖，导致无法启动 Linux，该问题留待查究。\n实现目标 由上所说，Linux 的启动引导过于丑陋，且一般情况下使用 Windows，进入 Linux 的情况较少，所以最终结果是开机直接启动 Windows，可以通过电脑启动项进入 Linux。\n实现方法 因为是两个系统都可以进入，所以我找到的方法也是系统正常启动下的方法，直接使用 Linux 系统自带的 efibootmgr 方法就可以完成我的要求。\n在命令行中键入 efibootmgr 并执行，就可以得到如下结果，\naecra@UUIK:~$ efibootmgr BootCurrent: 0009 Timeout: 0 seconds BootOrder: 0004,0009,0008,0006,0007,9999 Boot0004* Windows Boot Manager Boot0006* ubuntu Boot0007* Solid State Disk Boot0008* UOS Boot0009* deepin Boot9999* USB Drive (UEFI) 可以看到，我们第一行的结果显示的是 BootCurrent: 0009，对应到下面的就是 deepin，也就是当前所在系统。\n注意第三行，我们的启动顺序（BootOrder）是 0004,0009,0008,0006,0007,9999。正是通过修改该项实现的启动引导顺序更改，我现在的第一个启动项就是 Windows，修改命令如下：\nefibootmgr -o 0004,0009,0008,0006,0007,9999 另外有关启动项的其他设置也可以使用此命令，具体内容如下：\nusage: efibootmgr [options]\n-a | \u0026ndash;active sets bootnum active\n-A | \u0026ndash;inactive sets bootnum inactive\n-b | \u0026ndash;bootnum XXXX modify BootXXXX (hex)\n-B | \u0026ndash;delete-bootnum delete bootnum\n-c | \u0026ndash;create create new variable bootnum and add to bootorder\n-C | \u0026ndash;create-only create new variable bootnum and do not add to bootorder\n-D | \u0026ndash;remove-dups remove duplicate values from BootOrder\n-d | \u0026ndash;disk disk (defaults to /dev/sda) containing loader\n-r | \u0026ndash;driver Operate on Driver variables, not Boot Variables.\n-e | \u0026ndash;edd [1|3|-1] force EDD 1.0 or 3.0 creation variables, or guess\n-E | \u0026ndash;device num EDD 1.0 device number (defaults to 0x80)\n-g | \u0026ndash;gpt force disk with invalid PMBR to be treated as GPT\n-i | \u0026ndash;iface name create a netboot entry for the named interface\n-l | \u0026ndash;loader name (defaults to \u0026ldquo;\\EFI\\debian\\grub.efi\u0026rdquo;)\n-L | \u0026ndash;label label Boot manager display label (defaults to \u0026ldquo;Linux\u0026rdquo;)\n-m | \u0026ndash;mirror-below-4G t|f mirror memory below 4GB\n-M | \u0026ndash;mirror-above-4G X percentage memory to mirror above 4GB\n-n | \u0026ndash;bootnext XXXX set BootNext to XXXX (hex)\n-N | \u0026ndash;delete-bootnext delete BootNext\n-o | \u0026ndash;bootorder XXXX,YYYY,ZZZZ,\u0026hellip; explicitly set BootOrder (hex)\n-O | \u0026ndash;delete-bootorder delete BootOrder\n-p | \u0026ndash;part part (defaults to 1) containing loader\n-q | \u0026ndash;quiet be quiet\n-t | \u0026ndash;timeout seconds set boot manager timeout waiting for user input.\n-T | \u0026ndash;delete-timeout delete Timeout.\n-u | \u0026ndash;unicode | \u0026ndash;UCS-2 handle extra args as UCS-2 (default is ASCII)\n-v | \u0026ndash;verbose print additional information\n-V | \u0026ndash;version return version and exit\n-w | \u0026ndash;write-signature write unique sig to MBR if needed\n-y | \u0026ndash;sysprep Operate on SysPrep variables, not Boot Variables.\n-@ | \u0026ndash;append-binary-args file append extra args from file (use \u0026ldquo;-\u0026rdquo; for stdin)\n-h | \u0026ndash;help show help/usage\n特别注意大小写问题！！！\n","date":"2021-10-28T18:52:34Z","image":"https://static.aecra.cn/cover/windows-linux-dual-system-boot-problem.jpg","permalink":"https://aecra.github.io/article/windows-linux-dual-system-boot-problem/","title":"Windows \u0026 Linux 双系统启动引导问题"},{"content":"异步编程 该部分可以参考 JavaScript 中的异步编程，其中较为详细地介绍了各种异步编程的实现方案的优缺点，为了方便开发我使用了 async/await 方式去解决异步编程的问题。\n错误处理 在上面文章中 async/await 的方案中无法实现 Promise 的错误处理，该问题是在处理项目 网络书签 时遇到的，原始代码如下：\nexports.main = async (event) =\u0026gt; { const client = createClient(event.webdavurl, { username: event.username, password: event.password, }); // 获取文件内容 const buff = await client.getFileContents(event.path); // 将文件内容从二进制转换成字符串 const decoder = new util.TextDecoder(); const xmldata = decoder.decode(buff); // 解析文件内容 const parser = new xml2js.Parser(); const bookmark = await parser.parseStringPromise(xmldata); return { xbel: bookmark.xbel }; }; 如上可见，async/await 方式中我并没有添加任何错误处理程序，在这两天开始完善代码的时候，尝试过用 Promise.then().catch() 的方法去实现，但不能完美地定位某个错误(增加的那个 if 多丑啊)，而且代码量明显增加，代码如下：\nexports.main = async (event) =\u0026gt; { const client = createClient(event.webdavurl, { username: event.username, password: event.password, }); const result = await client .getFileContents(event.path) .then((buff) =\u0026gt; { // 将文件内容从二进制转换成字符串 const decoder = new util.TextDecoder(); const xmldata = decoder.decode(buff); // 解析文件内容 const parser = new xml2js.Parser(); return parser.parseStringPromise(xmldata); }) .then((bookmark) =\u0026gt; ({ xbel: bookmark.xbel, })) .catch((e) =\u0026gt; { if (e.message === \u0026#39;Invalid response: 401 Unauthorized\u0026#39;) { return Error(\u0026#39;配置信息错误！\u0026#39;); } return Error(\u0026#39;文件解析错误！\u0026#39;); }); if (result instanceof Error) { return { error: result.message, }; } return result; }; 在有使用 try\u0026hellip;catch 代码的想法的时候察觉到了有那么点违和感，所以在网上搜索得知了如下处理方式。\nawait-to await-to 的思想很简单，其中借鉴了 Go 的错误处理方法，对 Promise 进行包装。\nGo 的错误处理方法如下：\ndata, err := db.Query(\u0026#34;SELECT ...\u0026#34;) if err != nil { return err } 很容易地就想到我们可以采用类似的方式去解决 async/await 的错误。\n创建一个包装函数如下：\nfunction to(promise) { return promise .then((data) =\u0026gt; { return [null, data]; }) .catch((err) =\u0026gt; [err]); } 上面的代码可以改成：\nexports.main = async (event) =\u0026gt; { const client = createClient( event.webdavurl, { username: event.username, password: event.password, }, ); // 获取文件内容 const [err1, buff] = await to(client.getFileContents(event.path)); if (err1) return { error: \u0026#39;配置信息错误！\u0026#39; }; // 将文件内容从二进制转换成字符串 const decoder = new util.TextDecoder(); const xmldata = decoder.decode(buff); // 解析文件内容 const parser = new xml2js.Parser(); const [err2, bookmark] = await to(parser.parseStringPromise(xmldata)); if (err2) return { error: \u0026#39;文件解析错误！\u0026#39; }; return { xbel: bookmark.xbel }; 通过这种方式我们的错误处理更加简洁和易读，想要了解更多可以参考 How to write async await without try-catch blocks in Javascript 和 await-to-js。\n","date":"2021-10-18T16:53:59Z","image":"https://static.aecra.cn/cover/how-to-gracefully-implement-async-await-error-handing.jpg","permalink":"https://aecra.github.io/article/how-to-gracefully-implement-async-await-error-handing/","title":"如何优雅地实现 async/await 的错误处理"},{"content":"前言 Go 语言追求简洁优雅，所以，Go 语言不支持传统的 try … catch … finally 这种异常，因为 Go 语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在 Go 语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，也就是说，遇到真正的异常的情况下（比如除数为 0 了）。才使用 Go 中引入的 Exception 处理：defer, panic, recover。\n这几个异常的使用场景可以这么简单描述：Go 中可以抛出一个 panic 的异常，然后在 defer 中通过 recover 捕获这个异常，然后正常处理。\n代码示例 package main import \u0026#34;fmt\u0026#34; func main() { // 必须要先声明 defer，否则不能捕获到 panic 异常 // 解释：出现异常后直接跳过 return，执行 defer 代码 defer func() { fmt.Println(\u0026#34;d\u0026#34;) if err := recover(); err != nil { fmt.Println(err) } fmt.Println(\u0026#34;e\u0026#34;) }() fmt.Println(\u0026#34;a\u0026#34;) panic(55) fmt.Println(\u0026#34;b\u0026#34;) fmt.Println(\u0026#34;c\u0026#34;) } 输出：\na d 55 e defer defer 的意思是延迟，意为其后的代码延迟执行，在 Go 中，defer 的代码将在 panic 和 return 后执行；类似于 C++的析构函数，在函数结束后执行，但 defer 语句是动态的，在上面那个例子中，如果 panic 出现在 defer 之前，defer 语句并未被执行也就没有相应的错误处理。\ndefer 的三大特性：\ndefer 语句声明时，其参数立即求值\nA deferred function’s arguments are evaluated when the defer statement is evaluated\ndefer 函数在其后代码执行完之后按照先进后出的顺序执行\nDeferred function calls are executed in Last In First Out order after the surrounding function returns.\ndefer 语句可读取并修改函数的命名返回值\nDeferred functions may read and assign to the returning function’s named return values.\ndefer 的其他使用场景：\n释放一个信号量\nmu.Lock() defer mu.Unlock() 输出底部信息\nprintHeader() defer printFooter() panic Panic 是一个内置的函数，它停止普通的控制流并开始恐慌。当函数 F 调用 panic 时，F 的执行停止，F 中的任何延迟函数被正常执行，然后 F 返回给它的调用者。对于调用者来说，F 的行为就像对 panic 的调用。这个过程继续在堆栈中进行，直到当前 goroutine 中的所有函数都返回，这时程序就会崩溃。除非在 defer 函数中调用了 recover 函数处理了 panic，这时恐慌将不会继续向上传递。恐慌可以通过直接调用 panic 来启动。它们也会由运行时错误引起，如越界数组访问。\nrecover recover 是一个内置的函数，可以重新获得对一个恐慌的 goroutine 的控制。Recover 只在延迟函数中有用。在正常执行过程中，对 recover 的调用将返回 nil，没有其他影响。如果当前的 goroutine 处于恐慌状态，对 recover 的调用将捕获给定的恐慌值并恢复正常执行。\n","date":"2021-10-12T20:44:50Z","image":"https://static.aecra.cn/cover/go-exception-handling.png","permalink":"https://aecra.github.io/article/go-exception-handling/","title":"Go 的异常处理"},{"content":"SSL 是什么？ SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层与应用层之间对网络连接进行加密。\nSSL 证书 SSL 证书是一种遵守 SSL 协议的服务器数字证书，由受信任的根证书颁发机构颁发。\n证书格式 .DER .CER，文件是二进制格式，只保存证书，不保存私钥。\n.PEM，一般是文本格式，可保存证书，可保存私钥。\n.CRT，可以是二进制格式，可以是文本格式，与 .DER 格式相同，不保存私钥。\n.PFX .P12，二进制格式，同时包含证书和私钥，一般有密码保护。\n.JKS，二进制格式，同时包含证书和私钥，一般有密码保护。\n证书转换 CER/CRT\n将“cert.crt”证书文件直接重命名为“cert.pem”。\nPFX\n提取私钥命令，以“cert.pfx”转换为“key.pem”为例。\nopenssl pkcs12 -in cert.pfx -nocerts -out key.pem\n提取证书命令，以“cert.pfx”转换位“cert.pem”为例。\nopenssl pkcs12 -in cert.pfx -nokeys -out cert.pem\nP7B\n证书转换，以“cert.p7b”转换为“cert.cer”为例。\nopenssl pkcs7 -print_certs -in cert.p7b -out cert.cer\n将“cert.cer”证书文件直接重命名为“cert.pem”。\nDER\n提取私钥命令，以“privatekey.der”转换为“privatekey.pem”为例。 openssl rsa -inform DER -outform PEM -in privatekey.der -out privatekey. pem\n提取证书命令，以“cert.cer”转换为“cert.pem”为例。 openssl x509 -inform der -in cert.cer -out cert.pem 遇到的坑 在上面我们可以很清楚地区分各个 SSL 证书的格式和区别，我遇到的问题开头就说了是两个字母的问题。\n场景复现 我的证书是从OHTTPS上申请的，该网站提供的证书是 PEM 格式，同时提供了文件 cert.key - 私钥文件、cert.cer - 证书文件、fullchain.cer - 证书文件(包含证书和中间证书)。\n我的使用场景是 EwoMail 开源版邮件服务器。官网的要求是：\n默认使用本地证书,IMAP,SMTP,POP,WEB 访问都是通用一个文件\n使用互联网经过认证的证书，将你申请生成的 nginx 证书替换以下 2 个文件\n公匙 /etc/ssl/certs/dovecot.pem\n私匙 /etc/ssl/private/dovecot.pem\n所以我理所应当地就把 cert.cer 文件中内容复制到了 /etc/ssl/certs/dovecot.pem 中，把 cert.key 文件中的内容复制到了 /etc/ssl/private/dovecot.pem 中，但执行时总是报下面的这个错误：\nSep 17 21:54:30 VM-4-3-centos nginx[15958]: nginx: [emerg] cannot load certificate \u0026ldquo;/etc/ssl/certs/\u0026gt; dovecot.pem\u0026rdquo;: PEM_read_bio_X509_AUX() failed (SSL: error:0906D06C:PEM routines:PEM_read_bio:no start \u0026gt; line:Expecting: TRUSTED CERTIFICATE)\nSep 17 21:54:30 VM-4-3-centos nginx[15958]: nginx: configuration file /ewomail/nginx/conf/nginx.conf test failed\nSep 17 21:54:30 VM-4-3-centos systemd[1]: nginx.service: control process exited, code=exited status=1\nSep 17 21:54:30 VM-4-3-centos systemd[1]: Failed to start The NGINX HTTP and reverse proxy server.\nSep 17 21:54:30 VM-4-3-centos systemd[1]: Unit nginx.service entered failed state.\nSep 17 21:54:30 VM-4-3-centos systemd[1]: nginx.service failed.\n我能咋办，当然是去 愉快 地 Google 去喽，从 SSL 证书格式到 SSL 证书标准，从 SSL 官网的 Configure 到 NGINX 和 dovecot 的配置，在找了几个小时并逐渐崩溃后，在 StackOverflow 看到了这个问题 nginx SSL no start line: expecting: TRUSTED CERTIFICATE，提问的回复里有下面这句话：\nIt is expecting BEGIN TRUSTED CERTIFICATE instead of BEGIN CERTIFICATE and same for the end. The filename and extension are irelevant (you can name it foobar.42 and it will work the same way) only the content of the file is important.\n死马当活马医，我把 BEGIN CERTIFICATE 换成了 BEGIN TRUSTED CERTIFICATE，END CERTIFICATE 换成了END TRUSTED CERTIFICATE，一运行，成了！！！\n问题发现 证书由一个“证书颁发机构”通过一个或多个中间人签署。这将建立一个直到根证书的信任链，其中颁发者等于主体，该证书对自身进行签名。\n上文中的证书某种情况下是一个“自签名”证书，在技术上与 CA 证书没有区别，除了默认情况下没有系统（包括您自己的系统）会在没有特定配置的情况下信任此类证书。\n这基本上说明：应用程序说它正在根据您的配置加载一个无法验证的证书（因为它是自签名的），同时没有明确地将其配置为信任它。\n所以加上这个 TRUSTED 就等同于通知使用这个证书的程序这个证书是可信的。在 openssl 程序中有这样一个参数 -clrtrust , 它就是证书中有无 TRUSTED 的说明。可以通过 openssl x509 -in trusted.pem -clrtrust -out normal.pem 来将未取信的证书转换成取信的证书。\n","date":"2021-09-17T15:37:09Z","image":"https://static.aecra.cn/cover/remember-a-bug-in-use-ssl-certificates.jpg","permalink":"https://aecra.github.io/article/remember-a-bug-in-use-ssl-certificates/","title":"记 SSL 证书使用一大坑"},{"content":"docker 镜像是什么？ Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。\n分层存储 因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。\n使用 commit 创建镜像 容器是通过镜像创建的，因为镜像是分层存储的文件系统，因此容器实际上是通过在容器中新加入一个存储层来实现容器的文件使用的。\n由此可以看出，我们在容器中进行的文件修改实际上保存在新增加的存储层中，所以我们可以使用 commit 来将容器定制成一个镜像。\ndocker commit 的语法格式为：\ndocker commit [选项] \u0026lt;容器ID或容器名\u0026gt; [\u0026lt;仓库名\u0026gt;[:\u0026lt;标签\u0026gt;]] 但实际中我们应该避免使用该方法创建镜像，因为多层的文件结构使得我们在容器新创建的存储层中对前面层内的文件修改并不会直接作用于前面的层中，而是保存在当前层中，如果我们删除了部分文件，该文件并不会在我们的层中消失，而是被标记为删除，此行为会使文件系统愈发臃肿。\n另一方面，我们在用镜像的时候总是希望知道该镜像的每一层进行了何种修改，而在 commit 的方法中，修改是不可见的，这对于实际使用和维护是非常不利的，最终会导致该镜像成为垃圾镜像。\n使用 Dockerfile 创建镜像 Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\nDockerfile 例子：\nFROM nginx RUN echo \u0026#39;\u0026lt;h1\u0026gt;Hello, Docker!\u0026lt;/h1\u0026gt;\u0026#39; \u0026gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。\ndocker build 命令使用：\ndocker build [选项] \u0026lt;上下文路径/URL/-\u0026gt; 例如 docker build -t nginx:v3 . 意思是在当前目录下创建名字为 nginx 标签为 v3 的镜像。\nFROM ：指令基础镜像 可以使用各种官方提供的镜像，同时scratch是一个空白镜像，意味着你不以任何镜像为基础，不需要有操作系统提供运行时支持，Go 语言常见。\nRUN ：执行命令 shell 格式：RUN \u0026lt;命令\u0026gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。\nexec 格式：RUN [\u0026quot;可执行文件\u0026quot;, \u0026quot;参数1\u0026quot;, \u0026quot;参数2\u0026quot;]，这更像是函数调用中的格式。\nCOPY：复制文件 COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;源路径\u0026gt;... \u0026lt;目标路径\u0026gt; COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;源路径1\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;目标路径\u0026gt;\u0026#34;] ADD：更高级的文件 源路径可以是 url，但权限默认为 600，不推荐使用。\n源路径若为 tar 压缩包，ADD 命令会自动解压压缩文件到目标路径，而只有在这种情况下才推荐使用，其他情况推荐使用 COPY。\nCMD：容器启动命令 shell 格式：CMD \u0026lt;命令\u0026gt; exec 格式：CMD [\u0026#34;可执行文件\u0026#34;, \u0026#34;参数1\u0026#34;, \u0026#34;参数2\u0026#34;...] 容器无前台后台之分，容器就是为主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。\n所以容器启动命令应当是前台形式运行而不是启动服务等类型。\nENTRYPOINT：入口点 分为 exec 格式和 shell 格式，用于让镜像变成像命令一样使用和应用运行前的准备工作。\nENV：设置环境变量 ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;... ARG:构建参数 格式：ARG \u0026lt;参数名\u0026gt;[=\u0026lt;默认值\u0026gt;] ，与 ENV 不同之处在于，在将来容器运行时是不会存在这些环境变量的。\nARG 指令有生效范围，如果在 FROM 指令之前指定，那么只能用于 FROM 指令中。\nVOLUME：定义匿名卷 VOLUME [\u0026#34;\u0026lt;路径1\u0026gt;\u0026#34;, \u0026#34;\u0026lt;路径2\u0026gt;\u0026#34;...] VOLUME \u0026lt;路径\u0026gt; 对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。\nEXPOSE：暴露端口 格式为 EXPOSE \u0026lt;端口1\u0026gt; [\u0026lt;端口2\u0026gt;...]。\n声明容器运行时提供服务的端口，并不会在容器运行时开启端口服务，在 -P 选项时会随即映射该端口。\nWORKDIR：指定工作目录 格式为 WORKDIR \u0026lt;工作目录路径\u0026gt;。\n使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。\nUSER：指定当前用户 格式：USER \u0026lt;用户名\u0026gt;[:\u0026lt;用户组\u0026gt;]\nUSER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。\nHEALTHCHECK：健康检查 HEALTHCHECK [选项] CMD \u0026lt;命令\u0026gt;：设置检查容器健康状况的命令\nHEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\nHEALTHCHECK 支持下列选项：\n--interval=\u0026lt;间隔\u0026gt;：两次健康检查的间隔，默认为 30 秒； --timeout=\u0026lt;时长\u0026gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； --retries=\u0026lt;次数\u0026gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 ONBUILD：为他人作嫁衣裳 格式：ONBUILD \u0026lt;其它指令\u0026gt;。\nONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。\nLABEL：为镜像添加元数据 LABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata）。\nLABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... SHELL：指令 格式：SHELL [\u0026quot;executable\u0026quot;, \u0026quot;parameters\u0026quot;]。\nSHELL 指令可以指定 RUN ENTRYPOINT CMD 指令的 shell，Linux 中默认为 [\u0026quot;/bin/sh\u0026quot;, \u0026quot;-c\u0026quot;]\n","date":"2021-07-04T10:23:09Z","image":"https://static.aecra.cn/cover/create-docker-image.jpg","permalink":"https://aecra.github.io/article/create-docker-image/","title":"docker 镜像的创建"},{"content":"简介 Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。\n快速入门 安装 nginx\nsudo apt-get install nginx 卸载 nginx\nsudo apt-get uninstall nginx 启动 nginx\nnginx 停止 nginx\nnginx -s stop 热重启 nginx\nnginx -s reload CentOS 中安装 安装编译工具及库文件 yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装 下载 PCRE PCRE 作用是让 Nginx 支持 Rewrite 功能。\n这里有两个非常容易出问题的地方，第一个是安装 PCRE 的版本，在 PCRE 官网中我们得知 PCRE2 在 2015 年已经发布了，按照软件更新的规律，现在 NGINX 应该可以支持 PCRE2，但经过实际安装试错发现它并没有支持 PCRE2，在 StackOverflow 上更是说需要用 PCRE。\n第二个问题是在编译 NGINX 时的编译参数问题，--with-pcre 和 --with-pcre= 都加上肯定没问题，问题出在 --with-pcre= 的目录上，正如这一小节标题所说，正常安装 PCRE 并将库文件目录指定给 NGINX 是不行的，在同时指定 openssl 和 pcre 时，必须指定这两个项目的源码，因为 openssl 系统已经有了，所以我们需要指定 pcre 的源码，在其不再支持第一版后，最终版本就是 8.45。\n下载 PCRE 源文件，下载地址。\n再把文件传到服务器上。\n解压代码包。\nunzip pcre-8.45.zip 安装 Nginx 下载 Nginx，下载地址 。\ncd /usr/local/src/ wget https://nginx.org/download/nginx-1.20.1.tar.gz 解压安装包\ntar zxvf nginx-1.20.1.tar.gz 编译安装\n# 添加用户和组 groupadd www useradd -g www www # 进入安装目录 cd nginx-1.20.1/ # 配置 ./configure \\ --user=www \\ --group=www \\ --prefix=/usr/local/nginx \\ --with-stream \\ --with-stream_ssl_preread_module \\ --with-http_ssl_module \\ --with-http_stub_status_module \\ --with-http_realip_module \\ --with-http_dav_module \\ --with-http_gzip_static_module \\ --with-http_v2_module \\ --with-pcre \\ --with-pcre=/usr/local/src/pcre-8.45 # 编译并安装 make \u0026amp;\u0026amp; make install 修改配置 设置开机自启动 在系统服务目录里创建 nginx.service 文件\nvi /usr/lib/systemd/system/nginx.service 写入内容如下\n[Unit] Description=nginx After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s quit PrivateTmp=true [Install] WantedBy=multi-user.target [Unit]: 服务的说明\nDescription: 描述服务\nAfter: 描述服务类别\n[Service]: 服务运行参数的设置\nType=forking: 是后台运行的形式\nExecStart 为服务的具体运行命令\nExecReload 为重启命令\nExecStop 为停止命令\nPrivateTmp=True 表示给服务分配独立的临时空间\n注意：[Service] 的启动、重启、停止命令全部要求使用绝对路径\n[Install] 运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为 3\n设置开机自启动\nsystemctl enable nginx.service 该步骤之后需要重启服务器才能成功配置。\n常用目录 (in docker) /etc/nginx/nginx.conf nginx 配置文件路径 /usr/share/nginx/html nginx 服务器默认的根目录 /var/log/nginx nginx 服务器默认的日志目录 配置文件结构 ... #全局块 events { #events块 ... } http #http块 { ... #http全局块 server #server块 { ... #server全局块 location [PATTERN] #location块 { ... } location [PATTERN] { ... } } server { ... } ... #http全局块 } 全局块：配置影响 nginx 全局的指令。一般有运行 nginx 服务器的用户组，nginx 进程 pid 存放路径，日志存放路径，配置文件引入，允许生成 worker process 数等。 events 块：配置影响 nginx 服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网络连接，开启多个网络连接序列化等。 http 块：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type 定义，日志自定义，是否使用 sendfile 传输文件，连接超时时间，单连接请求数等。 server 块：配置虚拟主机的相关参数，一个 http 中可以有多个 server。 location 块：配置请求的路由，以及各种页面的处理情况。 官方文档： 连接\n","date":"2021-07-03T08:50:45Z","image":"https://static.aecra.cn/cover/nginx-getting-started-guide.png","permalink":"https://aecra.github.io/article/nginx-getting-started-guide/","title":"NGINX 入门指导"},{"content":"暴力算法低效在哪？ 字符串匹配如果使用暴力写法的话，我们需要不断移动匹配字符串的位置，同时一一对比此时字符串是否相同。这个过程中有没有浪费时间呢？答案是肯定的。\n首先我们需要知道，对于每次匹配时，我们已经知道出现未匹配字符串之前的各个字符的内容了，我们能不能考虑利用我们已匹配的的字符来优化我们的匹配流程呢？\n首先，我们先了解前缀后缀这两个概念。对于 abc 来说，前缀是 ['a', 'ab'] ，后缀是 ['c', 'bc'] 。那这个怎么用呢？\nnext 数组 next 数组保存了匹配字符串的前 n 个字符组成的字符串的最长相同前缀和后缀的长度。\n使用方法：我们下次移动不再 1 个步长地移动了，我们移动 x 个步长，x 怎么算呢？\n移动步长 x = 已匹配的字符数 - 对应的 next 值\n例如：BBCXABCDABVABCYUIYNDUYV 匹配 ABCDABD ，当前匹配字符串在下标为 4 的位置，同时此时 next 数组为 [0, 0, 0, 0, 1, 2, 0] ，我们当前移动步长应为 6-2，即 4 位。也就是说将匹配字符串移动到已匹配字符前缀后缀相同的最前的位置，而且我们还可以直接从未成功匹配的位置开始匹配。此时即可实现利用已匹配字符。\n好了，我们已经知道 KMP 算法的精髓是 next 数组，那么我们怎么求 next 数组呢？\n转换一下思维，既然是求前缀后缀相同的最大长度，我们可以用匹配字符串和自己比较（当然从 0 开始是没有意义的）。我们用 s1 来匹配 s2，移动 s1 来匹配不同下标开始的 s2，在某一个下标下匹配时，都有一个 s1 的移动指针 m，当前 m 位置匹配时，s2 的 next 的值就是它前一位置的 next 值加一，即当前匹配长度，如果当前 m 位置不匹配怎么办呢？我们可以看到已匹配的 s1 子串在 s2 中已经求出了 next 的值，因此我们可以直接移动 s1 到已匹配字串的后缀和前缀相同的位置继续求 next 的值。\n代码 class Solution { private: vector\u0026lt;int\u0026gt; preprocess(string\u0026amp; s) { vector\u0026lt;int\u0026gt; kmp(s.length()); int i = 1, m = 0; kmp[0] = 0; while (i \u0026lt; s.length()) { if (s[i] == s[m]) { kmp[i++] = ++m; } else if (m \u0026gt; 0) { m = kmp[m - 1]; } else { kmp[i++] = 0; } } return kmp; } public: int strStr(string haystack, string needle) { if (needle.length() == 0) return 0; vector\u0026lt;int\u0026gt; kmp = preprocess(needle); for (int i = 0, j = 0; i \u0026lt; haystack.length();) { if (needle[j] == haystack[i]) { ++i; ++j; } if (j == needle.length()) return i - j; if (i \u0026lt; haystack.length() \u0026amp;\u0026amp; needle[j] != haystack[i]) { if (j \u0026gt; 0) j = kmp[j - 1]; else ++i; } } return -1; } }; ","date":"2021-05-24T19:41:22Z","image":"https://static.aecra.cn/cover/kmp-string-matching-algorithm.jpg","permalink":"https://aecra.github.io/article/kmp-string-matching-algorithm/","title":"KMP 字符串匹配算法"},{"content":"http 介绍 概述 HTTP 是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的 Web 文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。\n客户端和服务端通过交换各自的消息（与数据流正好相反）进行交互。由像浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫做 responses。\nHTTP 被设计于 20 世纪 90 年代初期，是一种可扩展的协议。它是应用层的协议，通过TCP，或者是TLS－加密的 TCP 连接来发送，理论上任何可靠的传输协议都可以使用。因为其良好的扩展性，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如 HTML 表单这样的信息。HTTP 还可以根据网页需求，仅获取部分 Web 文档内容更新网页。\n详细内容见 HTTP 概述\nHTTP 请求方法 HTTP 定义了一组请求方法, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为 HTTP 动词. 每一个请求方法都实现了不同的语义, 但一些共同的特征由一组共享：: 例如一个请求方法可以是 safe, idempotent, 或 cacheable.\nHTTP 请求头 HTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。\n常用请求头：Accept 、Access-Control-Allow-Origin 、Connection 、Content-Length 、Content-Type 、Cookie 、Host 、Origin 、User-Agent 。\nHTTP 请求体 http 请求体通常用于 POST 请求中，包括但不限于提交表单等操作。\n格式为在请求头之后空一行填写，例如：\nPOST /test HTTP/1.1 Host: foo.example Content-Type: application/x-www-form-urlencoded Content-Length: 27 field1=value1\u0026amp;field2=value2 HTTP 响应代码 HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)。状态代码由 section 10 of RFC 2616定义。\n详见：HTTP 响应代码\nXHR 的理解和使用 MDN 文档 链接\n理解 使用 XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送 ajax 请求。 前端可以获取到数据，而无需让整个的页面刷新。 这使得 Web 页面可以只更新页面的局部，而不影响用户的操作。 xhr 和 fetch 都是 JavaScript 的底层 API，互不相关。 区别一般 http 请求与 ajax 请求 ajax 请求是一种特别的 http 请求。\n对服务器端来说，没有任何区别，区别在浏览器端。\n浏览器端发请求：只有 XHR 或 fetch 发出的才是 ajax 请求，其它所有的都是 非 ajax 请求。\n浏览器端接收到响应\n(1) 一般请求：浏览器一般会直接显示响应体数据，也就是我们常说的刷新 / 跳转页面。\n(2) ajax 请求：浏览器不会对界面进行任何更新操作，只是调用监视的回调 函数并传入响应相关数据。\nAPI 构造函数 XMLHttpRequest()\n该构造函数用于初始化一个 XMLHttpRequest 实例对象。在调用下列任何其他方法之前，必须先调用该构造函数，或通过其他方式，得到一个实例对象。\n属性 此接口继承了 XMLHttpRequestEventTarget 和 EventTarget 的属性。\nXMLHttpRequest.onreadystatechange\n当 readyState 属性发生变化时，调用的 EventHandler (en-US)。\nXMLHttpRequest.readyState 只读\n返回 一个无符号短整型（unsigned short）数字，代表请求的状态码。\nXMLHttpRequest.response 只读\n返回一个 ArrayBuffer、Blob、Document，或 DOMString，具体是哪种类型取决于 XMLHttpRequest.responseType 的值。其中包含整个响应实体（response entity body）。\nXMLHttpRequest.responseText 只读\n返回一个 DOMString，该 DOMString 包含对请求的响应，如果请求未成功或尚未发送，则返回 null。\nXMLHttpRequest.responseType\n一个用于定义响应类型的枚举值（enumerated value）。\nXMLHttpRequest.responseURL 只读\n返回经过序列化（serialized）的响应 URL，如果该 URL 为空，则返回空字符串。\nXMLHttpRequest.responseXML 只读\n返回一个 Document，其中包含该请求的响应，如果请求未成功、尚未发送或时不能被解析为 XML 或 HTML，则返回 null。\nXMLHttpRequest.status 只读\n返回一个无符号短整型（unsigned short）数字，代表请求的响应状态。\nXMLHttpRequest.statusText 只读\n返回一个 DOMString，其中包含 HTTP 服务器返回的响应状态。与 XMLHTTPRequest.status 不同的是，它包含完整的响应状态文本（例如，\u0026ldquo;200 OK\u0026rdquo;）。\n注意：根据 HTTP/2 规范（8.1.2.4 Response Pseudo-Header Fields，响应伪标头字段），HTTP/2 没有定义任何用于携带 HTTP/1.1 状态行中包含的版本（version）或者原因短语（reason phrase）的方法。\nXMLHttpRequest.timeout\n一个无符号长整型（unsigned long）数字，表示该请求的最大请求时间（毫秒），若超出该时间，请求会自动终止。\nXMLHttpRequestEventTarget.ontimeout\n当请求超时调用的 EventHandler。\nXMLHttpRequest.upload 只读\nXMLHttpRequestUpload，代表上传进度。\nXMLHttpRequest.withCredentials\n一个布尔值，用来指定跨域 Access-Control 请求是否应当带有授权信息，如 cookie 或授权 header 头。\n非标准属性\n事件处理器 作为 XMLHttpRequest 实例的属性之一，所有浏览器都支持 onreadystatechange。\n后来，许多浏览器实现了一些额外的事件（onload、onerror、onprogress 等）。\n更多现代浏览器，包括 Firefox，除了可以设置 on* 属性外，也提供标准的监听器 addEventListener() API 来监听 XMLHttpRequest 事件。\n方法 XMLHttpRequest.abort()\n如果请求已被发出，则立刻中止请求。\nXMLHttpRequest.getAllResponseHeaders()\n以字符串的形式返回所有用 CRLF 分隔的响应头，如果没有收到响应，则返回 null。\nXMLHttpRequest.getResponseHeader()\n返回包含指定响应头的字符串，如果响应尚未收到或响应中不存在该报头，则返回 null。\nXMLHttpRequest.open()\n初始化一个请求。该方法只能在 JavaScript 代码中使用，若要在 native code 中初始化请求，请使用 openRequest()。\nXMLHttpRequest.overrideMimeType()\n覆写由服务器返回的 MIME 类型。\nXMLHttpRequest.send()\n发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。\nXMLHttpRequest.setRequestHeader() 设置 HTTP 请求头的值。必须在 open() 之后、send() 之前调用 setRequestHeader() 方法。\n事件 abort\n当 request 被停止时触发，例如当程序调用 XMLHttpRequest.abort() 时。\nerror\n当 request 遭遇错误时触发。\nload\nXMLHttpRequest 请求成功完成时触发。\nloadend\n当请求结束时触发, 无论请求成功 ( load) 还是失败 (abort 或 error)。\nloadstart\n接收到响应数据时触发。\nprogress\n当请求接收到更多数据时，周期性地触发。\ntimeout\n在预设时间内没有接收到响应时触发。\nXHR 的 Ajax 封装（简单版 axios） /** * 1.函数的返回值为promise, 成功的结果为response, 失败的结果为error * 2.能处理多种类型的请求: GET/POST/PUT/DELETE * 3.函数的参数为一个配置对象 * { * url: \u0026#39;\u0026#39;, // 请求地址 * method: \u0026#39;\u0026#39;, // 请求方式GET/POST/PUT/DELETE * params: {}, // GET/DELETE请求的query参数 * data: {}, // POST或DELETE请求的请求体参数 * } * 4.响应json数据自动解析为js的对象/数组 **/ function axios({ url, method = \u0026#39;GET\u0026#39;, params = {}, data = {} }) { // 返回一个promise对象 return new Promise((resolve, reject) =\u0026gt; { // 处理method(转大写) method = method.toUpperCase(); // 处理query参数(拼接到url上) id=1\u0026amp;xxx=abc let queryString = \u0026#39;\u0026#39;; Object.entries(params).forEach((item) =\u0026gt; { queryString += `${item[0]}=${item[1]}\u0026amp;`; }); // 拼接url url += queryString === \u0026#39;\u0026#39; ? queryString.substring(0, queryString.length - 1) : \u0026#39;\u0026#39;; // 1. 执行异步ajax请求 // 创建xhr对象 const request = new XMLHttpRequest(); // 打开连接(初始化请求, 没有发送请求) request.open(method, url, true); // 发送请求 if (method === \u0026#39;GET\u0026#39; || method === \u0026#39;DELETE\u0026#39;) { request.send(); } else if (method === \u0026#39;POST\u0026#39; || method === \u0026#39;PUT\u0026#39;) { request.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json;charset=utf-8\u0026#39;); // 告诉服务器请求体的格式是json request.send(JSON.stringify(data)); // 发送json格式请求体参数 } // 绑定状态改变的监听 request.onreadystatechange = function () { // 如果请求没有完成, 直接结束 if (request.readyState !== 4) { return; } // 如果响应状态码在[200, 300)之间代表成功, 否则失败 const { status, statusText } = request; // 2.1. 如果请求成功了, 调用resolve() if (status \u0026gt;= 200 \u0026amp;\u0026amp; status \u0026lt;= 299) { // 准备结果数据对象response const response = { data: JSON.parse(request.response), status, statusText, }; resolve(response); } else { // 2.2. 如果请求失败了, 调用reject() reject(new Error(\u0026#39;request error status is \u0026#39; + status)); } }; }); } axios 的理解和使用 axios 是什么 前端最流行的 ajax 请求库 react/vue 官方都推荐使用 axios 发 ajax 请求 开源地址 .axios 特点 基本 promise 的异步 ajax 请求库 浏览器端/node 端都可以使用 支持请求／响应拦截器 支持请求取消 请求/响应数据转换 批量发送多个请求 axios 常用语法 axios(config): 通用/最本质的发任意类型请求的方式\naxios(url[, config]): 可以只指定 url 发 get 请求\naxios.request(config): 等同于 axios(config)\naxios.get(url[, config]): 发 get 请求\naxios.delete(url[, config]): 发 delete 请求\naxios.post(url[, data, config]): 发 post 请求\naxios.put(url[, data, config]): 发 put 请求\naxios.defaults.xxx: 请求的默认全局配置\naxios.interceptors.request.use(): 添加请求拦截器\naxios.interceptors.response.use(): 添加响应拦截器\naxios.create([config]): 创建一个新的 axios(它没有下面的功能)\naxios.Cancel(): 用于创建取消请求的错误对象\naxios.CancelToken(): 用于创建取消请求的 token 对象\naxios.isCancel(): 是否是一个取消请求的错误\naxios.all(promises): 用于批量执行多个异步请求\n难点语法的理解和使用 axios.create(config) 根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置\n新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的\n为什么要设计这个语法?\n(1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一 样, 如何处理\n(2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中\n拦截器函数/ajax 请求/请求的回调函数的调用顺序 说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 流程: 请求拦截器 2 =\u0026gt; 请求拦截器 1 =\u0026gt; 发 ajax 请求 =\u0026gt; 响应拦截器 1 =\u0026gt; 响应拦截器 2 =\u0026gt; 请求的回调 注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应拦截器传递的是 response 取消请求 基本流程\n配置 cancelToken 对象\n缓存用于取消请求的 cancel 函数\n在后面特定时机调用 cancel 函数取消请求\n在错误回调中判断如果 error 是 cancel, 做相应处理\n实现功能\n点击按钮, 取消某个正在请求中的请求；在请求一个接口前, 取消前面一个未完成的请求\naxios 源码分析 axios 与 Axios 的关系? 从语法上来说: axios 不是 Axios 的实例 从功能上来说: axios 是 Axios 的实例 axios 是 Axios.prototype.request 函数 bind()返回的函数 axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios instance 与 axios 的区别? 相同:\n(1) 都是一个能发任意请求的函数: request(config)\n(2) 都有发特定请求的各种方法: get()/post()/put()/delete()\n(3) 都有默认配置和拦截器的属性: defaults/interceptors\n不同:\n(1) 默认匹配的值很可能不一样\n(2) instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all()\naxios 运行的整体流程 整体流程:\nrequest(config) ==\u0026gt; dispatchRequest(config) ==\u0026gt; xhrAdapter(config)\nrequest(config):\n将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来, 返回 promise\ndispatchRequest(config):\n转换请求数据 ==\u0026gt; 调用 xhrAdapter()发请求 ==\u0026gt; 请求返回后转换响应数据。返回 promis\nxhrAdapter(config):\n创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据, 返回 promise\naxios 的请求/响应拦截器是什么? 请求拦截器:\n在真正发送请求前执行的回调函数\n可以对请求进行检查或配置进行特定处理\n成功的回调函数, 传递的默认是 config(也必须是)\n失败的回调函数, 传递的默认是 error\n响应拦截器\n在请求得到响应后执行的回调函数\n可以对响应数据进行特定处理\n成功的回调函数, 传递的默认是 response\n失败的回调函数, 传递的默认是 erro\naxios 的请求/响应数据转换器是什么? 请求转换器: 对请求头和请求体数据进行特定处理的函数\nif (utils.isObject(data)) { setContentTypeIfUnset(headers, \u0026#39;application/json;charset=utf-8\u0026#39;); return JSON.stringify(data); } 响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数\nresponse.data = JSON.parse(response.data); response 的整体结构 { data, status, statusText, headers, config, request, } error 的整体结构 { message, response, request, } 如何取消未完成的请求? 当配置了 cancelToken 对象时, 保存 cancel 函数\n(1) 创建一个用于将来中断请求的 Promise 对象： cancelPromise\n(2) 并定义了一个用于取消请求的 resolved 函数： cancel\n(3) 将 cancel 函数传递出来\n调用 cancel()取消请求\n(1) 执行 cacel 函数, 传入错误信息 message\n(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象\n(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败, 失败的 reason 为 Cacel 对象\n","date":"2021-04-17T00:26:25Z","image":"https://static.aecra.cn/cover/introduction-to-axios-and-source-code-analysis.jpg","permalink":"https://aecra.github.io/article/introduction-to-axios-and-source-code-analysis/","title":"axios 入门和源码分析"},{"content":"webpack 简介 webpack 是什么 webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/\u0026hellip;)都会作为模块处理。 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。\nwebpack 五个核心概念 Entry\n入口(Entry)指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。\nOutput\n输出(Output)指示 webpack 打包后的资源 budles 输出到哪里去，以及如何命名。\nLoader\nLoader 让 webpack 能够去处理那些非 JavaScript 文件(webpack 自身只理解 JavaScript)。\nPlugins\n插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 一直到重新定义环境中的变量等。\nMode\n模式(Mode)指示 webpack 使用相应模式的配置。\n选项 描述 特点 development 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 能让代码本地调试 运行的环境 production 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置 为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin 能让代码优化上线 运行的环境 webpack 的简易使用 初始化配置 初始化 package.json\nnpm init 下载并安装 webpack\n// 全局安装 npm install webpack webpack-cli -g // 安装到开发环境 npm install webpack webpack-cli -D 编译打包应用 创建文件\n运行指令\n// 开发环境 webpack src/js/index.js -o build/js/built.js --mode=development 功能：webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成 浏览器能识别的语法。\n// 生产环境 webpack src/js/index.js -o build/js/built.js --mode=production 功能：在开发配置功能上多一个功能，压缩代码。\n效果\nwebpack 能够编译打包 js 和 json 文件。 能将 es6 的模块化语法转换成浏览器能识别的语法。 能压缩代码。\n问题\n不能编译打包 css、img 等文件。 不能将 js 的 es6 基本语法转化为 es5 以下语法。\nwebpack 开发环境的基本配置 创建配置文件 创建文件 webpack.config.js\n配置内容如下\n// resolve用来拼接绝对路径的方法 const { resolve } = require(\u0026#39;path\u0026#39;); module.exports = { // 入口起点 entry: \u0026#39;./src/index.js\u0026#39;, // 输出 output: { // 输出文件名 filename: \u0026#39;built.js\u0026#39;, // 输出路径 path: resolve(__dirname, \u0026#39;build\u0026#39;), }, // 模式 mode: \u0026#39;development\u0026#39;, // 开发模式 // mode: \u0026#39;production\u0026#39; }; 运行指令: webpack\n打包样式资源 创建 less 文件\n下载安装 loader 包\nnpm install css-loader style-loader less-loader --save-dev 修改配置文件\n// resolve用来拼接绝对路径的方法 const { resolve } = require(\u0026#39;path\u0026#39;); module.exports = { // 入口起点 entry: \u0026#39;./src/index.js\u0026#39;, // 输出 output: { // 输出文件名 filename: \u0026#39;built.js\u0026#39;, // 输出路径 // __dirname nodejs的变量，代表当前文件的目录绝对路径 path: resolve(__dirname, \u0026#39;build\u0026#39;), }, // loader的配置 module: { rules: [ // 详细loader配置 // 不同文件必须配置不同loader处理 { // 匹配哪些文件 test: /\\.css$/, // 使用哪些loader进行处理 use: [ // use数组中loader执行顺序：从右到左，从下到上 依次执行 // 创建style标签，将js中的样式资源插入进行，添加到head中生效 \u0026#39;style-loader\u0026#39;, // 将css文件变成commonjs模块加载js中，里面内容是样式字符串 \u0026#39;css-loader\u0026#39;, ], }, { test: /\\.less$/, use: [ \u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, // 将less文件编译成css文件 // 需要下载 less-loader和less \u0026#39;less-loader\u0026#39;, ], }, ], }, // plugins的配置 plugins: [ // 详细plugins的配置 ], // 模式 mode: \u0026#39;development\u0026#39;, // 开发模式 // mode: \u0026#39;production\u0026#39; }; 运行指令: webpack\n打包 HTML 资源 创建 HTML 文件\n下载安装 plugin 包\nnpm install --save-dev html-webpack-plugin 修改配置文件，html-webpack-plugin 的详细配置见 Github\nconst { resolve } = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#39;built.js\u0026#39;, path: resolve(__dirname, \u0026#39;build\u0026#39;), }, module: { rules: [ // loader的配置 ], }, plugins: [ // plugins的配置 // html-webpack-plugin // 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS） // 需求：需要有结构的HTML文件 new HtmlWebpackPlugin({ // 复制 \u0026#39;./src/index.html\u0026#39; 文件，并自动引入打包输出的所有资源（JS/CSS） template: \u0026#39;./src/index.html\u0026#39;, }), ], mode: \u0026#39;development\u0026#39;, }; 运行指令: webpack\n打包图片资源 创建图片文件\n下载安装 loader 包，在 webpack5 中，增加了资源模块用来处理资源文件而无需加载 loader，下载的 html-loader 只是将图片 require 到 js 目录以进行打包。\nnpm install --save-dev html-loader 修改配置文件，其中\nconst { resolve } = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#39;built.js\u0026#39;, path: resolve(__dirname, \u0026#39;build\u0026#39;), }, module: { rules: [ // css-loader 会对 @import 和 url() 进行处理（导入） { test: /\\.less$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;], }, // 将HTML中的可加载属性导入到js进行打包 { test: /\\.html$/, loader: \u0026#39;html-loader\u0026#39;, }, // 处理import的图片路径问题，实际上使用 Asset Modules 可以接收并加载任何文件，然后将其输出到构建目录 { test: /\\.(png|svg|jpg|jpeg|gif)$/i, type: \u0026#39;asset\u0026#39;, // 自动地在 resource 和 inline 之间进行选择：小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型。 parser: { dataUrlCondition: { maxSize: 8 * 1024, // 8kb 是默认值 }, }, }, ], }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, }), ], mode: \u0026#39;development\u0026#39;, }; 打包其他资源 const { resolve } = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#39;built.js\u0026#39;, path: resolve(__dirname, \u0026#39;build\u0026#39;), }, module: { rules: [ { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;], }, // 打包其他资源(除了html/js/css资源以外的资源) { // 排除css/js/html资源 exclude: /\\.(css|js|html|less)$/, type: \u0026#39;asset\u0026#39;, // 自动地在 resource 和 inline 之间进行选择：小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型。 parser: { dataUrlCondition: { maxSize: 8 * 1024, // 8kb 是默认值 }, }, }, ], }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, }), ], mode: \u0026#39;development\u0026#39;, }; source map 当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。可以通过一定设置来追踪错误文件。在配置中加入如下属性：\ndevtool: \u0026#39;inline-source-map\u0026#39;, 开发工具 在每次编译代码时，手动运行 npm run build 会显得很麻烦。webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码：\nwebpack\u0026rsquo;s Watch Mode webpack-dev-server webpack-dev-middleware 但一般使用 webpack-dev-server，其具有 live reloading(实时重新加载) 功能，webpack-dev-middleware 是 webpack-dev-server 的中间件。配置如下：\ndevServer: { // 项目构建后路径 contentBase: resolve(__dirname, \u0026#39;build\u0026#39;), // 启动gzip压缩 compress: true, // 端口号 port: 3000, // 自动打开浏览器 open: true } 运行应使用webpack serve 而不是 webpack-dev-server，见issues。\n若要更改代码时浏览器自动刷新可做如下设置：\nmodule.exports = { target: \u0026#39;web\u0026#39;, }; webpack 生产环境的基本配置 生产环境下默认使用 TerserPlugin\n启用 source map 在生产环境中启用 source map，因为它们对 debug(调试源码) 和运行 benchmark tests(基准测试) 很有帮助。\ndevtool: \u0026#39;eval-source-map\u0026#39;, 提取所有的 CSS 到一个文件中 使用插件 mini-css-extract-plugin，同时将 Loader style-loader 换成 MiniCssExtractPlugin.loader\nconst MiniCssExtractPlugin = require(\u0026#34;mini-css-extract-plugin\u0026#34;); // \u0026#34;style-loader\u0026#34;换成如下配置，其中publicPath为当前文件处理后的公共路径 { loader: MiniCssExtractPlugin.loader, options: { publicPath: \u0026#34;../\u0026#34;, }, }, // 增加 mini-css-extract-plugin 插件 plugins: [ new MiniCssExtractPlugin({ filename: \u0026#39;[name].css\u0026#39;, }), ], css 兼容性处理 使用 postcss-loader 和 postcss-preset-env 两个 loader。\nnpm install --save-dev postcss-loader postcss postcss-preset-env 创建配置文件 postcss.config.js\nmodule.exports = { plugins: [ [ \u0026#39;postcss-preset-env\u0026#39;, { // 其他选项 }, ], ], }; webpack.config.js 中添加 postcss-loader\nmodule.exports = { module: { rules: [ { test: /\\.css$/i, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;postcss-loader\u0026#39;], }, ], }, }; 在 package.json 中增加如下配置\n{ \u0026#34;browserslist\u0026#34;: [\u0026#34;\u0026gt; 1%\u0026#34;, \u0026#34;not dead\u0026#34;, \u0026#34;not op_mini all\u0026#34;] } 压缩 css 使用插件 CssMinimizerWebpackPlugin，安装：\nnpm install css-minimizer-webpack-plugin --save-dev 接着在 webpack 配置中加入该插件，与此同时 html 也被压缩了（貌似是默认压缩？）。\noptimization: { minimize: true, minimizer: [ new CssMinimizerPlugin(), ], }, js 语法检查 Eslint 为了解决 eslint-loader 的问题，eslint-loader 被弃用，改用EslintWebpackPlugin插件。\n安装：\nnpm install eslint-webpack-plugin --save-dev // 需要用到 eslint npm install eslint --save-dev 使用 airbnb 的 js 语法检查设置\nnpm install eslint-config-airbnb-base eslint-plugin-import --save-dev 在 package.json 中添加配置\n{ \u0026#34;eslinkConfig\u0026#34;: { \u0026#34;extends\u0026#34;: \u0026#34;airbnb-base\u0026#34; } } 注意：可能有非常多的错误警告，建议搭配 vs code 插件 ESlint 做格式化使用。\n调试过程中会有 console 语句，可以在 console 语句前加入如下注释用来忽略对 console 的检查。\n// eslint-disable-next-line no-console console.log(\u0026#39;no-console\u0026#39;); js 兼容性处理 在之前使用 @babel/polyfill 来处理 js 兼容性问题，但 babel 官网显示已被弃用，建议直接用 core-js/stable 和 regenerator-runtime/runtime ：\n🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions):\nimport \u0026#39;core-js/stable\u0026#39;; import \u0026#39;regenerator-runtime/runtime\u0026#39;; 安装：\nnpm i --save core-js regenerator-runtime 在 js 中引入 core-js/stable 和 regenerator-runtime/runtime ：\nimport \u0026#39;core-js/stable\u0026#39;; import \u0026#39;regenerator-runtime/runtime\u0026#39;; 拓展\n@babel/preset-env 可以做到按需加载，具体见 链接，没看明白怎么用，暂时不做学习，同时 webpack 官网建议 “不加选择地和同步地加载所有 polyfill/shim，尽管这会导致额外的 bundle 体积成本。”，因为 pyolyfill 被弃用，所以我们要不加选择地加载core-js/stable 和 regenerator-runtime/runtime，因为有些浏览器并没有很好地支持 ECMAScript 的新特性。取舍问题建议查看 webpack 官网描述。\njs 压缩 官网有如下内容：\n如果你使用的是 webpack v5 或以上版本，你不需要安装这个插件。webpack v5 自带最新的 terser-webpack-plugin。如果使用 webpack v4，则必须安装 terser-webpack-plugin v4 的版本。\n生产环境下自动压缩，但通过以上的配置流程之后，我的 js 并没有被压缩，甚至还达到了 427kb 的大小，以至于报出错误警告说文件过大（限制 244kb），所以自行配置。\n添加到开发依赖项：\nnpm install terser-webpack-plugin --save-dev 配置 webpack.config.js ：\nconst TerserPlugin = require(\u0026#39;terser-webpack-plugin\u0026#39;); module.exports = { optimization: { minimize: true, minimizer: [new TerserPlugin()], }, }; 性能优化/功能提升 模块热替换(hot module replacement) 模块热替换(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。更多介绍见 模块热替换。\n设置方法：在 [开发工具](### 开发工具) 中添加如下设置：\nhot: true, 可以看到此时 css 和 js 都热更新了，但 html 并没有热更新，所以要修改 webpack 配置，在 entry 入口中添加上 html 文件。\nentry: [\u0026#39;./src/index.js\u0026#39;, \u0026#39;./src/index.html\u0026#39;], 但是，没那么简单，单页面的流行使得 html 不需要更改，因为都是 js 生成的虚拟 dom 树再添加到页面中的，而且 html 页面的变化使得所有其他的页面都要去变化，设置 html 热加载还不如不设置热加载。\n生产环境和开发环境配置分离 development(开发环境) 和 production(生产环境) 这两个环境下的构建目标存在着巨大差异。在开发环境中，我们需要：强大的 source map 和一个有着 live reloading(实时重新加载) 或 hot module replacement(热模块替换) 能力的 localhost server。而生产环境目标则转移至其他方面，关注点在于压缩 bundle、更轻量的 source map、资源优化等，通过这些优化方式改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。\n虽然，以上我们将 生产环境 和 开发环境 做了细微区分，但是，请注意，我们还是会遵循不重复原则(Don\u0026rsquo;t repeat yourself - DRY)，保留一个 \u0026ldquo;common(通用)\u0026rdquo; 配置。为了将这些配置合并在一起，我们将使用一个名为 webpack-merge 的工具。此工具会引用 \u0026ldquo;common\u0026rdquo; 配置，因此我们不必再在环境特定(environment-specific)的配置中编写重复代码。\n我们先从安装 webpack-merge 开始，并将之前指南中已经成型的那些代码进行分离：\nnpm install --save-dev webpack-merge webpack.dev.js const { merge } = require(\u0026#39;webpack-merge\u0026#39;); const common = require(\u0026#39;./webpack.common.js\u0026#39;); module.exports = merge(common, { mode: \u0026#39;development\u0026#39;, devtool: \u0026#39;inline-source-map\u0026#39;, devServer: { contentBase: \u0026#39;./dist\u0026#39;, }, }); webpack.prod.js const { merge } = require(\u0026#39;webpack-merge\u0026#39;); const common = require(\u0026#39;./webpack.common.js\u0026#39;); module.exports = merge(common, { mode: \u0026#39;production\u0026#39;, }); package.json \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack --config webpack.prod.js\u0026#34;, \u0026#34;dev-build\u0026#34;: \u0026#34;webpack serve --open --config webpack.dev.js\u0026#34; }, eslint 检测依赖问题，在文件开头添加注释\n/* eslint-disable import/no-extraneous-dependencies */ source-map 详解 source-map: 一种提供源代码到构建后代码映射技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）。\n格式：[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map\nsource-map：外部\n错误代码准确信息 和 源代码的错误位置\ninline-source-map：内联\n只生成一个内联 source-map\n错误代码准确信息 和 源代码的错误位置\nhidden-source-map：外部\n错误代码错误原因，但是没有错误位置\n不能追踪源代码错误，只能提示到构建后代码的错误位置\neval-source-map：内联\n每一个文件都生成对应的 source-map，都在 eval\n错误代码准确信息 和 源代码的错误位置\nnosources-source-map：外部\n错误代码准确信息, 但是没有任何源代码信息\ncheap-source-map：外部\n错误代码准确信息 和 源代码的错误位置\n只能精确的行\ncheap-module-source-map：外部\n错误代码准确信息 和 源代码的错误位置\nmodule 会将 loader 的 source map 加入\n生产环境：eval-source-map / eval-cheap-module-souce-map\n开发环境：source-map / cheap-module-souce-map\noneOf 在前面我们设置了许多 loader 规则，但是过多的 loader 会使得打包速度变慢，所以我们需要一种规则使得打包的时候只进行一次匹配处理，这个规则就是 oneOf，配置方法如下：\nmodule: { rules: [ { oneOf: [ { test: /\\.css$/, use: [ \u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;postcss-loader\u0026#39;, ], }, { test: /\\.less$/, use: [ \u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;, \u0026#39;postcss-loader\u0026#39;, ], }, ], }, ], }, Tree Shaking 得益于 es6 模块的静态分析，可以在打包时直接去掉不适用的代码。\n条件：1. 必须使用 ES6 模块化 2. 开启 production 环境\n作用：减少代码体积\n在 package.json 中配置：\u0026quot;sideEffects\u0026quot;: false 表示所有代码都没有副作用（都可以进行 tree shaking）\n这样会导致的问题：可能会把 css / @babel/polyfill 文件干掉（副作用）\n所以可以配置：\u0026quot;sideEffects\u0026quot;: [\u0026quot;*.css\u0026quot;, \u0026quot;*.less\u0026quot;] 不会对 css/less 文件 tree shaking 处理。\n代码分割 多入口模式\n在设置中可以设置 entry 为一个对象，实现多入口，此时可以从但入口中去除掉其他入口的 import。\nentry: { index: \u0026#39;./src/js/index.js\u0026#39;, test: \u0026#39;./src/js/test.js\u0026#39; }, SplitChunksPlugin\n开箱即用的 SplitChunksPlugin 对于大部分用户来说非常友好。\n默认情况下，它只会影响到按需加载的 chunks，因为修改 initial chunks 会影响到项目的 HTML 文件中的脚本标签。\nmodule.exports = { //... optimization: { splitChunks: { // include all types of chunks chunks: \u0026#39;all\u0026#39;, }, }, }; 同时输出文件名需要添加上 [chunkhash:10] 此类字段，否则输出文件名相同而报错。\n因为默认最小文件为 20kb 所以可以使用 import 动态导入语法来使得引入的文件强制单独打包。\n更多配置可以参见官网描述。\n其他见 代码分离\n懒加载 懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。\n懒加载同时是上一小节“代码分离”的一部分，但因时常被单独提及，这里另加一小节。\n当涉及到动态代码拆分时，虽然提供了两种技术，但require.ensure 已经是不建议使用的了，所以我们用符合 ECMAScript 提案 的 import() 语法 来实现动态导入，因为返回的是 Promise，所以需要使用像 es6-promise 或者 promise-polyfill 这样 polyfill 库，来预先填充(shim) Promise 环境。更好的方法还是使用[js 兼容性处理](### js 兼容性处理) 的方案。\n示例：\nimport(\u0026#39;./test\u0026#39;).then(({ mul }) =\u0026gt; { console.log(mul(2, 5)); }); 可以使用 魔法注释 来设置文件名、加载方式、预获取/预加载模块\n渐进式网络应用程序 渐进式网络应用程序(progressive web application - PWA)，是一种可以提供类似于 native app(原生应用程序) 体验的 web app(网络应用程序)。\n添加 Workbox 添加 workbox-webpack-plugin 插件，然后调整配置文件\nnpm install workbox-webpack-plugin --save-dev const WorkboxPlugin = require(\u0026#39;workbox-webpack-plugin\u0026#39;); module.exports = { plugins: [ new WorkboxPlugin.GenerateSW({ // 这些选项帮助快速启用 ServiceWorkers // 不允许遗留任何“旧的” ServiceWorkers clientsClaim: true, skipWaiting: true, }), ], }; 注册 Service Worker index.js\nif (\u0026#39;serviceWorker\u0026#39; in navigator) { window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { navigator.serviceWorker .register(\u0026#39;./service-worker.js\u0026#39;) .then((registration) =\u0026gt; { // eslint-disable-next-line no-console console.log(\u0026#39;SW registered: \u0026#39;, registration); }) .catch((registrationError) =\u0026gt; { // eslint-disable-next-line no-console console.log(\u0026#39;SW registration failed: \u0026#39;, registrationError); }); }); } 多进程打包 需要安装 thread-loader 来对 babel 新开进程，从名字可以看出，这是一个 loader，可以添加到 use 中使得打包时新开进程，另外还可以设置进程数量来优化打包速度，需要注意的是，进程启动大概需要 600ms，进程通信需要消耗时间，所以加上该 loader 并不一定会有正向优化，应该视具体情况而定。\n{ loader: \u0026#39;thread-loader\u0026#39;, options: { workers: 2 // 设置进程数为2个 } } 外部扩展(externals) externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法。官网提供多种方法，以下介绍几个 web 常用的。\n方法 1：字符串 module.exports = { //... externals: { jquery: \u0026#39;jQuery\u0026#39;, }, }; 将 jquery 模块替换为全局变量 jQuery。\n方法 2：函数 function ({ context, request, contextInfo, getResolve }, callback) \u0026gt; function ({ context, request, contextInfo, getResolve }) =\u0026gt; promise 5.15.0+\n函数接收两个入参：\nctx (object)：包含文件详情的对象。\nctx.context (string): 包含引用的文件目录。\nctc.request (string): 被请求引入的路径。\nctx.contextInfo (string): 包含 issuer 的信息（如，layer）\nctx.getResolve 5.15.0+: 获取当前解析器选项的解析函数。\ncallback (function (err, result, type)): 用于指明模块如何被外部化的回调函数\n回调函数接收三个入参：\nerr (Error): 被用于表明在外部外引用的时候是否会产生错误。如果有错误，这将会是唯一被用到的参数。\nresult (string [string] object): 描述外部化的模块。可以接受形如 ${type} ${path} 格式的字符串，或者其它标准化外部化模块格式，(string, [string]，或 object)。\ntype (string): 可选的参数，用于指明模块的类型（如果它没在 result 参数中被指明）。\nexternals: [ function ({ request }, callback) { if (/^jquery$/.test(request)) { // 使用 request 路径，将一个 commonjs 模块外部化 return callback(null, \u0026#39;root jQuery\u0026#39;); } // 继续下一步且不外部化引用 callback(); }, ], 以上设置表明只对 /^jquery$/ 匹配的模块做处理，其中 callback 的参数含义为可以通过一个全局变量访问 library（例如，通过 script 标签）且全局变量为 jQuery。\n以上两种方法都需要在 index.html 中通过 cdn 引入：\n\u0026lt;script src=\u0026#39;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; DLL DllPlugin 和 DllReferencePlugin 用某种方法实现了拆分 bundles，同时还大幅度提升了构建的速度。\u0026ldquo;DLL\u0026rdquo; 一词代表微软最初引入的动态链接库。换句话说就是让某些库单独打包，后续再直接引入到 build 中。\n注意：DLL 拆分出来 bundles 是通过单独的配置文件来单独执行 webpack 打包这一过程实现的，不可与项目配置文件混淆。\nwebpack.dll.js 配置：(将 jquery 单独打包)\nconst { resolve } = require(\u0026#39;path\u0026#39;); const webpack = require(\u0026#39;webpack\u0026#39;); module.exports = { entry: { // 最终打包生成的[name] --\u0026gt; jquery // [\u0026#39;jquery] --\u0026gt; 要打包的库是jquery jquery: [\u0026#39;jquery\u0026#39;], }, output: { // 输出出口指定 filename: \u0026#39;[name].js\u0026#39;, // name就是jquery path: resolve(__dirname, \u0026#39;dll\u0026#39;), // 打包到dll目录下 library: \u0026#39;[name]_[hash]\u0026#39;, // 打包的库里面向外暴露出去的内容叫什么名字 }, plugins: [ // 打包生成一个manifest.json --\u0026gt; 提供jquery的映射关系（告诉webpack：jquery之后不需要再打包和暴露内容的名称） new webpack.DllPlugin({ name: \u0026#39;[name]_[hash]\u0026#39;, // 映射库的暴露的内容名称 path: resolve(__dirname, \u0026#39;dll/manifest.json\u0026#39;), // 输出文件路径 entryOnly: true, // 则仅暴露入口，确保 DLL 中的 tree shaking 正常工作 }), ], mode: \u0026#39;production\u0026#39;, }; webpack.config.js 配置：(告诉 webpack 不需要再打包 jquery，并将之前打包好的 jquery 跟其他打包好的资源一同输出到 build 目录下)\n// 引入插件 const webpack = require(\u0026#39;webpack\u0026#39;); const AddAssetHtmlWebpackPlugin = require(\u0026#39;add-asset-html-webpack-plugin\u0026#39;); // plugins中配置： plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39; }), // 告诉webpack哪些库不参与打包，同时使用时的名称也得变 new webpack.DllReferencePlugin({ manifest: resolve(__dirname, \u0026#39;dll/manifest.json\u0026#39;) }), // 将某个文件打包输出到build目录下，并在html中自动引入该资源 new AddAssetHtmlWebpackPlugin({ filepath: resolve(__dirname, \u0026#39;dll/jquery.js\u0026#39;) }) ], 提升 enrty entry: 入口起点\nstring \u0026ndash;\u0026gt; \u0026lsquo;./src/index.js\u0026rsquo;，单入口\n打包形成一个 chunk。 输出一个 bundle 文件。此时 chunk 的名称默认是 main\narray \u0026ndash;\u0026gt; [\u0026rsquo;./src/index.js\u0026rsquo;, \u0026lsquo;./src/add.js\u0026rsquo;]，多入口\n所有入口文件最终只会形成一个 chunk，输出出去只有一个 bundle 文件。\n（一般只用在 HMR 功能中让 html 热更新生效）\nobject，多入口\n有几个入口文件就形成几个 chunk，输出几个 bundle 文件，此时 chunk 的名称是 key 值\noutput output: { // 文件名称（指定名称+目录） filename: \u0026#39;js/[name].js\u0026#39;, // 输出文件目录（将来所有资源输出的公共目录） path: resolve(__dirname, \u0026#39;build\u0026#39;), // 所有资源引入公共路径前缀（可以做cdn） --\u0026gt; \u0026#39;imgs/a.jpg\u0026#39; --\u0026gt; \u0026#39;/imgs/a.jpg\u0026#39; publicPath: \u0026#39;/\u0026#39;, chunkFilename: \u0026#39;js/[name]_chunk.js\u0026#39;, // 指定非入口chunk的名称 library: \u0026#39;[name]\u0026#39;, // 打包整个库后向外暴露的变量名 libraryTarget: \u0026#39;window\u0026#39; // 变量名添加到哪个上 browser：window // libraryTarget: \u0026#39;global\u0026#39; // node：global // libraryTarget: \u0026#39;commonjs\u0026#39; // conmmonjs模块 exports }, resolve // 解析模块的规则 resolve: { // 配置解析模块路径别名: 优点：当目录层级很复杂时，简写路径；缺点：路径不会提示 alias: { $css: resolve(__dirname, \u0026#39;src/css\u0026#39;) }, // 配置省略文件路径的后缀名（引入时就可以不写文件后缀名了） extensions: [\u0026#39;.js\u0026#39;, \u0026#39;.json\u0026#39;, \u0026#39;.jsx\u0026#39;, \u0026#39;.css\u0026#39;], // 告诉 webpack 解析模块应该去找哪个目录 modules: [resolve(__dirname, \u0026#39;../../node_modules\u0026#39;), \u0026#39;node_modules\u0026#39;] } 这样配置后，引入文件就可以这样简写：import '$css/index';\ndev server devServer: { // 运行代码所在的目录 contentBase: resolve(__dirname, \u0026#39;build\u0026#39;), // 监视contentBase目录下的所有文件，一旦文件变化就会reload watchContentBase: true, watchOptions: { // 忽略文件 ignored: /node_modules/ }, // 启动gzip压缩 compress: true, // 端口号 port: 5000, // 域名 host: \u0026#39;localhost\u0026#39;, // 自动打开浏览器 open: true, // 开启HMR功能 hot: true, // 不要显示启动服务器日志信息 clientLogLevel: \u0026#39;none\u0026#39;, // 除了一些基本信息外，其他内容都不要显示 quiet: true, // 如果出错了，不要全屏提示 overlay: false, // 服务器代理，--\u0026gt; 解决开发环境跨域问题 proxy: { // 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到另外一个服务器3000 \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, // 发送请求时，请求路径重写：将/api/xxx --\u0026gt; /xxx （去掉/api） pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; } } } } optimization contenthash 缓存会导致一个问题：修改 a 文件导致 b 文件 contenthash 变化。 因为在 index.js 中引入 a.js，打包后 index.js 中记录了 a.js 的 hash 值，而 a.js 改变，其重新打包后的 hash 改变，导致 index.js 文件内容中记录的 a.js 的 hash 也改变，从而重新打包后 index.js 的 hash 值也会变，这样就会使缓存失效。（改变的是 a.js 文件但是 index.js 文件的 hash 值也改变了） 解决办法：runtimeChunk \u0026ndash;\u0026gt; 将当前模块记录其他模块的 hash 单独打包为一个文件 runtime，这样 a.js 的 hash 改变只会影响 runtime 文件，不会影响到 index.js 文件\noutput: { filename: \u0026#39;js/[name].[contenthash:10].js\u0026#39;, path: resolve(__dirname, \u0026#39;build\u0026#39;), chunkFilename: \u0026#39;js/[name].[contenthash:10]_chunk.js\u0026#39; // 指定非入口文件的其他chunk的名字加_chunk }, optimization: { splitChunks: { chunks: \u0026#39;all\u0026#39;, /* 以下都是splitChunks默认配置，可以不写 miniSize: 30 * 1024, // 分割的chunk最小为30kb（大于30kb的才分割） maxSize: 0, // 最大没有限制 minChunks: 1, // 要提取的chunk最少被引用1次 maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量为5 maxInitialRequests: 3, // 入口js文件最大并行请求数量 automaticNameDelimiter: \u0026#39;~\u0026#39;, // 名称连接符 name: true, // 可以使用命名规则 cacheGroups: { // 分割chunk的组 vendors: { // node_modules中的文件会被打包到vendors组的chunk中，--\u0026gt; vendors~xxx.js // 满足上面的公共规则，大小超过30kb、至少被引用一次 test: /[\\\\/]node_modules[\\\\/]/, // 优先级 priority: -10 }, default: { // 要提取的chunk最少被引用2次 minChunks: 2, prority: -20, // 如果当前要打包的模块和之前已经被提取的模块是同一个，就会复用，而不是重新打包 reuseExistingChunk: true } } */ }, // 将index.js记录的a.js的hash值单独打包到runtime文件中 runtimeChunk: { name: entrypoint =\u0026gt; `runtime-${entrypoint.name}` }, minimizer: [ // 配置生产环境的压缩方案：js/css new TerserWebpackPlugin({ // 开启缓存 cache: true, // 开启多进程打包 parallel: true, // 启用sourceMap(否则会被压缩掉) sourceMap: true }) ] } webpack 中的默认配置 entry: \u0026#34;./src/index.js\u0026#34; output.path: path.resolve(__dirname, \u0026#34;dist\u0026#34;) output.filename: \u0026#34;[name].js\u0026#34; 题外话 webpack 东西太多了！！！这学的脑瓜子难受，感觉受到了 dos 攻击，我大脑都要拒绝服务（拒绝思考）了，不过学的时候看弹幕其他人都是先用 vue 后学 webpack，我这直接上来就 webpack，真的头大。还有，这笔记记录的只不过 webpack 的冰山一角，看看官方文档的目录就直接跪了，更不要提写自己的 loader 和 plugin 了，学无止境，webpack 先到此为止吧，啥时候有时间再啃文档，真尼玛多。\n","date":"2021-03-27T22:55:10Z","image":"https://static.aecra.cn/cover/webpack-learning-notes.jpg","permalink":"https://aecra.github.io/article/webpack-learning-notes/","title":"webpack 学习笔记"},{"content":"说明 此算法可以称为“加边法”，初始最小生成树边数为 0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。\n实现思路 把图中的所有边按代价从小到大排序； 把图中的 n 个顶点看成独立的 n 棵树组成的森林； 按权值从小到大选择边，所选的边连接的两个顶点 ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 重复(3),直到所有顶点都在一颗树内或者有 n-1 条边为止。 代码示例 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Edge { int u, v, w; } edge[200005]; int fa[5005], n, m, ans, eu, ev, cnt; inline bool cmp(Edge a, Edge b) { return a.w \u0026lt; b.w; //快排的依据 } inline int find(int x) { while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x; } //并查集模板，用while循环比递归版快 inline void kruskal() { sort(edge, edge + m, cmp); //将边的权值排序 for (int i = 0; i \u0026lt; m; i++) { eu = find(edge[i].u), ev = find(edge[i].v); if (euev) continue; //若出现环，则continue ans += edge[i].w; //更新答案 fa[ev] = eu; cnt++; if (cntn - 1) break; //循环结束条件 } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) fa[i] = i; //初始化并查集 for (int i = 0; i \u0026lt; m; i++) scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;edge[i].u, \u0026amp;edge[i].v, \u0026amp;edge[i].w); kruskal(); printf(\u0026#34;%d\u0026#34;, ans); return 0; } ","date":"2021-03-27T22:47:46Z","image":"https://static.aecra.cn/cover/minimum-spanning-tree-kruskal-algorithm.jpg","permalink":"https://aecra.github.io/article/minimum-spanning-tree-kruskal-algorithm/","title":"最小生成树（kruskal 算法）"},{"content":"pip 国内源 豆瓣 http://pypi.douban.com/simple/\n清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/\n阿里云 https://mirrors.aliyun.com/pypi/simple/\n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n临时更换 pip install pythonModuleName -i https://mirrors.aliyun.com/pypi/simple 永久更换 windows 直接在 user 目录中创建一个 pip 目录，如：C:\\Users\\xx\\pip，新建文件 pip.ini，内容如下\n[global] index-url = https://mirrors.aliyun.com/pypi/simple/ Linux #创建目录 mkdir -p ~/.pip #修改配置文件 vim ~/.pip/pip.conf #写入以下内容并保存 [global] index-url = https://mirrors.aliyun.com/pypi/simple/ npm cnpm（间接换源） Private npm registry and web for Company.\n安装并使用国内淘宝镜像源\nnpm install cnpm -g --registry=https://r.npm.taobao.org 直接换源 单次使用\nnpm install --registry=https://registry.npm.taobao.org 永久使用\nnpm config set registry https://registry.npm.taobao.org Ubuntu 修改软件源配置文件 sources.list\nsudo vim /etc/apt/sources.list 注释掉全部内容(i)，在末尾加入如下数据\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 保存退出(Esc,!wq)，更新软件\nsudo apt-get update sudo apt-get upgrade Golang 直接命令行配置 启用 Go Modules 功能\ngo env -w GO111MODULE=on 配置 GOPROXY 环境变量\n# 官方镜像源 go env -w GOPROXY=https://goproxy.io,direct # 阿里镜像源 go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct # 七牛云 CDN go env -w GOPROXY=https://goproxy.cn,direct 验证\nsource ~/.bashrc 后使用命令 go env | grep GOPROXY 查看配置是否成功。\n私有模块\n采用自有仓库，不经过镜像，可使用 GOPRIVATE 环境变量设置，多个使用逗号隔开。\ngo env -w GOPRIVATE=*.corp.example.com 使用系统环境变量配置 Linux / Mac 配置\necho \u0026#34;export GO111MODULE=on\u0026#34; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#34;export GOPROXY=https://goproxy.cn\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc Windows 配置\n单次使用：\n$env:GO111MODULE = \u0026#34;on\u0026#34; $env:GOPROXY = \u0026#34;https://goproxy.cn\u0026#34; 永久使用：\n在系统个环境变量编辑器中设置变量 GO111MODULE，值为 on；变量 GOPROXY，值为 goproxy.cn。\n银弹 以上更换国内源的方法实在是过于繁杂，更好的方法是使用系统代理直接将本机流量转发到处于正常的网络环境的机器中。参见新文章 为服务器配置畅通的网络环境。\n","date":"2021-03-24T16:44:54Z","image":"https://static.aecra.cn/cover/replace-domestic-source.jpg","permalink":"https://aecra.github.io/article/replace-domestic-source/","title":"更换国内源"},{"content":"含义 对于有根树 T 的两个结点 u、v，最近公共祖先 LCA(T,u,v)表示一个结点 x，满足 x 是 u 和 v 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先。\n算法思路 下图所示:\n4 和 5 的 LCA 就是 2，那怎么求呢？\n最粗暴的方法就是先 dfs 一次，处理出每个点的深度，然后把深度更深的那一个点（4）一个点地一个点地往上跳，直到到某个点（3）和另外那个点（5）的深度一样然后两个点一起一个点地一个点地往上跳，直到到某个点（就是最近公共祖先）两点“变”成了一个点。\n不过有没有发现一个点地一个点地跳很浪费时间？如果一下子跳到目标点内存又可能不支持，因此相对来说倍增的性价比算是很高的。\n倍增的话就是一次跳 2i 个点，倍增找 lca 的方法是这样的：\n从最大可以跳的步数开始跳(一定是 2^i)，如果跳的到的位置一样，就不跳，如果不一样才跳，每次跳的路程是前一次的一半过程大概就像上图所示，但是执行完了这一段到的点不是最近公共祖先，但是，它们再往上跳一格，就到了。\n代码示例 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int maxn = 500000 + 2; int n, m, root; int k = 0; int head[maxn], depth[maxn], pmaxn; //head数组记录点的出边的起始下标， //depth存的是深度（deep）, //pi存的[i]向上走2的j次方那么长的路径 struct node { int v, next; } e[maxn * 2]; //邻接表（链式前向星）存树 void add(int u, int v) { e[k].v = v; e[k].next = head[u]; head[u] = k++; } //加边函数 void dfs(int u, int fa) { depth[u] = depth[fa] + 1; pu = fa; //u向上跳2^0（1）个点是其父节点 for (int i = 1; (1 \u0026lt;\u0026lt; i) \u0026lt;= depth[u]; i++) pu = pp[u][i - 1]; //画图思考，不会重复，很高效,因为从上到下添加点及其父节点 for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if (v != fa) dfs(v, u); } } //首先进行的预处理，将所有点的deep和p的初始值dfs出来 int lca(int a, int b) { //非常标准的lca查找 //将深度置为相同 if (depth[a] \u0026gt; depth[b]) swap(a, b); //保证a是在b结点上方，即a的深度小于b的深度 for (int i = 20; i \u0026gt;= 0; i--) if (depth[a] \u0026lt;= depth[b] - (1 \u0026lt;\u0026lt; i)) b = pb; //如果b的祖先为a,那就可以直接返回答案了 if (a == b) return a; for (int i = 20; i \u0026gt;= 0; i--) { if (pa == pb) continue; else a = pa, b = pb; //A和B一起上移 } return pa; //找出最后a值的父节点 } int main() { memset(head, -1, sizeof(head)); int a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;root); for (int i = 1; i \u0026lt; n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); add(b, a); //无向图，要加两次 } dfs(root, 0); for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%d \u0026#34;, lca(a, b)); } return 0; } ","date":"2021-03-17T23:50:14Z","image":"https://static.aecra.cn/cover/last-common-ancestor-lca.jpg","permalink":"https://aecra.github.io/article/last-common-ancestor-lca/","title":"最近公共祖先lca"},{"content":"前置知识准备 函数对象与实例对象 函数对象：将函数作为对象使用时, 简称为函数对象。\n实例对象：new 函数产生的对象, 简称为实例对象。\nfunction Fn() { // Fn函数 } const fn = new Fn(); // Fn是构造函数 fn是实例对象(简称为对象) console.log(Fn.prototype); // Fn是函数对象 Fn.call({}); // Fn是函数对象 $(\u0026#39;#test\u0026#39;); // jQuery函数 $.get(\u0026#39;/test\u0026#39;); // jQuery函数对象 两种类型的回调函数 同步回调 理解：立即执行, 完全执行完了才结束, 不会放入回调队列中\n例子：数组遍历相关的回调函数 / Promise 的 excutor 函数\nconst arr = [1, 3, 5]; arr.forEach((item) =\u0026gt; { // 遍历回调, 同步回调函数, 不会放入列队, 一上来就要执行完 console.log(item); }); console.log(\u0026#39;forEach()之后\u0026#39;); // 1 // 3 // 5 // forEach()之后 异步回调 理解：不会立即执行, 会放入回调队列中将来执行\n例子：定时器回调 / ajax 回调 / Promise 的成功|失败的回调\nsetTimeout(() =\u0026gt; { // 异步回调函数, 会放入队列中将来执行 console.log(\u0026#39;timout callback()\u0026#39;); }, 0); console.log(\u0026#39;setTimeout()之后\u0026#39;); // setTimeout()之后 // timout callback() 程序错误 错误类型 Error: 所有错误的父类型\nReferenceError: 引用的变量不存在\nTypeError: 数据类型不正确的错误\nRangeError: 数据值不在其所允许的范围内\nSyntaxError: 语法错误\n/* ReferenceError: 引用的变量不存在 */ console.log(a) // ReferenceError: a is not defined console.log(\u0026#39;-----\u0026#39;) // 没有捕获error, 下面的代码不会执行 /* TypeError: 数据类型不正确的错误 */ let b console.log(b.xxx) // TypeError: Cannot read property \u0026#39;xxx\u0026#39; of undefined b = {} b.xxx() // TypeError: b.xxx is not a function /* RangeError: 数据值不在其所允许的范围内 */ function fn() { fn() } fn() // RangeError: Maximum call stack size exceeded /* SyntaxError: 语法错误 */ const c = \u0026#34;\u0026#34;\u0026#34;\u0026#34; // SyntaxError: Unexpected string 错误处理 捕获错误：try \u0026hellip; catch\ntry { let d; console.log(d.xxx); } catch (error) { console.log(error.message); console.log(error.stack); } console.log(\u0026#39;出错之后\u0026#39;); // Cannot read property \u0026#39;xxx\u0026#39; of undefined // TypeError: Cannot read property \u0026#39;xxx\u0026#39; of undefined // at \u0026lt;anonymous\u0026gt;:3:19 // 出错之后 抛出错误：throw error\nfunction something() { if (Date.now() % 2 === 1) { console.log(\u0026#39;当前时间为奇数, 可以执行任务\u0026#39;); } else { // 如果时间是偶数抛出异常, 由调用来处理 throw new Error(\u0026#39;当前时间为偶数无法执行任务\u0026#39;); } } // 捕获处理异常 try { something(); } catch (error) { alert(error.message); } 错误对象\nmessage 属性: 错误相关信息\nstack 属性: 函数调用栈记录信息\nPromise 深入 含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n特点 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n基本使用 // 1. 创建一个新的promise对象 const p = new Promise((resolve, reject) =\u0026gt; { // 执行器函数 同步回调 console.log(\u0026#39;执行 excutor\u0026#39;); // 2. 执行异步操作任务 setTimeout(() =\u0026gt; { const time = Date.now(); // 如果当前时间是偶数就代表成功, 否则代表失败 // 3.1. 如果成功了, 调用resolve(value) if (time % 2 == 0) { resolve(\u0026#39;成功的数据, time=\u0026#39; + time); } else { // 3.2. 如果失败了, 调用reject(reason) reject(\u0026#39;失败的数据, time=\u0026#39; + time); } }, 1000); }); console.log(\u0026#39;new Promise()之后\u0026#39;); p.then( (value) =\u0026gt; { // 接收得到成功的value数据 onResolved console.log(\u0026#39;成功的回调\u0026#39;, value); }, (reason) =\u0026gt; { // 接收得到失败的reason数据 onRejected console.log(\u0026#39;失败的回调\u0026#39;, reason); } ); // 执行 excutor // new Promise()之后 // 失败的回调 失败的数据, time=1615801107751 为什么要用 Promise 指定回调函数的方式更加灵活:\n​ 旧的：必须在启动异步任务前指定\n​ promise：启动异步任务 =\u0026gt; 返回 promie 对象 =\u0026gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后指定)\n支持链式调用, 可以解决回调地狱问题\n什么是回调地狱? 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件\n回调地狱的缺点? 不便于阅读 / 不便于异常处理\n解决方案? promise 链式调用\n终极解决方案? async/await\n详见 JavaScript 中的异步编程\nPromise 的 API Promise 构造函数: Promise (excutor) {}\nexcutor 函数: 同步执行 (resolve, reject) =\u0026gt; {}\nresolve 函数: 内部定义成功时我们调用的函数 value =\u0026gt; {}\nreject 函数: 内部定义失败时我们调用的函数 error =\u0026gt; {}\n说明: excutor 会在 Promise 内部立即同步回调,异步操作在执行器中执行\nPromise.prototype.then 方法: (onResolved, onRejected) =\u0026gt; {}\nonResolved 函数: 成功的回调函数 (value) =\u0026gt; {}\nonRejected 函数: 失败的回调函数 (error) =\u0026gt; {}\n说明: 指定用于得到成功 value 的成功回调和用于得到失败 error 的失败回调\n返回一个新的 promise 对象\nPromise.prototype.catch 方法: (onRejected) =\u0026gt; {}\nonRejected 函数: 失败的回调函数 (error) =\u0026gt; {}\n说明: then()的语法糖, 相当于: then(undefined, onRejected)\nPromise.resolve 方法: (value) =\u0026gt; {}\nvalue: 成功的数据或 promise 对象\n说明: 返回一个成功/失败的 promise 对象\nPromise.reject 方法: (error) =\u0026gt; {}\nerror: 错误内容\n说明: 返回一个失败的 promise 对象\nPromise.all 方法: (promises) =\u0026gt; {}\npromises: 包含 n 个 promise 的数组\n说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败\nPromise.race 方法: (promises) =\u0026gt; {}\npromises: 包含 n 个 promise 的数组\n说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态\nPromise 的几个关键问题 如何改变 promise 的状态?\n(1)resolve(value): 如果当前是 pendding 就会变为 resolved\n(2)reject(error): 如果当前是 pendding 就会变为 rejected\n(3)抛出异常: 如果当前是 pendding 就会变为 rejected\nconst p = new Promise((resolve, reject) =\u0026gt; { resolve(1); // promise变为resolved成功状态 reject(2); // promise变为rejected失败状态 throw new Error(\u0026#39;出错了\u0026#39;); // 抛出异常, promse变为rejected失败状态, error为抛出的error throw 3; // 抛出异常, promse变为rejected失败状态, error为 抛出的3 }); 一个 promise 指定多个成功/失败回调函数, 都会调用吗?\n当 promise 改变为对应状态时都会调用\n改变 promise 状态和指定回调函数谁先谁后?\n(1)都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调\n(2)如何先改状态再指定回调?\n① 在执行器中直接调用 resolve()/reject()\n② 延迟更长时间才调用 then()\n(3)什么时候才能得到数据?\n① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据\n② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据\npromise.then()返回的新 promise 的结果状态由什么决定?\n(1)简单表达: 由 then()指定的回调函数执行的结果决定\n(2)详细表达:\n① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常\n② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值\n③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果\npromise 如何串连多个操作任务?\n(1)promise 的 then()返回一个新的 promise, 可以写成 then()的链式调用\n(2)通过 then 的链式调用串连多个同步/异步任务\npromise 异常传/穿透?\n(1)当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调\n(2)前面任何操作出了异常, 都会传到最后失败的回调中处理\n// Promise.prototype.then()的默认调用 Promise.prototype.then( (value) =\u0026gt; Promise.resolve(calue), (error) =\u0026gt; Promise.reject(error) ); 中断 promise 链?\n(1)当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数\n(2)办法: 在回调函数中返回一个 pendding 状态的 promise 对象\nreturn new Promise(() =\u0026gt; {}); 自定义（手写）Promise 代码 /** * 自定义Promise类 */ class Promise { /** * Promise 构造函数 * executor：执行器函数（同步执行） */ constructor(executor) { this.status = PENDING; this.value = undefined; this.callbacks = []; const resolve = (value) =\u0026gt; { if (this.status !== PENDING) { return; } this.status = RESOLVED; this.data = value; if (this.callbacks.length \u0026gt; 0) { setTimeout(() =\u0026gt; { // 异步调用已在队列中的回调函数 this.callbacks.forEach((callback) =\u0026gt; { callback.onResolved(value); }); }); } }; const reject = (error) =\u0026gt; { if (this.status !== PENDING) { return; } this.status = REJECTED; this.data = error; if (this.callbacks.length \u0026gt; 0) { setTimeout(() =\u0026gt; { // 异步调用已在队列中的回调函数 this.callbacks.forEach((callback) =\u0026gt; { callback.onRejected(error); }); }); } }; try { executor(resolve, reject); } catch (error) { reject(error); } } /** * Promise 原型对象的 then() * 指定成功和失败的回调函数 * 返回一个新的 Promise 对象 */ then(onResolved, onRejected) { onResolved = typeof onResolved === \u0026#39;function\u0026#39; ? onResolved : (value) =\u0026gt; value; onRejected = typeof onRejected === \u0026#39;function\u0026#39; ? onRejected : (error) =\u0026gt; { throw error; }; return new Promise((resolve, reject) =\u0026gt; { const handle = (callback) =\u0026gt; { try { const result = callback(this.data); if (result instanceof Promise) { result.then(resolve, reject); } else { resolve(result); } } catch (error) { reject(error); } }; if (this.status === RESOLVED) { setTimeout(() =\u0026gt; { handle(onResolved); }); } else if (this.status === REJECTED) { setTimeout(() =\u0026gt; { handle(onRejected); }); } else { this.callbacks.push({ onResolved: () =\u0026gt; { handle(onResolved); }, onRejected: () =\u0026gt; { handle(onRejected); }, }); } }); } /* * Promise 原型对象的 catch() * 指定失败的回调函数 * 返回一个新的 Promise 对象 */ catch(onRejected) { return this.then(undefined, onRejected); } /** * Promise 函数的对象的 resolve 方法 * 返回一个指定 error 的失败的 promise */ static resolve(value) { if (value instanceof Promise) { return value; } else { return new Promise((resolve, reject) =\u0026gt; { resolve(value); }); } } /** * Promise 函数的对象的 reject 方法 * 返回一个指定 error 的失败的 promise */ static reject(error) { return new Promise((resolve, reject) =\u0026gt; { reject(error); }); } /** * Promise 函数对象的 all 方法 * 返回一个 promise，只有当所有的 promise 都成功时才成功，否则只要有一个失败就失败 */ static all(promises) { return new Promise((resolve, reject) =\u0026gt; { let values = []; promises.forEach((promise, index) =\u0026gt; { promise = Promise.resolve(promise); promise.then( (value) =\u0026gt; { values[index] = value; if (values.length === promises.length) { resolve(values); } }, (error) =\u0026gt; { reject(error); } ); }); }); } /** * Promise 函数对象的 race 方法 * 返回一个 promise，其结果由第一个完成的 promise 决定 */ static race(promises) { return new Promise((resolve, reject) =\u0026gt; { promises.forEach((promise) =\u0026gt; { promise = Promise.resolve(promise); promise.then(resolve, reject); }); }); } } 遇到的问题 this 的指向\n在 executor 中，因为设定了 setTimeout，因而 resolve 调用时的 this 指向为当前运行环境的 this（window），因此通过箭头函数，将 this 设置为函数创建时的 this 即 promise 实例可以解决 resolve 调用时 this 指向问题。\n在 then 方法中，handle 实际调用时 this 同样为 window，通过箭头函数解决 this 指向问题。\n微任务和宏任务\n在 es6 中 then 中的函数会放入微任务中，而因为开发者无法向微任务队列中添加任务，所以用宏任务替代，即用 setTimeout 实现异步执行，详细问题见 JavaScript 中的异步编程\nthen 方法如何书写？\n返回一个 Promise 实例，其中存储了 then 中代码运行状态的信息； 运行状态信息受到 onResolved 和 onRejected 的执行结果影响； then 同步执行，then 中的函数异步执行且受调用 then 的 promise 实例状态的控制； 异常穿透； 面试题 面试题 1 setTimeout(() =\u0026gt; { console.log(1); }, 0); Promise.resolve().then(() =\u0026gt; { console.log(2); }); Promise.resolve().then(() =\u0026gt; { console.log(4); }); console.log(3); // 3 2 4 1 面试题 2 setTimeout(() =\u0026gt; { console.log(1); }, 0); new Promise((resolve) =\u0026gt; { console.log(2); resolve(); }) .then(() =\u0026gt; { console.log(3); }) .then(() =\u0026gt; { console.log(4); }); console.log(5); // 2 5 3 4 1 面试题 3 const first = () =\u0026gt; new Promise((resolve, reject) =\u0026gt; { console.log(3); let p = new Promise((resolve, reject) =\u0026gt; { console.log(7); setTimeout(() =\u0026gt; { console.log(5); resolve(6); }, 0); resolve(1); }); resolve(2); p.then((arg) =\u0026gt; { console.log(arg); }); }); first().then((arg) =\u0026gt; { console.log(arg); }); console.log(4); // 3 7 4 1 2 5 注意：promise 状态一但变化就固定下来了。\n面试题 4 setTimeout(() =\u0026gt; { console.log(\u0026#39;0\u0026#39;); }, 0); new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;1\u0026#39;); resolve(); }) .then(() =\u0026gt; { console.log(\u0026#39;2\u0026#39;); new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;3\u0026#39;); resolve(); }) .then(() =\u0026gt; { console.log(\u0026#39;4\u0026#39;); }) .then(() =\u0026gt; { console.log(\u0026#39;5\u0026#39;); }); }) .then(() =\u0026gt; { console.log(\u0026#39;6\u0026#39;); }); new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;7\u0026#39;); resolve(); }).then(() =\u0026gt; { console.log(\u0026#39;8\u0026#39;); }); // 1 7 2 3 8 4 6 5 0 注意：then 中函数是否放入微任务队列取决于它前面的 Promise 的状态改变。\n","date":"2021-03-15T16:06:58Z","image":"https://static.aecra.cn/cover/promise-deep-custom-promise.jpg","permalink":"https://aecra.github.io/article/promise-deep-custom-promise/","title":"Promise 深入 + 自定义 Promise"},{"content":"对象中 this 指向问题 var name = \u0026#39;小王\u0026#39;, age = 17; var persion = { name: \u0026#39;小王\u0026#39;, myAge: this.age, introduce() { console.log(\u0026#39;我叫\u0026#39; + this.name + \u0026#39;，我今年\u0026#39; + this.age); }, }; person.myAge; // 17 persion.introduce(); // 我叫小王，我今年undefined 在该样例中，persion 的属性 myAge 设置的时候为 this.age，即将 window.age 赋值给 objAge，此时 this 指向 window。introduce 执行时，this 指向 persion 对象，所以 this.age 为 undefined。\n一般函数中 this 的指向 var name = \u0026#39;小钱\u0026#39;; function sayName() { console.log(this.name); } 此时函数中的 this 指向的是全局对象 this。\ncall()、apply()、bind()的简单应用 var name = \u0026#39;小王\u0026#39;, age = 17; var persion = { name: \u0026#39;小王\u0026#39;, myAge: this.age, introduce() { console.log(\u0026#39;我叫\u0026#39; + this.name + \u0026#39;，我今年\u0026#39; + this.age); }, }; var persion2 = { name: \u0026#39;小钱\u0026#39;, age: 18, }; persion.introduce.call(persion2); // 我叫小钱，我今年18 persion.introduce.apply(persion2); // 我叫小钱，我今年18 persion.introduce.bind(persion2)(); // 我叫小钱，我今年18 由此例可以看出，call()、apply()、bind()都可以改变 this 的指向为指定对象。其中如果没有传入参数，那么将 Global 对象作为参数传入。\n另外可见 bind 返回的是一个新的函数，但该函数执行之后三个方法此时并无差异。\ncall()、apply()、bind()传参 var name = \u0026#39;小王\u0026#39;, age = 17; var persion = { name: \u0026#39;小王\u0026#39;, myAge: this.age, introduce(toPersion = \u0026#39;同学\u0026#39;, from = \u0026#39;河北\u0026#39;) { console.log(toPersion + \u0026#39;你好，我叫\u0026#39; + this.name + \u0026#39;来自\u0026#39; + from + \u0026#39;，我今年\u0026#39; + this.age); }, }; var persion2 = { name: \u0026#39;小钱\u0026#39;, age: 18, }; persion.introduce.call(persion2, \u0026#39;小齐\u0026#39;, \u0026#39;北京\u0026#39;); // 小齐你好，我叫小钱来自北京，我今年18 persion.introduce.apply(persion2, [\u0026#39;小齐\u0026#39;, \u0026#39;北京\u0026#39;]); // 小齐你好，我叫小钱来自北京，我今年18 persion.introduce.bind(persion2, \u0026#39;小齐\u0026#39;, \u0026#39;北京\u0026#39;)(); // 小齐你好，我叫小钱来自北京，我今年18 从此例可以看出 call()、bind()、 apply()这三个函数的第一个参数都是 this 的指向对象，但传参时 call()和 bind()都是向后依次添加参数，而 apply 是传入数组。\n","date":"2021-03-14T23:47:57Z","image":"https://static.aecra.cn/cover/differences-in-the-usage-of-call-apply-and-bind-in-javascript.jpg","permalink":"https://aecra.github.io/article/differences-in-the-usage-of-call-apply-and-bind-in-javascript/","title":"JavaScript 中 call()、apply()、bind() 的用法差异"},{"content":"apt-get 安装 apt-get，是一条 linux 命令，适用于 deb 包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。如果下载慢可更换为国内源。\n# 安装软件包 apt-get install # 移除软件包 apt-get remove # 移除软件包及配置文件 pt-get purge # 刷新存储库索引 apt-get update # 升级所有可升级的软件包 apt-get upgrade # 自动删除不需要的包 apt-get autoremove # 在升级软件包时自动处理依赖关系 apt-get dist-upgrade # 搜索应用程序 apt-cache search # 显示装细节 apt-cache show deb 安装包安装 deb 是 Debian 软件包格式的文件扩展名。\n# 安装 deb 包 dpkg -i \u0026lt;package.deb\u0026gt; # 移除 deb 包 dpkg -r \u0026lt;package\u0026gt; 二进制文件安装 二进制源码包一般都以 tar.gz 的方式压缩，下载之后需要解压压缩包，压缩包最好移动到 /usr/local/lib 目录，该目录用用于放用户自己特定的可执行文件，然后需要对可执行文件建立软链接到 /usr/bin目录，几乎所有的系统可执行文件都会安装在这里，由此可以通过命令行进行调用（/usr/local/bin 应该也是可以的，可以自行尝试，是不是这个更合理一点？）。\n# 解压 tar.gz 压缩包 tar -xzvf xxx.tar.gz # 讲二进制文件包移动到 /usr/local/lib sudo mv xxx.tar.gz /usr/local/lib/xxx # 建立软链接，以 node 为例 sudo ln -s /usr/local/lib/node/bin/node /usr/bin/node 源码安装 有些程序可能以上方式都无法安装，只提供了源码，此时可以通过 make 编译之后进行安装。\n# 解压 tar.gz 压缩包 tar -xzvf xxx.tar.gz # 预编译 ./configure # 编译 make # 安装 make install # 默认安装/usr/local/bin，改变安装路径 ./configure --prefix=/opt/xxx ","date":"2021-03-12T19:47:32Z","image":"https://static.aecra.cn/cover/ubuntu-deepin-installation-software.jpg","permalink":"https://aecra.github.io/article/ubuntu-deepin-installation-software/","title":"Ubuntu、Deepin 安装软件"},{"content":"简述 拓展欧几里得定理也称辗转相除法\n公示表述：gcd(a,b)=gcd(b,a mod b)；\n具体解释在代码里。\n（沙雕一下：终极版本为求组合数）\n补充知识点：\na / b % c != ((a % c) / (b % c)) % c 为了解决这个问题，出现了乘法逆元，若 b*x mod c=1,则 x 为 b 模 c 的乘法逆元\n(a / b) % c = (a / b1) % c = (a / bbx) % c = ax % c 这样就会做了\n代码示例 #include \u0026lt;stdio.h\u0026gt; #define mod 1000000007 using namespace std; //ax+by+c=0;有整数解当且仅当c=kgcd(a,b); //ax+by=gcd(a,b) 先求;(x+b)%b是a关于模b的乘法逆元，前提是a，b互素 //ax+by=-c;的解为x0=-x/gcd(a,b)c y0=-y/gcd(a,b)c //x\u0026#39;=x+k(b/gcd(a,b)) y\u0026#39;=y-k(a/gcd(a,b)); ax+by=gcd(a,b)的任意整数解 int table[1000005]; //计算阶乘表 void cal_table() { table[0] = 1; for (int i = 1; i \u0026lt;= 1000000; i++) table[i] = table[i - 1] i % mod; } //解ax+by=gcd(a,b)，返回a，b的最大公因数 int extend_gcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (b0) { x = 1; y = 0; return a; } int r = extend_gcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return r; } //求a在模b下的乘法逆元（注意只有在a,b互素时才有乘法逆元）,若不存在逆元则返回-1 int inv(int a, int b) { int x, y, d; d = extend_gcd(a, b, x, y); return (d1) ? (x + b) % b : -1; //因为x可能是负数，所以+b保证为正 } //求组合数 int C(int n, int m) { if (n \u0026lt; 0 || m \u0026lt; 0 || m \u0026gt; n) return 0; return table[n] inv(table[m], mod) % modinv(table[n - m], mod) % mod; } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); cal_table(); printf(\u0026#34;%lld \u0026#34;, C(n, m)); return 0; } ","date":"2021-03-08T19:02:08Z","image":"https://static.aecra.cn/cover/extended-euclidean-theorem.jpg","permalink":"https://aecra.github.io/article/extended-euclidean-theorem/","title":"拓展欧几里得定理"},{"content":"什么是异步编程 在谈论异步编程概念之提前，先了解什么是同步编程。同步编程是指程序的执行是按着代码顺序执行的，若一段代码因任何原因而卡住（http 请求或死循环）时，程序将不再往下执行，只有等前面的事件执行完之后，后面的事件才会执行。\n异步编程是指在某段耗时较长的代码执行完之前就将代码的执行权交由下面的代码执行，当耗时长的代码执行完之后再重新拿回代码的执行权继续执行。\nJavaScript 中的异步编程问题 浏览器的多线程 在浏览器中，每一个 tab 页面都是一个独立的进程，在该进程中同时存在多个线程，每个进程一般有以下几个常驻线程：\nGUI 渲染线程 JavaScript 引擎线程 事件触发线程 定时触发器线程 异步 http 请求线程 GUI 渲染线程 GUI 渲染线程负责渲染浏览器界面 HTML 元素，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。\n当界面需要重绘(Repaint)或由于某种操作引发回流(重排)(reflow)时,该线程就会执行。\n在 Javascript 引擎运行脚本期间,GUI 渲染线程都是处于挂起状态的,也就是说被”冻结”了，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。\nJavaScript 引擎线程 JavaScript 引擎，也可以称为 JS 内核，主要负责处理 Javascript 脚本程序，例如 V8 引擎。\nJS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序（单线程）。\n注意：GUI 渲染线程和 JavaScript 引擎线程互斥！\n由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。\n如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n事件触发线程 当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。\n这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。\n定时触发器线程 setInterval 与 setTimeout 所在线程\n浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。\n通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）\n注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。\n异步 http 请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。\n将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行。\n摘自：浏览器的多线程\n事件循环 如图：\n事件循环是指 JavaScript 引擎线程在工作时不断从任务队列（Event Queue）中获取任务并执行的过程。\n宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)。\n微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)。\n从浏览器的多线程可知，事件触发线程、定时触发器线程、异步 http 请求线程都会向任务队列（Event Queue）中添加宏任务。\n参考：\n深入理解 JavaScript 事件循环机制\n【JS】深入理解事件循环,这一篇就够了!(必看)\n实现异步编程 回调函数（callback） JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是\u0026quot;重新调用\u0026quot;。以下代码就是一个回调函数的例子：\najax(url, () =\u0026gt; { // 处理逻辑 }); 但是回调函数有一个致命的弱点，如果出现多重嵌套，代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。即产生\u0026quot;回调函数地狱\u0026quot;（callback hell）。例如多个请求存在依赖性，就会有如下代码：\najax(url, () =\u0026gt; { // 处理逻辑 ajax(url1, () =\u0026gt; { // 处理逻辑 ajax(url2, () =\u0026gt; { // 处理逻辑 }); }); }); 回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return。\n参考：es6 入门教程、JS 异步编程六种方案\n事件监听 采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\n还是以 f1 和 f2 为例。首先，为 f1 绑定一个事件（这里采用的 jQuery 的写法）。\nf1.on(\u0026#39;done\u0026#39;, f2); 上面这行代码的意思是，当 f1 发生 done 事件，就执行 f2。然后，对 f1 进行改写：\nfunction f1() { setTimeout(function () { // f1的任务代码 f1.trigger(\u0026#39;done\u0026#39;); }, 1000); } f1.trigger(\u0026lsquo;done\u0026rsquo;)表示，执行完成后，立即触发 done 事件，从而开始执行 f2。\n这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\u0026ldquo;去耦合\u0026rdquo;（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n摘自：Javascript 异步编程的 4 种方法\n发布/订阅 上一节的\u0026quot;事件\u0026quot;，完全可以理解成\u0026quot;信号\u0026quot;。\n我们假定，存在一个\u0026quot;信号中心\u0026quot;，某个任务执行完成，就向信号中心\u0026quot;发布\u0026quot;（publish）一个信号，其他任务可以向信号中心\u0026quot;订阅\u0026quot;（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\u0026ldquo;发布/订阅模式\u0026rdquo;（publish-subscribe pattern），又称\u0026ldquo;观察者模式\u0026rdquo;（observer pattern）。\n这个模式有多种实现，下面采用的是 Ben Alman 的Tiny Pub/Sub，这是 jQuery 的一个插件。\n首先，f2 向\u0026quot;信号中心\u0026quot;jQuery 订阅\u0026quot;done\u0026quot;信号。\njQuery.subscribe(\u0026#39;done\u0026#39;, f2); 然后，f1 进行如下改写：\nfunction f1() { setTimeout(function () { // f1的任务代码 jQuery.publish(\u0026#39;done\u0026#39;); }, 1000); } jQuery.publish(\u0026ldquo;done\u0026rdquo;)的意思是，f1 执行完成后，向\u0026quot;信号中心\u0026quot;jQuery 发布\u0026quot;done\u0026quot;信号，从而引发 f2 的执行。\n此外，f2 完成执行后，也可以取消订阅（unsubscribe）。\njQuery.unsubscribe(\u0026#39;done\u0026#39;, f2); 这种方法的性质与\u0026quot;事件监听\u0026quot;类似，但是明显优于后者。因为我们可以通过查看\u0026quot;消息中心\u0026quot;，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n摘自：Javascript 异步编程的 4 种方法\nPromise Promise 对象就是为了解决回调地狱而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续执行多个读取文件内容的异步任务，写法如下。\nvar readFile = require(\u0026#39;fs-readfile-promise\u0026#39;); readFile(fileA) .then(function (data) { console.log(data.toString()); }) .then(function () { return readFile(fileB); }) .then(function (data) { console.log(data.toString()); }) .catch(function (err) { console.log(err); }); 上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。Promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。\n可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。\nPromise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。\n摘自：Generator 函数的异步应用\n生成器（Generator/yield） 生成器中通过 yield 命令可以在异步任务执行过程时将程序的执行权移出 Generator 函数，并通过以下两种方法交回执行权：\n（1）回调函数。将异步操作包装成Thunk 函数，在回调函数里面交回执行权。\n（2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。\n实现第二种方法的库有co，详细介绍见ECMAScript 6 入门教程：co-模块\nasync/await async 函数是什么？一句话，它就是 Generator 函数的语法糖。\nasync函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await。\n改进：\nasync函数对 Generator 函数的改进，体现在以下四点。\n（1）内置执行器。\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\nasyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\n（2）更好的语义。\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n（3）更广的适用性。\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n（4）返回值是 Promise。\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n摘自：async 函数\n","date":"2021-03-05T20:54:11Z","image":"https://static.aecra.cn/cover/asynchronous-programming-in-javascript.jpg","permalink":"https://aecra.github.io/article/asynchronous-programming-in-javascript/","title":"JavaScript 中的异步编程"},{"content":"首先，快速幂的目的就是做到快速求幂，假设我们要求 a^b，按照朴素算法就是把 a 连乘 b 次，这样一来时间复杂度是 O(b)也即是 O(n)级别，快速幂能做到 O(logn)，快了好多好多。它的原理如下：\n假设我们要求 a^b，那么其实 b 是可以拆成二进制的，该二进制数第 i 位的权为 2^(i-1)\n例如当 b==11 时,a^11=a^(2^0+2^1+2^3)，11 的二进制是 1011，11 = 2^3×1 + 2^2×0 + 2^1×1 + 2^0×1，\n因此，我们将 a^11 转化为算a^(2^0)a^(2^1)a^(2^3)，也就是a^1 _ a^2 _ a^8.\n由于是二进制，很自然地想到用位运算这个强大的工具：\u0026amp;和\u0026raquo;。 \u0026amp;运算通常用于二进制取位操作，例如一个数 \u0026amp; 1 的结果就是取二进制的最末位。还可以判断奇偶 x\u0026amp;1==0 为偶，x\u0026amp;1==1 为奇。 \u0026raquo;运算比较单纯,二进制去掉最后一位。具体看代码。\n快速幂算法：\nint pow2(int a, int b) { int ans = 1; while (b) { if (b \u0026amp; 1) ans *= a; //末位是1 a *= a; b = b \u0026gt;\u0026gt; 1; } return ans; } 快速幂模运算根据(a^b) mod c=(a mod c)^b mod c\n快速幂取模：\nint PowerMod(int a, int b, int c) { int ans = 1; a = a % c; while (b) { if (b % 2 == 1) ans = (ans * a) % c; b = b / 2; a = (a * a) % c; } return ans; } ","date":"2021-03-04T10:43:14Z","image":"https://static.aecra.cn/cover/fast-power-and-fast-power-modulus.jpg","permalink":"https://aecra.github.io/article/fast-power-and-fast-power-modulus/","title":"快速幂和快速幂取模"},{"content":"图像预处理 空间域处理 点运算 HE\n直方图均衡 AHE\n自适应直方图均衡（局部均衡、模板滑动） CLAHE\n限制对比度自适应直方图均衡（裁剪均衡直方图、线性插值） 形态学运算 膨胀\n高亮部分进行膨胀，类似于领域扩张 腐蚀\n高亮部分被腐蚀，类似于领域被蚕食 开运算\n先腐蚀再膨胀，去掉目标外部的孤立点 闭运算\n先膨胀再腐蚀，去掉目标内部的孔 临域运算 卷积/滤波\n平滑均值滤波/卷积\n平滑中值滤波/卷积\n去除椒盐 平滑高斯滤波/卷积\n模拟人眼、延伸为金字塔 梯度 Prewitt 滤波/卷积\n梯度渐变 梯度 Sobel 滤波/卷积\n梯度渐变+另一方向高斯平滑 梯度 Laplacian 滤波/卷积\n团块检测、边缘检测、锐化 其他滤波/卷积\n金字塔\n高斯金字塔\n目的：得到一系列尺寸逐渐减小的图像 操作：先进行图像平滑（高斯滤波/卷积），再进行降采样 拉普拉斯金字塔\n目的：保留所有层所丢失的高频信息，用于图像恢复 操作：原图-高斯金字塔进行上采样 频率与处理 傅里叶变换 内容：一个信号可以由足够多个不同频率和幅值的正余弦波组成\n作用：信号分解\n欧拉公式（e^(ix) = cosx + isinx）描述的是一个随着时间变化，在复平面上做圆周运动的点；傅里叶变换描述的是一系列这样的点的运动叠加的效应\n离散傅里叶变换：∑[n=-∞, ∞]x(n)*e^(-iwn)\n二维傅里叶变换：f(u, v) = ∑[x=0,M-1] ∑[y=0, N-1] f(x, y)e^(-j2π(ux/M+vy/N))\n基于傅里叶变换的滤波\n低通滤波 相位滤波 频谱滤波 傅里叶变换的不足\n缺乏时间和频率的定位功能 对于非平稳信号的局限性 在时间和频率分辨率上的局限性 短时傅里叶变换（STFT）\n原理：设置窗格，对信号分段，认为窗格内的信号是平稳的 优点：可以获得频域信息的同时可以获得时域信息 缺点：窗格大小很难设置 小波变换 起源：将傅里叶变换的无限长的三角函数基换成了有限长的会衰减的小波基\n原理：将原始信号表示为一组小波基的线性组合，然后通过忽略其中不重要的部分达到数据压缩（即降维）的目的\n小波函数\n特点：1.均值为零 2.在时域和频域都局部化 常用小波函数\nHaar 系列\n方波/最简单 Daubechies 系列\nMoret 系列\nSym 系列\nMeyer 系列\nCoif 系列\n图像特征与描述 颜色特征 量化颜色直方图 适用颜色空间：RGB、HSV 等颜色空间 操作：颜色空间量化，单元（bin）由单元中心代表；统计落在量化单元上的像素数量 优势：计算高效 劣势：量化问题、稀疏 聚类颜色直方图 适用颜色空间：Lab 等颜色空间 操作：使用聚类算法对所有像素点颜色向量进行聚类；单元（bin）由聚类中心代表 优化 采用二次距离法 对颜色直方图事先进行平滑过滤，即每个 bin 中的像素对于相邻的几个 bin 也有贡献 几何特征 边缘(Edge) 定义：像素值函数快速变化的区域-\u0026gt;一阶导数的极值区域\n作用\n物体识别 视角变换 边缘提取\n高斯滤波 一阶导数获取极值 梯度（幅值/强度）增加最快 方向 边缘提取的尺度问题：不同标准差的滤波能捕捉到不同尺度的边缘\n特征点(Corner) 性质\n可重复性 显著性 抗图片变换（外貌变换/亮度、光照，几何变换/平移、选择、尺度） 作用\n图片配准/拼接 运动跟踪 物体识别 机器人导航 3D 重建 Harris 角点\n特点：在任何方向（实际为 x,y）上移动小观察窗，导致大的像素变动\n数学模型：E(u, v) = ∑[x, y]w(x, y)[ I(x+u, y+v) - I(x, y) ]²\n检测方法\n图像中直线：一个特征值大，另一个特征值小 图像中平面：两个特征值都小，且近似相等 图像中角点：两个特征值都大，且近似相等 Fast 角点\n特点：某像素与周围领域内足够多的像素点处于不同的区域，则为焦点或某些属性与众不同 检测方法：对兴趣点所在圆周上 16 个像素点进行判断，若当前中心像素暗或亮，则将其定为角点 缺点：无多尺度特征、没有方向信息、失去旋转的不变性 斑点(Blob) 拉普拉斯梯度：一阶导极值点-\u0026gt;二阶导数零点 缺点：对噪声很敏感 优化：高斯卷积滤波降噪处理，再采用 Laplace 算子进行边缘检测 斑点判断：高斯拉普拉斯滤波图找极值点-\u0026gt;斑点 基于关键点的特征描述子 SIFT 特点\n具有良好的不变性：对旋转、缩放、平移、亮度变化、噪声有一定程度的稳定性 独特性好，信息量能丰富：适用于在海量特征数据库中进行快速、准确的匹配 多量性：即使少数物体也可以产生大量 SIFT 特征 计算快：经过优化的 SIFT 匹配算法甚至可以达到实时性 计算步骤\n在 DoG 尺度空间中获取极值点/关键点：LoG 空间优化为 DoG 空间（差分高斯） 对关键点处理：1.位置插值（获得精确的关键点） 2.去除边缘点 关键点的方向估计 关键点的描述子的生成：1.区域坐标旋转 2.计算采样区域的直方图 具体实现\n构造高斯金字塔：对每一层用不同的参数 σ 做高斯模糊，使得每一层金字塔有多张高斯模糊图像，每一层的第一张图像是由上一层中倒数第三张图像降采样得到的\n计算高斯差分空间：相邻的图像进行差分形成差分金字塔\n判断极值点：以 ✗ 为检测点，除了大于同层所包围的 8 个点以外，还有上一层的 9 个点与下一层的 9 个点\nSIFT-特征点方向估计\n在尺度上计算梯度直方图：8 方向，以特征点为中心、以 3×1.5σ 为半径 获取最高值方向为关键点主方向 为匹配的稳定性，将超过最高值 80%的方向，做为辅方向 将原图像 x 轴转到与主方向相同的方向 在旋转后的坐标上采用 16×16 的像素窗计算梯度幅值和方向，4×4 分别计算得到 128 维特征向量 SURF Haar-like 特征\n分类\n边缘特征 线性特征 中心特征 对角线特征 特征模板：由以上特征组合而成\n特征模板的特征值：白色矩形像素和减去黑色矩形像素和\nHaar 特征值反映了图像的灰度变化情况\n优化内容\n把 SIFT 中的高斯二阶微分的模板简化，使得卷积平滑操作仅需要转换成加减运算 在方向确定阶段，在圆形区域计算 x，y 方向的 Haar 小波响应，找到模最大的扇形方向 特点\n使用 Hessian 矩阵变换图像，极值检测只需计算 Hesian 矩阵行列式（用一个简单方程求行列式近似值作为优化），使用盒状模糊滤波（特征模板）求高斯模糊近似值 SURF 不使用降采样，通过保持图像大小不变，但改变盒状滤波器的大小来构建尺度金字塔 在计算关键点主方向以及关键点周边像素方向的方法上，SURF 不使用直方图统计，而是使用哈尔(haar)小波转换，降至 64 维 ORB 理论基础：FAST 角点的特征点检测（缺乏尺度不变性）、BRIEF 特征描述技术（缺乏旋转不变性）\nBRIEF\n先平滑图像，然后在特征点周围选择一个 Patch，然后在这个 Patch 内通过一种选定的方法来挑选出来 n(d)个点对\n比较点对中两个像素的大小，进行如下赋值：τ(p; x, y)=p(x)\u0026lt;p(y) ? 1:0;\n所有 n(d)个点对，都进行比较，生成一个 n(d)长的二进制串\n点对的生成方式（共 5 种）\n1.X 和 Y 都服从在[-S/2, S/2]范围内的均匀分布，且相互独立 2.X 和 Y 都服从均值为 0，方差为 S²/25 的高斯分布，且相互独立，即 X 和 Y 都以原点为中心，进行同方差的高斯分布 点对的位置一旦选定，就不再更改/每一个关键点都以此为基础\nORB 对 BRIEF 的改进：以关键点和取点区域的形心（圆形）的连线为 X 轴建立坐标系，计算形心时，圆形区域上每个点的“质量”是其对应的像素值\n其他特征提取 LBP（局部二值模式） 具体实现\n将每个像素点与周围点大小比较：1.半径为 R 的圆上，均匀采样 P 个点 2.大小量化为 0 或 1 多个 bit 组成一个数，统计每个数的直方图 旋转不变性的解决方案：将得到的二进制数按位旋转，取最小的作为最终 LBP 值\n改进的 LBP：将 3×3 临域扩展到任意邻域，且用圆形临域代替正方形临域\nGabor 代码实现 pip install opencv-contrib-python\n深度学习之前的目标检测 图像分割 含义 根据灰度、颜色、纹理和形状等特征把图像划分成若干互不交叠的区域，并使这些特征在同一区域内呈现出相似性，而在不同区域内呈现出明显的差异性\n分割依据 灰度值的不连续性和相似性\n分类 基于阈值\n基于图像的灰度特征来计算一个或多个灰度阈值，并将图像中的每个像素的灰度值与阈值相比较，最后将像素根据比较结果分到合适的类别中/其实就是分类合并\n基于边缘\n根据图像局部特征不连续性进行分割\n基于区域\n将图像按照相似性准则分成不同的区域\n方法：种子区域生长法、区域分裂合并法、分水岭法\n基于图论\nGraph Cuts 分割\nGrab Cuts 分割\n人脸检测 Haar-like 特征 依据特征模板（15 种、不同位置、不同缩放）\n数量非常多\n级联分类器 理解：每次选取少量特征多次匹配所选要素\n含义：级联分类器就是将多个强分类器连接在一起进行操作\n每一个强分类器由若干个弱分类器加权组成\n行人检测 HOG+SVM HOG：方向梯度（矢量）直方图\n将整个图像进行 Gamma 空间、颜色空间归一化（减弱对比度与局部光照影响）\n梯度计算\n分别计算水平、垂直梯度\n对于彩色图，选取梯度幅值最大的通道\nBlock 拆分\n16×16 的 Bolck，步长为 8，50%重合\n包含 2×2 个 Cell\n每个 Cell 是 8×8\n计算 Cell 的梯度直方图\n9 个方向 bin（0-180）\n累计梯度幅值\n使用位置高斯加权\n相邻 bin 使用线性插值\n串联所有 Block 直方图\n64×128 图片：7×15Block、7×15×（2×2）×9=3780 维\n收集 HOG 特征\nSVM\n通过映射到超平面来完成样本分割 带约束条件的极值问题？？？ 松弛变量：防止因少量数据的融合或交叉而对结果产生的较大的影响 映射到高维空间解决线性不可分数据的问题 DPM（可变形的组件模型） 提取 DPM 特征图，将原图像进行高斯金字塔上采样（双线性插值），提取 DPM 特征图 对原图像的 DPM 特征图和训练好的 Root filter 做卷积操作，得到 Root filter 响应图 对于 2 倍图像的 DPM 特征图，和训练好的 Part filter 做卷积操作，从而得到 Part filter 的相应图 对精细高斯金字塔的下采样操作，这样 Root filter 的响应图和 Part filter 的响应图就具有相同的分辨率了 对其进行加权平均，得到最终的响应图。亮度越大表示响应值越大 神经网络与误差反向传播算法 神经网络 神经网络概述 神经网络：大量（结构简单的、功能接近的）神经元节点按一定体系架构连接成的网状结构——就是大脑的结构 神经网络的作用：分类、模式识别、连续值预测 建立输入与输出的映射关系 神经元 生物神经元：树突、轴突、细胞体\n人工神经元\n接收前一层传来的数据 将数据的加权和输入非线性作用函数中 输出结果传递至后一层 非线性函数：y = f(w^t * x) = f(∑[i=1, d]w(i)x(i)) 常见激活函数：f(x) = 1/(1 + e^-x)、f(x) = tanh(x) = (e^x - e^-x)/(e^x + e^-x) 人工神经网络 神经元\n输入向量 x 权重向量 w 偏置标量 b 激活函数 sigmoid 逻辑结构：输入-\u0026gt;输入层、隐含层（n）、输出层-\u0026gt;输出\n浅网络\n3~5 层 优化：梯度下降、BP 后向传播 “层”的理解\n“层”实现了输入空间到输出空间的线性或非线性变换 输入若干变量 通过改变权重的值提取不同的特征 提取特征个数：下一层节点数决定了想要获得多少种不同的新特征 类比：C、O 原子 前馈神经 单项多层结构：有向无环图、同层神经元之间没有连接\nDelta 学习规则\n一种有监督的学习算法，该算法根据神经元的实际输出与期望输出差别来调整连接权\n公式表示：△w(ij) = a*(d(i) - y(i))*x(j)\n△w(ij) 表示神经元 j 到神经元 i 的连接权重增量 d(i) 是神经元 i 的期望输出 y(i) 是神经元 i 的实际输出 x(j) 表示神经元 j 的状态 a 是表示学习速度的常数 前馈神经网络的目标函数（降到最小）\n对一系列训练样本 X，期望输出 T = (t1, t2……tn)，网络实际输出 Z = (z1, z2……zn) 目标函数：J(w) = 1/2 × ||t - z||² = 1/2 × ∑[k=1, c](t(k) - z(k))² //各输出误差的平方的累加 梯度下降 通过 w 向量的变化，逐步找到目标函数的最小值/瞎子下山：方向（梯度方向）、步长（学习速率）、平地（迭代）、悬崖（不可导） 误差反向传播 寻找一个函数将输入的向量映射到一个准确的输出值上。具体的寻找过程就是寻找合适的神经网络参数的过程。也就是缩小神经网络输出和事实所预计输出的过程。训练时随机初始化神经网络中的参数，这样的参数一定会带来较大的误差，就根据得到的误差来调整神经网络的参数。\n视频及课件 链接,提取码：2ff8\n","date":"2021-03-03T20:06:10Z","image":"https://static.aecra.cn/cover/computer-vision-target-detection.jpg","permalink":"https://aecra.github.io/article/computer-vision-target-detection/","title":"计算机视觉-目标检测"},{"content":"百度百科 对一个有向无环图(Directed Acyclic Graph 简称 DAG)G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边(u,v)∈E(G)，则 u 在线性序列中出现在 v 之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。\n理解 就是将一个有向无环图的节点按着图的方向排序，也就是一个图上的边的两个顶点若为 u-\u0026gt;v，则排序时 u 必须在 v 前面。\n由此可以看出一个图的拓扑排序可能不止一种，可以自己举例试一下，加深理解。\n实现方法 图的存储可以零用邻接矩阵或是邻接表，排序时，定义两个队列（queue）q1，q2，先遍历一次所有的节点求出各节点的入度，并找到入度为 0 的节点（即没有边指向的节点），将其放入 q1 中，接下来依次取出 q1 中的点，将其放入 q2 中，若该点有指向的点，将被指向的点入读减 1，若入度为零，则将其放入 q1 中，直至 q1 为空队列。\n代码示例 queue\u0026lt;int\u0026gt; q; //priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt;q; //优先队列的话，会按照数值大小有顺序的输出 //此处为了理解，暂时就用简单队列 inttopo() { for (inti = 1; i \u0026lt;= n; i++) { if (indegree[i] 0) { q.push(i); } } int temp; while (!q.empty()) { temp = q.front(); //如果是优先队列，这里可以是top() printf(\u0026#34;%d-\u0026gt;\u0026#34;, temp); q.pop(); for (inti = 1; i \u0026lt;= n; i++) //遍历从temp出发的每一条边，入度-- { if (maptemp) { indegree[i]--; if (indegree[i] 0) q.push(i); } } } } ","date":"2021-02-28T13:14:08Z","image":"https://static.aecra.cn/cover/topological-sorting.jpg","permalink":"https://aecra.github.io/article/topological-sorting/","title":"拓扑排序"},{"content":"介绍 有权边的图的存储一般有两种：邻接矩阵、前向星。\n若图是稀疏图，边很少，开二维数组 a[][]很浪费;若点很多(如 10000 个点)a[10000][10000]又会爆.只能用前向星做。\n前向星的效率不是很高（要将边的起点或终点进行排序），优化后为链式前向星，效率有所提升。\n数据结构 1 结构体数组 edge 存边，edge[i]表示第 i 条边，\n2 head[i]存以 i 为起点的第一条边(在 edge 中的下标)\n增边方法 增边：若以点 i 为起点的边新增了一条，在 edge 中的下标为。\n那么 edge[j].next=head[i]；然后 head[i]=j。\n即每次新加的边作为从该起点出发的第一条边，最后倒序遍历（即 edge[j].next 用来记录以该点为起点的下一条边在 edge 中的下标，用于遍历）\n代码示例 #include \u0026lt;iostream\u0026gt; using namespace std; #define MAXM 500010 #define MAXN 10010 struct EDGE { int next; //与该边同起点的下一条边的存储下标 int to; //这条边的终点 int w; //权值 }; EDGE edge[MAXM]; int n, m, cnt; int head[MAXN]; //head[i]表示以i为起点的第一条边 void Add(int u, int v, int w) { //起点u, 终点v, 权值w edge[++cnt].next = head[u]; edge[cnt].w = w; edge[cnt].to = v; head[u] = cnt; //第一条边为当前边 } void Print() { int st; cout \u0026lt;\u0026lt; \u0026#34;Begin with[Please Input]: \u0026#34;; cin \u0026gt;\u0026gt; st; for (int i = head[st]; i != 0; i = edge[i].next) { //i开始为第一条边，每次指向下一条(以0为结束标志)若下标从0开始，next应初始化-1 cout \u0026lt;\u0026lt; \u0026#34;Start: \u0026#34; \u0026lt;\u0026lt; st \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;End: \u0026#34; \u0026lt;\u0026lt; edge[i].to \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;W: \u0026#34; \u0026lt;\u0026lt; edge[i].w \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } } int main() { int s, t, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; w; Add(s, t, w); } Print(); return 0; } ","date":"2021-02-26T18:59:07Z","image":"https://static.aecra.cn/cover/chain-forward-star.jpg","permalink":"https://aecra.github.io/article/chain-forward-star/","title":"链式前向星"},{"content":"巴什（Bash）博弈 题目： 只有一堆 n 个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取 m 个。最后取光者得胜。问是否存在先手必胜的策略。\n首先引入 N（先手必胜）状态和 P（先手必败）状态的概念。\n什么是 N（先手必胜）状态？如果我能使对方的状态为 P（先手必败）状态，那么我当前的状态不就是 N（先手必胜）状态了吗？\n对于本题，可以从简单的状态入手，当石子数为 0 时为一个 P 状态，则石子数为 [1,m] 时是 N 状态，因为总可以一次拿完。而石子数为 m+1 时，先手无论如何操作，后手总可以拿完剩下的石子，故是一个 P 状态。继续向前推发现，当石子数为 m+1 的倍数时，与上述情况是相同的，先手必败；否则，先手总可以让后手处于上述状态，后手必败。\n尼姆（Nimm）博弈 题目：两个人玩游戏，有 n 堆物品，每次操作可以选一堆物品去拿，最少拿一个，无物品可取者为负。问是否存在先手必胜的策略。\n那我们就来总结一下简单的 P（先手必败）状态：\n1.每个堆的物品数都为 0 //根本就没有物品取\n2.有两个堆且两个堆的物品数相同 //如果我取其中的一个堆，对方就对另一个堆进行相同的操作，怎样都是我去面对状态 1 //貌似干掉了威佐夫（Wythoff）博弈\n对上面状态 1 进行分析可知，只有一个堆的时候，我就能使对方必败，对状态 2 进行分析，如果有两个堆且物品数目不等，我就能让他们相等，我就必胜。\n再对状态 2 分析，将两个堆推广到 2*n 个堆，且每个堆都有与其相同的堆，那么这种状态依旧是 P（先手必败）状态。\n再进一步推广，一个结论就是亦或和值为零则后手胜，否则先手胜\n对于上面分析的状态，毫无疑问满足这个结论，但一般性地来讲是否符合呢？而又怎样理解呢？\n先说思考方向：枪打出头鸟\n如果有成对相同的堆那就无需考虑，因为对手的操作，我完全可以复制过来形成状态 2，而这种成对亦或为 0，对结果没影响，可以剔除掉进行一下讨论\n此时将思维从十进制转换成二进制，将所有的数目看成二进制，且思维不要停留在单独的堆上（因为是亦或运算啊）\n设 k=a[1]^a[2]^a[3]^\u0026hellip;^a[n]。\n如果 k==0，说明没有特立独行的位数，\n（：哎，刚才不是堆吗？怎么开始看位数了？参考系都不一样了啊？\n那我们想一下，如果 k!=0，说明存在一个 1 在最高位，那我们就可以对有这个最高位的堆进行操作去让其他的位（不管是什么，最高位都比他们大啊）不再特立独行。\n（：不对啊？怎么又跑到特立独行的位数了啊？\n我不是先证明如果 k!=0 时，情况反转吗？\n（：那你凭什么保证 k==0 时必输这个结论正确啊？\n接下来思考一下，如果我随便取了，k 是不是就不等于 0 了？因为相当于亦或了我刚才的操作数，而我不可能不取物品滴\n而这种规则下，我如果总是可以保证 k==0 时不是我面对的状态，我就能去抵消对手的操作而使结果变为 k==0，最后，是对手面对的 0，\n（：？？？？？\n可以看作是打地鼠，只要 k 中有 1 冒出来，我就去消灭，如此，反正我不是最后遇到零的，管他还有多少堆，堆中有多少个呢\n","date":"2021-02-25T14:35:42Z","image":"https://static.aecra.cn/cover/bash-game-and-nimm-game.jpg","permalink":"https://aecra.github.io/article/bash-game-and-nimm-game/","title":"巴什（Bash）博弈和尼姆（Nimm）博弈"},{"content":"想法与思路 在一月底二月初写了一份博客代码，然后在两天前接触了 Hexo 这个静态博客生成器，悲剧地发现还是这个简单快捷。转为 Hexo 之后原博客代码要想不荒废那不是得每更一篇文就要去博客后台提交文章？而且有的文章小毛病一大堆可能要三天两头地修改，就这繁杂的工作能把我折腾地放弃写博客。\n从一贯的删繁就简的思路来看，用 python 这种简单的语言来干这种事情那是最好的了。\npython 同步数据库内容 知识储备 语言要求：\nMySQL python 用到的 python 模块\nfrontmatter pymysql os 原数据库格式 create table usertb( id int primary key auto_increment, username varchar(20) unique not null, pass_word varchar(40) not null, email varchar(50), portrait varchar(200) ); create table articletb( id int primary key auto_increment, title varchar(100) not null, img_url varchar(200) default \u0026#34;https://static.aecra.cn/aecra.png\u0026#34; not null, content text not null, publish_time timestamp not null default \u0026#34;2021-01-01 00:00:00\u0026#34;, update_time timestamp not null default \u0026#34;2021-01-01 00:00:00\u0026#34;, hided int default 0 not null, toped int default 0 not null, clicks int default 0, userid int default 1 not null, foreign key(userid) references usertb(id) ); create table tagstb( id int primary key auto_increment, tagname varchar(15) not null ); create table tagmaptb( id int primary key auto_increment, tagid int, articleid int, foreign key(tagid) references tagstb(id), foreign key(articleid) references articletb(id), unique(tagid,articleid) ); 导入 python 模块 import frontmatter import pymysql import os 初始化设置 # config post_folder = \u0026#39;./hexo/source/_posts/\u0026#39; database = { \u0026#39;host\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;user\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;passwd\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;db\u0026#39;: \u0026#39;\u0026#39; } 读取文章内容 # 读取所有的文章的内容 print(\u0026#34;读取文章内容......\u0026#34;) posts = os.listdir(post_folder) article_data = [] for post in posts: f = open(post_folder + post, encoding=\u0026#39;utf-8-sig\u0026#39;) item = frontmatter.loads(f.read()) article = { \u0026#39;title\u0026#39;: item[\u0026#39;title\u0026#39;], \u0026#39;date\u0026#39;: item[\u0026#39;date\u0026#39;], \u0026#39;tags\u0026#39;: item[\u0026#39;tags\u0026#39;], \u0026#39;cover\u0026#39;: item[\u0026#39;cover\u0026#39;], \u0026#39;content\u0026#39;: item.content } article_data.append(article) article_data = sorted(article_data, key=lambda article: article[\u0026#39;date\u0026#39;]) print(\u0026#34;已读取文章内容\u0026#34;) 连接数据库，进行数据库操作 # 连接数据库，进行数据库操作 print(\u0026#39;连接数据库......\u0026#39;) conn = pymysql.connect( host=database[\u0026#39;host\u0026#39;], user=database[\u0026#39;user\u0026#39;], passwd=database[\u0026#39;passwd\u0026#39;], db=database[\u0026#39;db\u0026#39;], charset=\u0026#39;utf8\u0026#39;) cursor = conn.cursor() print(\u0026#39;已连接数据库\u0026#39;) 删除原有文章数据 # 删除原有文章数据 print(\u0026#39;清空数据库......\u0026#39;) cursor.execute(\u0026#39;truncate table tagmaptb\u0026#39;) cursor.execute(\u0026#39;truncate table tagstb\u0026#39;) cursor.execute(\u0026#39;truncate table articletb\u0026#39;) print(\u0026#39;已清空数据库\u0026#39;) 向数据库中添加数据 # 向数据库中添加数据 print(\u0026#39;正在向数据库中添加文章......\u0026#39;) i = 0 for article in article_data: i = i + 1 # 添加文章 sql = (\u0026#39;INSERT INTO articletb \u0026#39; \u0026#39;(title,img_url,content,publish_time,update_time,userid) \u0026#39; \u0026#39;VALUES(%s,%s,%s,%s,%s,1)\u0026#39;) cursor.execute(sql, [article[\u0026#39;title\u0026#39;], article[\u0026#39;cover\u0026#39;], article[\u0026#39;content\u0026#39;], article[\u0026#39;date\u0026#39;], article[\u0026#39;date\u0026#39;]]) # 获取文章id article_id = cursor.lastrowid # 建立文章和标签的链接 for tag in article[\u0026#39;tags\u0026#39;]: # 标签不存在就插入标签 res = cursor.execute(\u0026#39;select * from tagstb where tagname=%s\u0026#39;, [tag]) if res == 0: cursor.execute(\u0026#39;insert into tagstb(tagname) values(%s)\u0026#39;, [tag]) # 获取标签id cursor.execute(\u0026#39;select * from tagstb where tagname=%s\u0026#39;, [tag]) tag_id = cursor.fetchone()[0] # 向映射表中插入数据 cursor.execute(\u0026#39;insert into tagmaptb(tagid,articleid) values(%s,%s)\u0026#39;, [ tag_id, article_id]) print(\u0026#39;(\u0026#39;, i, \u0026#39;/\u0026#39;, len(article_data), \u0026#39;) 已添加：\u0026#39;, article[\u0026#39;title\u0026#39;]) print(\u0026#39;添加完成\u0026#39;) 关闭数据库 # 关闭数据库 print(\u0026#39;关闭数据库......\u0026#39;) cursor.close() conn.close() print(\u0026#39;已关闭数据库\u0026#39;) 遇到的问题 从 python-frontmatter 可以看到 frontmatter 是支持 frontmatter.load 的，但是在我应用的过程中发现有一个文件无论怎样更改都无法让 frontmatter 正常工作，而在打印 content 之后发现 front matter 的内容在 content 中，而且在这之前有一个乱码的字符，于是去到 GitHub 上 frontmatter 的 issue 中寻找答案。\n在 issue 中我们可以发现是编码问题，于是乎，只能通过设置编码为 utf-8-sig 来解决问题。\nsorted() 函数不改变原有的数组，需要写成 o = sorted(o) 的形式。\n缺点 因为代码的复杂度问题，没有对文章地址，同时也就是 id 做永久性处理，在这样的处理方案下，如若某一天有文章增加或删除都会对其后的文章地址产生影响，在严格的思路下该处理方式存在问题，如果以后有时间再修正该问题。\n因为是重新生成，所以原文章的点击量无法保存。\n因为在 hexo 中只有 date 一项，所以发布时间和修改时间只能设置成统一的。\n又因为 hexo 中没有置顶和隐藏选项，所以该功能同样被架空，置顶的问题还是需要通过博客后台来设置。\n","date":"2021-02-22T18:57:38Z","image":"https://static.aecra.cn/cover/what-about-the-original-blog-after-using-hexo.jpg","permalink":"https://aecra.github.io/article/what-about-the-original-blog-after-using-hexo/","title":"使用 Hexo 之后原有博客怎么办？"},{"content":"Vercel 是什么 如果你曾听说过 ZEIT Now，是的，它是 Vercel 的前身。在去年早些时候，ZEIT Now 进行了「品牌升级」，成为了现在的 Vercel。\n注册与安装 首先，在 Vercel 官网注册一个新账户。现在，注册新用户必须使用 Github、Gitlab 或者 Bitbucket 的账户进行授权，并绑定手机号。注册完成后，可以在配置页面修改自己的邮箱地址。\nVercel 的大部分功能都通过命令行来操作。Vercel 的客户端工具下载地址。\n这个命令行工具是使用 Node.js 编写的，因此使用 npm 安装，也因此同时支持 Windows、macOS 和 Linux 操作系统。如果你没有安装过 Node.js 环境，需要先安装 Node.js。之后，可以在 Windows 的 Powershell 或者 macOS 的终端中运行下述命令安装 Vercel：\nnpm i -g vercel 成功安装后，运行下述命令登录账户：\nvc login 这里，vc 是 Vercel 的缩写，你也可以使用完整版的 vercel 来执行。\nVercel 的登录很有意思，因为我们自始至终没有设置过账户密码，它是通过向你邮箱发送一封邮件确认。在邮件中，甚至还有一个和你约定的「暗号」，作为彼此的凭证。\n绑定域名 如果你拥有你自己的域名，或者你拥有多个域名，我十分推荐把它们全部绑定到 Vercel 进行管理。\n把域名绑定到 Vercel 时，只需要执行：\nvc domains add 域名 然后在你的域名解析服务商处添加解析即可。\nhexo + vercel 搭建博客 如果你喜爱写作、喜爱分享，那你一定想过要有一个自己的博客。除了使用类似新浪博客、CSDN 等博客服务之外，许多人也会尝试自己搭建一个「独立博客」。\n我以知名的静态博客系统 Hexo 为例。使用 Hexo 写作后，执行 hexo 的命令生成网站的静态文件：\nhexo g 这时，会产生一个 public 的文件夹。\n继续执行 Vercel 的命令：\nvc 是的，这次不需要跟其他命令，只需要简单的 vc 即可。\n接下来会出现交互式的配置菜单，需要你依次选择：\nVercel CLI 19.2.0 ? Set up and deploy “~/Documents/workspace/blog”? [Y/n] y ? Which scope do you want to deploy to? sanko.sspai ? Link to existing project? [y/N] n ? What’s your project’s name? blog ? In which directory is your code located? ./public ? Want to override the settings? [y/N] n 在第一次部署时，只有倒数第二个问题「In which directory is your code located?」要手动输入 public ，其他问题全部可以直接敲击回车键选择默认配置。\n现在，网站已经成功运行起来了。你可以直接去浏览器按下「Ctrl+V」粘贴，即可访问你的新博客。\n值得注意的是，这个网站支持 HTTPS 访问。Vercel 会自动为我们申请一个 Let\u0026rsquo;s Encrypt 的证书，并为我们自动续期。而如果这一切由我们自己来完成，则需要：\n购买域名 购买服务器 安装与配置 Nginx 上传网站文件 添加 DNS 解析项 配置 Let\u0026rsquo;s Encrypt 的证书 每三个月续期证书 相比之下，使用 Vercel 确实省心不少，还省下了购买域名和服务器的费用。\n要更新文章的时候，只需要执行：\nvc --prod 文章就会更新到之前的网址中。\nhexo + github + vercel 搭建博客 和上面的方式不同的是该方案需要用到 GitHub 来管理我们的网站源码，同时不再需要使用 vercel 工具。\nhexo 和 GitHub 的使用请见上一篇文章。注：并不需要部署 GitHub 的静态网站。\nOK，我们已经过完了上一篇文章，接下来我们就要用 vercel 来部署我们的网站了。\n第一步：进入 vercel 的控制台，点击 New Project。\n第二步：授权 GitHub 并 Import 上文所设置的 GitHub 仓库。\n第三步：选择自己的账户。\n第四步： Continue。\n第五步：设置相关信息并 Deploy，看不明白默认即可。\n第六步：进入项目页点击 Settings -\u0026gt; Domains，然后添加域名，设置域名解析。\n然后等一会儿之后，我们访问添加的域名就可以访问到我们的博客了。而且这个项目只需要更改 GitHub 仓库，Vercel 会在仓库变更之后重新加载网站。\n更上一层楼 通过上面那一步是不是发现 Vercel 本身就可以为我们编译项目？而且支持的项目种类非常多，所以我们可以直接把各种项目提交到 GitHub 仓库，然后设置 Vercel，这样就不需要本地跑程序去编译工程了。\n而且 Vercel 支持可执行程序，除了没有数据库之外这妥妥的完美解决方案啊，又不需要备案，真香！\n限制 这么好的事情有没有限制嘞？\n当然有，只不过对于个人博客这种小项目，完全不需要担心被限制，据说是每月 100G 流量，当然，短时间大流量肯定是要出问题的。\n项目数目有没有限制不清楚，可以去试一下。\n","date":"2021-02-22T00:08:23Z","image":"https://static.aecra.cn/cover/deployment-blog-used-by-vercel.jpg","permalink":"https://aecra.github.io/article/deployment-blog-used-by-vercel/","title":"Vercel 使用之部署博客"},{"content":"准备环境 安装 Git sudo apt install git-core -y 安装 Node.js 使用以下命令安装 Node.js\nwget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 更新一下\nsource ~/.profile 安装 Node.js\nnvm install stable 安装 Hexo 安装 cnpm 使用以下命令安装 cnpm\nnpm install -g cnpm --registry=https://registry.npm.taobao.org 安装 hexo-cli 用命令创建 hexo 文件夹 mkdir hexo 用命令安装 hexo cnpm install -g hexo-cli 初始化 hexo cd hexo/ hexo init 测试安装成功 打开 hexo 服务\nhexo server 打开浏览器访问 http://localhost:4000/ 即可看到搭建成功的博客页面\n将博客部署到 GitHub 如果没有 GitHub 账户的先去注册，有 GitHub 账户的直接下一步 去注册 GitHub 账户\n设置 user.name 和 user.email 把以下命令中的 \u0026ldquo;Your user.name\u0026rdquo; 和 \u0026ldquo;You user.email\u0026rdquo; 换成自己的\ngit config --global user.name \u0026#34;Your user.name\u0026#34; git config --global user.email \u0026#34;You user.email\u0026#34; 生成 ssh 密匙 user.email 就是自己注册 GitHub 的邮箱\nssh-keygen -t rsa -C user.email 下面要输入要保存到的路径（Windows 为用户目录）\n/home/ubuntu/.ssh/id_rsa 然后直接回车回车\n查看 ssh 密匙 打开\nid_rsa.pub 在 GitHub 账户下添加 SSH key 去 GitHub 添加 SSH key\n创建 GitHub 仓库 命名格式为\u0026quot;账户的 userName\u0026quot;.github.io 例如 ： zhangsan.github.io 去创建 GitHub 仓库\n修改 hexo 配置 打开 hexo 配置文件\n_config.yml 修改对应部分\ndeploy: type: git repo: git@github.com:(BoView)/(BoView).github.io.git #括号里面换成自己的用户名和仓库名,去掉括号 branch: master 保存一下\n测试并部署 清空静态页面\nhexo clean 生成静态页面\nhexo g 将 public 文件内容部署到 github 仓库\nhexo d 如果部署遇到错误的时候，先运行下面这条命令\nnpm install hexo-deployer-git --save 然后重新部署一下\nhexo d 此时可以打开浏览器访问 userName.github.io (GitHub 仓库名) 即可以访问到搭建的博客页面\n绑定域名 添加解析记录 如果想通过域名访问的就继续，前提是要有自己的域名，要是通过上面的仓库名可以访问就满足的可以跳过这一步 去自己的域名下添加解析记录类型为 CNAME 主机记录为@ 线路选择默认，TTL 选择 600，记录值为 github 的仓库名 userName.github.io 配置 hexo 创建 CNAME 配置文件\ntouch ~/hexo/source/CNAME 去 CNAME 文件 下添加刚才解析的域名 例如： zhangsan.com\n然后重新部署一下\nhexo g hexo d Hexo 博客已搭建完成 可将 markdown 文件放置到 ./source/_posts/ 中即可部署自己的文章页面\n另外，可以在文件夹 themes 中添加博客主题，然后修改 _config.yml 文件中的 theme 为主题文件夹名，即可使用新的主题部署自己的博客\n更多的博客主题见 点击\n","date":"2021-02-21T23:51:38Z","image":"https://static.aecra.cn/cover/quickly-build-hexo-personal-blog-and-deploy-it-to-github.jpg","permalink":"https://aecra.github.io/article/quickly-build-hexo-personal-blog-and-deploy-it-to-github/","title":"快速搭建 Hexo 个人博客并部署至 GitHub"},{"content":"JavaScript 负责页面中的的行为。\n它是一门运行在浏览器端的脚本语言。\n基础内容 JS 的编写的位置 1.可以编写到标签的指定属性中\n\u0026lt;button onclick=\u0026#34;alert(\u0026#39;hello\u0026#39;);\u0026#34;\u0026gt;我是按钮\u0026lt;/button\u0026gt; \u0026lt;a href=\u0026#34;javascript:alert(\u0026#39;aaa\u0026#39;);\u0026#34;\u0026gt;超链接\u0026lt;/a\u0026gt; 2.可以编写到 script 标签中\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //编写js代码 \u0026lt;/script\u0026gt; 3.可以将代码编写到外部的 js 文件中，然后通过标签将其引入\nscript 标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 ,如果需要则可以在创建一个新的 script 标签用于编写内部代码\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;文件路径\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 输出语句 alert(\u0026#39;要输出的内容\u0026#39;); 该语句会在浏览器窗口中弹出一个警告框\ndocument.write(\u0026#39;要输出的内容\u0026#39;); 该内容将会被写到 body 标签中，并在页面中显示\nconsole.log(\u0026#39;要输出的内容\u0026#39;); 该内容会被写到开发者工具的控制台中\n基本的语法 js 函数声明不需要；分号，但是赋值语句要加；分号\nfunction functionName(arg0, arg1, arg2) { //函数声明 } var functionName = function (arg0, arg1, arg2) { //函数表达式 }; 注意分号; 注释\n单行注释\n//注释内容 多行注释\n/* 注释内容 */ JS 严格区分大小写\nJS 中每条语句以分号(;)结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写\nJS 中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。\n字面量和变量 字面量：\n字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN \u0026ldquo;hello\u0026rdquo;，字面量都是不可以改变的。\n由于字面量不是很方便使用，所以在 JS 中很少直接使用字面量\n变量：\n变量可以用来保存字面量，并且可以保存任意的字面量\n一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述\n声明变量\n使用 var 关键字来声明一个变量\nvar a; 为变量赋值\na = 1; 声明和赋值同时进行\nvar a = 456; 标识符 在 JS 中所有的可以自主命名的内容，都可以认为是一个标识符，是标识符就应该遵守标识符的规范。\n比如：变量名、函数名、属性名\n规范：\n标识符中可以含有字母、数字、_、$ 标识符不能以数字开头 标识符不能是 JS 中的关键字和保留字 标识符一般采用驼峰命名法：xxxYyyZzz 数据类型 String 字符串 JS 中的字符串需要使用引号引起来双引号或单引号都行\n在字符串中使用\\作为转义字符\n\\\u0026#39; ==\u0026gt; \u0026#39; \\\u0026#34; ==\u0026gt; \u0026#34; \\n ==\u0026gt; 换行 \\t ==\u0026gt; 制表符 \\\\ ==\u0026gt; \\ 使用 typeof 运算符检查字符串时，会返回\u0026quot;string\u0026quot;\nNumber 数值 JS 中所有的整数和浮点数都是 Number 类型\n最大能表示的值：Number.MAX_VALUE=1.7976931348623157e+308\n特殊的数字：能赋值给变量\nInfinity 正无穷 a = Infinity ,能赋值\nInfinity 负无穷\nNaN 非法数字（Not A Number）\n其他进制的数字的表示：\n0b 开头表示二进制，但是不是所有的浏览器都支持\n0 开头表示八进制\n0x 开头表示十六进制\n使用 typeof 检查一个 Number 类型的数据时，会返回\u0026quot;number\u0026quot;（包括 NaN 和 Infinity）\nBoolean 布尔值 布尔值主要用来进行逻辑判断，布尔值只有两个\ntrue 逻辑的真\nfalse 逻辑的假\n使用 typeof 检查一个布尔值时，会返回\u0026quot;boolean\u0026quot;\nNull 空值 空值专门用来表示为空的对象，Null 类型的值只有一个 null\n使用 typeof 检查一个 Null 类型的值时会返回\u0026quot;object\u0026quot;\nUndefined 未定义 如果声明一个变量但是没有为变量赋值此时变量的值就是 undefined\n该类型的值只有一个 undefined\n使用 typeof 检查一个 Undefined 类型的值时，会返回\u0026quot;undefined\u0026quot;\n引用数据类型 Object 对象\n类型转换 类型转换就是指将其他的数据类型，转换为 String Number 或 Boolean\n转换为 String toString()方法 强制类型转换\nvar a = 123; a = a.toString(); // 注意：这个方法不适用于null和undefined // 由于这两个类型的数据中没有方法，所以调用toString()时会报错 String()函数 强制类型转换\nvar a = 123; a = String(a); // 对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串\u0026#34;null\u0026#34;。对于undefined直接转换为字符串\u0026#34;undefined\u0026#34; 为任意的数据类型 + \u0026quot;\u0026quot; 隐式类型转换\nvar a = true; a = a + \u0026#39;\u0026#39;; 原理：和 String()函数一样\n转换为 Number Number()函数 强制类型转换\nvar s = \u0026#39;123\u0026#39;; s = Number(s); 转换的情况\n字符串 \u0026gt; 数字\n如果字符串是一个合法的数字，则直接转换为对应的数字\n如果字符串是一个非法的数字，则转换为 NaN\n如果是一个空串或纯空格的字符串，则转换为 0\n布尔值 \u0026gt; 数字\ntrue 转换为 1\nfalse 转换为 0\n空值 \u0026gt; 数字\nnull 转换为 0\n未定义 \u0026gt; 数字\nundefined 转换为 NaN\nparseInt()或 parseFloat() 强制类型转换\n如果对非 String 使用 parseInt()或 parseFloat()，它会先将其转换为 String然后在操作\nvar a = \u0026#39;123.456px\u0026#39;; a = parseInt(a); //123 var b = \u0026#39;123.456px\u0026#39;; b = parseFloat(b); //123.456 使用一元的+ 隐式类型转换\nvar a = \u0026#39;123\u0026#39;; a = +a; 原理：和 Number()函数一样\n转换为布尔值 Boolean()函数 强制类型转换\nvar s = \u0026#39;false\u0026#39;; s = Boolean(s); //true 转换情况\n字符串 \u0026gt; 布尔\n除了空串其余全是 true\n数值 \u0026gt; 布尔\n除了 0 和 NaN 其余的全是 true\nnull、undefined \u0026gt; 布尔\n都是 false\n对象 \u0026gt; 布尔\n都是 true\n两次非运算 隐式类型转换\nvar a = \u0026#39;hello\u0026#39;; a = !!a; //true 基础语法 运算符 运算符也称为操作符\n通过运算符可以对一个或多个值进行运算或操作\ntypeof 运算符 用来检查一个变量的数据类型\n语法：typeof 变量\n它会返回一个用于描述类型的字符串作为结果\n算数运算符 + 对两个值进行加法运算并返回结果\n- 对两个值进行减法运算并返回结果\n* 对两个值进行乘法运算并返回结果\n/ 对两个值进行除法运算并返回结果\n% 对两个值进行取余运算并返回结果\n除了加法以外，对非 Number 类型的值进行运算时，都会先转换为 Number 然后在做运算。\n而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。\n任何值和字符串做加法，都会先转换为字符串，然后再拼串\n一元运算符 一元的+\n就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字\nvar a = true; a = +a; 一元的-\n就是负号，可以对一个数字进行符号位取反\nvar a = 10; a = -a; 自增\n自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1 不同的是++a和a++的值是不同的 ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减\n自减可以使变量在原值的基础上自减1 自减使用 -- 自减可以使用 前（--a）后(a--) 无论是a 还是 a都会立即使原变量自减1 不同的是--a和a++的值是不同的 --a的值是变量的新值（自减后的值） a++的值是变量的原值（自减前的值） 逻辑运算符 !\n非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 \u0026amp;\u0026amp;\n\u0026amp;\u0026amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为false，则返回第一个值 2.如果第一个值为true，则返回第二个值 ||\n||可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为true，则返回第一个值 2.如果第一个值为false，则返回第二个值 赋值运算符 =\n可以将符号右侧的值赋值给左侧变量\n+=\na += 5; // 相当于 a = a+5 var str = \u0026#39;hello\u0026#39;; str += \u0026#39;world\u0026#39;; -=\na -= 5; // 相当于 a = a-5 *=\na *= 5; // 相当于 a = a*5 /=\na /= 5; // 相当于 a = a/5 %=\na %= 5; // 相当于 a = a%5 关系运算符 关系运算符用来比较两个值之间的大小关系的\n\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=\n关系运算符的规则和数学中一致，用来比较两个值之间的关系\n如果关系成立则返回 true，关系不成立则返回 false。\n如果比较的两个值是非数值，会将其转换为 Number 然后再比较。\n如果比较的两个值都是字符串，此时会比较字符串的 Unicode 编码，而不会转换为 Number。\n相等运算符 相等，判断左右两个值是否相等，如果相等返回 true，如果不等返回 false\n相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回 true，null == undifined\n!=\n不等，判断左右两个值是否不等，如果不等则返回 true，如果相等则返回 false，不等也会做自动的类型转换。\n===\n全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，如果两个值的类型不同，则直接返回 false\n!==\n不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回 true\n特殊的值：\nnull 和 undefined 由于 undefined 衍生自 null，所以null == undefined 会返回 true，但是 null === undefined 会返回 false。\nNaN\nNaN 不与任何值相等，包括它自身 NaN == NaN //false\n判断一个值是否是 NaN 使用 isNaN()函数\n三元运算符 ?: 语法：条件表达式?语句 1:语句 2;\n执行流程：\n先对条件表达式求值判断\n如果判断结果为 true，则执行语句 1，并返回执行结果 果判断结果为 false，则执行语句 2，并返回执行结果 优先级：\n和数学中一样，JS 中的运算符也是具有优先级的，比如 先乘除 后加减 先与 后或\n具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高，优先级越高的越优先计算，优先级相同的，从左往右计算。优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。\n流程控制语句 程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。\n条件判断和分支语句 if 判断语句 语法一\nif(条件表达式){ 语句... } 执行流程：\nif 语句执行时，会先对条件表达式进行求值判断\n如果值为 true，则执行 if 后的语句\n如果值为 false，则不执行\n语法二\nif(条件表达式){ 语句... }else{ 语句... } 执行流程：\nif\u0026hellip;else 语句执行时，会对条件表达式进行求值判断\n如果值为 true，则执行 if 后的语句\n如果值为 false，则执行 else 后的语句\n语法三\nif(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else{ 语句... } 执行流程\nif\u0026hellip;else if\u0026hellip;else 语句执行时，会自上至下依次对条件表达式进行求值判断，\n如果判断结果为 true，则执行当前 if 后的语句，执行完成后语句结束。\n如果判断结果为 false，则继续向下判断，直到找到为 true 的为止。\n如果所有的条件表达式都是 false，则执行 else 后的语句\n条件分支语句 switch 语句\nswitch(条件表达式){ case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; } 执行流程：\nswitch\u0026hellip;case\u0026hellip;语句在执行时，会依次将 case 后的表达式的值和 switch 后的表达式的值进行全等比较，\n如果比较结果为 false，则继续向下比较。如果比较结果为 true，则从当前 case 处开始向下执行代码。\n如果所有的 case 判断结果都为 false，则从 default 处开始执行代码。\n循环语句 通过循环语句可以反复执行某些语句多次\nwhile 循环：\nwhile(条件表达式){ 语句... } 执行流程： while 语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为 false，则终止循环 如果判断结果为 true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推\ndo\u0026hellip;while 循环：\ndo{ 语句... }while(条件表达式) 执行流程\ndo\u0026hellip;while 在执行时，会先执行 do 后的循环体，然后在对条件表达式进行判断，\n如果判断判断结果为 false，则终止循环。\n如果判断结果为 true，则继续执行循环体，依此类推\n和 while 的区别：\nwhile：先判断后执行\ndo\u0026hellip;while: 先执行后判断\ndo\u0026hellip;while 可以确保循环体至少执行一次。\nfor 循环：\n语法：\nfor(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } 执行流程：\n首先执行 ① 初始化表达式，初始化一个变量，\n然后对 ② 条件表达式进行求值判断，如果为 false 则终止循环\n如果判断结果为 true，则执行 ③ 循环体\n循环体执行完毕，执行 ④ 更新表达式，对变量进行更新。\n更新表达式执行完毕重复 ②\n死循环：\nwhile (true) {} for (;;) {} 对象（Object） 对象是 JS 中的引用数据类型\n对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性\n使用 typeof 检查一个对象时，会返回 object\n对象的分类 1.内建对象\n由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用\n比如：Math String Number Boolean Function Object\u0026hellip;.\n2.宿主对象\n由 JS 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象\n比如 BOM DOM\n3.自定义对象\n由开发人员自己创建的对象\n创建对象 方式一\nvar obj = new Object(); 方式二\nvar obj = {}; 对象的属性 向对象中添加属性\n对象.属性名 = 属性值; 对象[\u0026#39;属性名\u0026#39;] = 属性值; //这种方式能够使用特殊的属性名 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。\n属性值也可以任意的数据类型。\n读取对象中的属性\n对象.属性名; 对象[\u0026#39;属性名\u0026#39;]; //\u0026#34;属性名\u0026#34;可以使字符串常量，也可以是字符串变量 如果读取一个对象中没有的属性，它不会报错，而是返回一个 undefined\n删除对象中的属性\ndelete 对象.属性名; delete 对象[\u0026#39;属性名\u0026#39;]; 遍历 使用 in 检查对象中是否含有指定属性 语法：\u0026ldquo;属性名\u0026rdquo; in 对象\n如果在对象中含有该属性，则返回 true,如果没有则返回 false\n循环遍历对象自身的和继承的可枚举属性(不含 Symbol 属性)\nvar obj = { 0: \u0026#39;a\u0026#39;, 1: \u0026#39;b\u0026#39;, 2: \u0026#39;c\u0026#39; }; for (var i in obj) { console.log(i, \u0026#39;:\u0026#39;, obj[i]); } 使用对象字面量，在创建对象时直接向对象中添加属性 var obj = { 属性名: 属性值, 属性名: 属性值, 属性名: 属性值, 属性名: 属性值, }; 基本数据类型和引用数据类型 基本数据类型\nString Number Boolean Null Undefined\n引用数据类型\nObject\n基本数据类型的数据，变量是直接保存的它的值。\n变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。\n引用数据类型的数据，变量是保存的对象的引用（内存地址）。\n如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比较两个变量时，对于基本数据类型，比较的就是值，对于引用数据类型比较的是地址，地址相同才相同\n函数（Function） 函数也是一个对象，也具有普通对象的功能（能有属性）\n函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码\n使用 typeof 检查一个函数时会返回 function\n创建函数 // 函数声明 function 函数名([形参1,形参2...形参N]){ 语句... } // 函数表达式 var 函数名 = function([形参1,形参2...形参N]){ 语句... }; 调用函数 语法：函数对象([实参 1,实参 2\u0026hellip;实参 N]);\nfun() sum() alert() Number() parseInt()\n当我们调用函数时，函数中封装的代码会按照编写的顺序执行\n立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数\n立即执行函数往往只会执行一次\n(function (a, b) { console.log(\u0026#39;a = \u0026#39; + a); console.log(\u0026#39;b = \u0026#39; + b); })(123, 456); 形参和实参 形参：形式参数\n定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开，定义形参就相当于在函数内声明了对应的变量但是并不赋值，形参会在调用时才赋值。\n实参：实际参数\n调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参，调用函数时 JS 解析器不会检查实参的类型和个数，可以传递任意数据类型的值。如果实参的数量大于形参，多余实参将不会赋值，如果实参的数量小于形参，则没有对应实参的形参将会赋值 undefined\n返回值 使用 return 来设置函数的返回值。\n语法：return 值;\n该值就会成为函数的返回值，可以通过一个变量来接收返回值。如果 return 后不跟值，或者是不写 return 则函数默认返回 undefined。\nbreak、continue 和 return break，退出循环\ncontinue，跳过当次循环\nreturn，退出函数\n方法（method） 可以将一个函数设置为一个对象的属性，当一个对象的属性是一个函数时，我们称这个函数是该对象的方法。\n对象.方法名();\n函数名()\n函数的属性和方法 call()、apply()\n这两个方法都是函数对象的方法需要通过函数对象来调用\n通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中 this，不同的是 call 是直接传递函数的实参而 apply 需要将实参封装到一个数组中传递\narguments arguments 和 this 类似，都是函数中的隐含的参数\narguments 是一个类数组元素，它用来封装函数执行过程中的实参，所以即使不定义形参，也可以通过 arguments 来使用实参，arguments 中有一个属性 callee 表示当前执行的函数对象\nthis this 是函数的上下文对象，根据函数的调用方式不同会执向不同的对象\n以函数的形式调用时，this 是 window 以方法的形式调用时，this 是调用方法的对象 以构造函数的形式调用时，this 是新建的那个对象 使用 call 和 apply 调用时，this 是指定的那个对象 在全局作用域中 this 代表 window 作用域 作用域简单来说就是一个变量的作用范围。\n全局作用域 直接在 script 标签中编写的代码都运行在全局作用域中\n全局作用域在打开页面时创建，在页面关闭时销毁。\n全局作用域中有一个全局对象 window，window 对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。在全局作用域中创建的变量都会作为 window 对象的属性保存，在全局作用域中创建的函数都会作为 window 对象的方法保存，在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。尽量不要在全局中创建变量。\n函数作用域 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。\n函数作用域在函数执行时创建，在函数执行结束时销毁。\n在函数作用域中创建的变量，不能在全局中访问。当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找\n变量的声明提前 在全局作用域中，使用**var 关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。**所以我们可以在变量声明前使用变量。但是不使用 var 关键字声明的变量不会被声明提前。\n在函数作用域中，也具有该特性，使用 var 关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用 var 关键字声明变量，则变量会变成全局变量。\n函数的声明提前 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性。\nthis（上下文对象） 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。\n使用 this 来引用上下文对象，根据函数的调用形式不同，this 的值也不同。\n一般指向当前对象。\nthis 的不同的情况：\n以函数的形式调用时，this 是 window\n以方法的形式调用时，this 就是调用方法的对象\n以构造函数的形式调用时，this 就是新创建的对象\n构造函数 构造函数是专门用来创建对象的函数，一个构造函数我们也可以称为一个类。\n通过一个构造函数创建的对象，我们称该对象是这个构造函数的实例；通过同一个构造函数创建的对象，我们称为一类对象。\n构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数，如果使用 new 来调用，则它就是一个构造函数。\n例子：\nfunction Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; this.sayName = function () { alert(this.name); }; return this; } 构造函数的执行流程：\n创建一个新的对象\n将新的对象作为函数的上下文对象（this）\n执行函数中的代码\n将新建的对象返回\ninstanceof 用来检查一个对象是否是一个类的实例\n语法：对象 instanceof 构造函数\n如果该对象时构造函数的实例，则返回 true，否则返回 false\nObject 是所有对象的祖先，所以任何对象和 Object 做 instanceof 都会返回 true\n原型（prototype） 创建一个函数以后，解析器都会默认在函数中添加一个数 prototype，prototype 属性指向的是一个对象，这个对象我们称为原型对象。\n当函数作为构造函数使用，**它所创建的对象中都会有一个隐含的属性就是该原型对象。**这个隐含的属性可以通过对象.__proto__来访问。\n原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。\n我们可以将对象中共有的属性和方法统一添加到原型对象中，这样我们只需要添加一次，就可以使所有的对象都可以使用。\n当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，如果在自身中找到了，则直接使用。如果没有找到，则去原型对象中寻找，如果找到了则使用，**如果没有找到，则去原型的原型中寻找，**依此类推。直到找到 Object 的原型为止，Object 的原型的原型为 null，如果依然没有找到则返回 undefined\n方法 hasOwnProperty()\n这个方法可以用来检查对象自身中是否含有某个属性\n语法：对象.hasOwnProperty(\u0026ldquo;属性名\u0026rdquo;)\ntoString 方法 当我们直接在页面中打印一个对象时，事件上是输出的对象的 toString()方法的返回值\n如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个 toString()方法\n//修改Person原型的toString Person.prototype.toString = function () { return \u0026#39;Person[name=\u0026#39; + this.name + \u0026#39;,age=\u0026#39; + this.age + \u0026#39;,gender=\u0026#39; + this.gender + \u0026#39;]\u0026#39;; }; 垃圾回收（GC） 就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾。\n当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象， 此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。\n在 JS 中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，我们需要做的只是要将不再使用的对象设置 null 即可。\n数组（Array） 数组也是一个对象，是一个用来存储数据的对象和 Object 类似，但是它的存储效率比普通对象要高；数组中保存的内容我们称为元素；数组使用索引（index）来操作元素；索引指由 0 开始的整数。\n数组的操作 创建数组\nvar arr = new Array(); var arr = []; 向数组中添加元素\narr[0] = 123; arr[1] = \u0026#39;hello\u0026#39;; 创建数组时直接添加元素\nvar arr = [元素1,元素2....元素N]; 获取和修改数组的长度 使用 length 属性来操作数组的长度\n获取长度 数组.length length获取到的是数组的最大索引+1 对于连续的数组，length获取到的就是数组中元素的个数 修改数组的长度 数组.length = 新长度 如果修改后的length大于原长度，则多出的部分会空出来 如果修改后的length小于原长度，则原数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值; 数组的方法 方法名 push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度 pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的开头添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的开头的一个元素，并返回被删除的元素 reverse() 可以用来反转一个数组，它会对原数组产生影响 concat() 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回 slice(sart,[end]) 可以从一个数组中截取指定的元素，该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回。\n参数：\n截取开始位置的索引（包括开始位置）\n截取结束位置的索引（不包括结束位置）\n第二个参数可以省略不写，如果不写则一直截取到最后\n参数可以传递一个负值，如果是负值，则从后往前数\nsplice() 可以用来删除数组中指定元素，并使用新的元素替换,该方法会将删除的元素封装到新数组中返回\n参数：\n删除开始位置的索引\n删除的个数\n三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边\njoin([splitor]) 可以将一个数组转换为一个字符串\n参数：\n需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素,如果不指定连接符则默认使用\nsort() 可以对一个数组中的内容进行排序，默认是按照 Unicode 编码进行排序,调用以后，会直接修改原数组。\n我们可以在 sort()添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参,浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但是肯定的是在数组中 a 一定在 b 前边\n浏览器会根据回调函数的返回值来决定元素的顺序， 如果返回一个大于 0 的值，则元素会交换位置 如果返回一个小于 0 的值，则元素位置不变 如果返回一个 0，则认为两个元素相等，也不交换位置\n如果需要升序排列，则返回 a-b 如果需要降序排列，则返回 b-a\nfunction(a,b){ //升序排列 //return a-b; //降序排列 return b-a; } 遍历数组 遍历数组就是将数组中元素都获取到\n一般情况我们都是使用 for 循环来遍历数组\nfor (var i = 0; i \u0026lt; 数组.length; i++) { //数组[i] } 使用 forEach()方法来遍历数组（不兼容 IE8）\n数组.forEach(function (value, index, obj) {}); // value:正在遍历的元素 // index:正在遍历元素的索引 // obj:被遍历对象 forEach()方法需要一个回调函数作为参数，数组中有几个元素，回调函数就会被调用几次，每次调用时，都会将遍历到的信息以实参的形式传递进来，我们可以定义形参来获取这些信息。\n常用类和方法 包装类 在 JS 中为我们提供了三个包装类：\nString() Boolean() Number()\n通过这三个包装类可以创建基本数据类型的对象\nvar num = new Number(2); var str = new String(\u0026#39;hello\u0026#39;); var bool = new Boolean(true); 但是在实际应用中千万不要这么干。\n当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，\n操作完成以后再将这个临时对象进行销毁。\nDate 日期的对象，在 JS 中通过 Date 对象来表示一个时间\n创建对象\n// 创建一个当前的时间对象 var d = new Date(); // 创建一个指定的时间对象 var d = new Date(\u0026#39;月/日/年 时:分:秒\u0026#39;); 方法\n方法名 getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） getMonth() 返回当前日期对象的月份（0-11） getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 Date.now() 可以获取当前代码执行时的时间戳 Math Math 属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法，我们可以直接使用它来进行数学运算相关的操作。 方法：\n方法名 Math.PI 常量，圆周率 Math.abs() 绝对值运算 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入取整 Math.random() 生成一个 01 之间的随机数 Math.pow(x,y) 求 x 的 y 次幂 Math.sqrt() 对一个数进行开方 Math.max() 求多个数中最大值 Math.min() 求多个数中的最小值 字符串的相关的方法 方法名 String.prototype.padStart(maxLength, fillString=\u0026rsquo;') 填充字符串 String.prototype.padEnd(maxLength, fillString=\u0026rsquo;') 填充字符串 length 获取字符串的长度 charAt() 根据索引获取指定的字符 charCodeAt() 根据索引获取指定的字符编码 String.fromCharCode() 根据字符编码获取字符 indexOf() 从一个字符串中检索指定内容 第一个字符串参数，找到返回索引，否则-1，第二个参数开始位置 lastIndexOf() indexOf()的逆序版 slice(start,[end]) 从一个字符串中截取指定的内容并返回，不影响原变量 substr() 和 slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 substring() 和 slice()基本一致，不同的是它不接受负值作参数，负值会修正为 0，substring()中第二个参数小于第一个，自动调整位置 toLowerCase() 将字符串转换为小写并返回 toUpperCase() 将字符串转换为大写并返回 split() 可以根据指定内容将一个字符串拆分为一个数组，可以接收一个字符串或正则表达式 match() 可以根据字符串正则表达式，从一个字符串中将符合条件的内容提取出来 replace() 可以将字符串中指定内容替换为新的内容 search() 可以搜索字符串中是否含有指定内容 正则表达式 正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。\n创建正则表达式:\nvar reg = new RegExp(\u0026#39;正则\u0026#39;, \u0026#39;匹配模式\u0026#39;); // 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\\\来代替 var reg = /正则表达式/; // 匹配模式 （匹配模式可以多个一起写：/gi） 语法 匹配模式：\ni:忽略大小写（ignore）\ng:全局匹配模式（默认为 1 次）\n设置匹配模式时，可以都不设置，也可以设置 1 个，也可以全设置，设置时没有顺序要求\n其他\n方法 test()\n可以用来检查一个字符串是否符合正则表达式\n如果符合返回 true，否则返回 false\n例子:\n去掉两端的空格:\nvar s = \u0026#39; f afa \u0026#39;; s = s.replace(/^\\s*|\\s*$/g, \u0026#39;\u0026#39;); DOM Document Object Model\n文档对象模型，通过 DOM 可以来任意来修改网页中各个内容\n文档：文档指的是网页，一个网页就是一个文档\n对象：对象指将网页中的每一个节点都转换为对象\n模型：模型用来表示节点和节点之间的关系，方便操作页面\n节点（Node）：节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点\n节点类型：\n文档节点 （Document）：代表整个网页 ​ 元素节点（Element）：代表网页中的标签 ​ 属性节点（Attribute）：代表标签中的属性 ​ 文本节点（Text）：代表网页中的文本内容\nDOM 操作 DOM 查询 在网页中浏览器已经为我们提供了document 对象，它代表的是整个网页，它是 window 对象的属性，可以在页面中直接使用。\ndocument 查询方法\n// 根据元素的id属性查询一个元素节点对象： document.getElementById(\u0026#39;id属性值\u0026#39;); // 根据元素的name属性值查询一组元素节点对象: document.getElementsByName(\u0026#39;name属性值\u0026#39;); // 根据标签名来查询一组元素节点对象： document.getElementsByTagName(\u0026#39;标签名\u0026#39;); 元素的属性 读取元素的属性：\n语法：元素.属性名 ele.name ele.id ele.value ele.className 修改元素的属性：\n语法：元素.属性名 = 属性值 innerHTML：\n使用该属性可以获取或设置元素内部的 HTML 代码\n文档的加载：\n浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。如果将 js 代码编写到页面的上边，当代码执行时，页面中的 DOM 对象还没有加载，此时将会无法正常获取到 DOM 对象，导致 DOM 操作失败。\n解决方式一：\n可以将 js 代码编写到 body 的下边\n\u0026lt;body\u0026gt; \u0026lt;button id=\u0026#39;btn\u0026#39;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt;var btn = document.getElementById(\u0026#34;btn\u0026#34;); btn.onclick = function(){};\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 解决方式二：\n将 js 代码编写到 window.onload = function(){}中；window.onload 对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM 对象已经加载完毕了。\n\u0026lt;script\u0026gt; window.onload = function(){ var btn = document.getElementById(\u0026#34;btn\u0026#34;); btn.onclick = function(){ }; }; \u0026lt;/script\u0026gt; DOM 查询 API：\nname 元素.childNodes 获取当前元素的所有子节点， 会获取到空白的文本子节点 元素.children 获取当前元素的所有子元素 元素.firstChild 获取当前元素的第一个子节点，会获取到空白的文本子节点 元素.lastChild 获取当前元素的最后一个子节点 元素.parentNode 获取当前元素的父元素 元素.previousSibling 获取当前元素的前一个兄弟节点 元素.previousElementSibling 获取前一个兄弟元素，IE8 及以下不支持 元素.nextSibling 获取当前元素的后一个兄弟节点 元素.firstElementChild 获取当前元素的第一个子元素，不支持 IE8 及以下的浏览器 元素.innerHTML 获取到标签内部的内容。包含 HTML 标签 元素.innerText 获取到标签内部的内容。不包含 HTML 标签 元素.firstChild.nodeValue 读取标签内部的文本内容 document.all 获取页面中的所有元素 document.documentElement 获取页面中 html 根元素 document.body 获取页面中的 body 元素 document.getElementsByClassName() 根据元素的 class 属性值查询一组元素节点对象 document.querySelector() 根据 CSS 选择器去页面中查询一个元素，返回查询到的第一个元素 document.querySelectorAll() 根据 CSS 选择器去页面中查询一组元素，以数组方式返回 DOM 修改 name document.createElement(\u0026ldquo;TagName\u0026rdquo;) 可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回 document.createTextNode(\u0026ldquo;textContent\u0026rdquo;) 可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点) 向父节点中添加指定的子节点 父节点.insertBefore(新节点,旧节点) 将一个新的节点插入到旧节点的前边 父节点.replaceChild(新节点,旧节点) 使用一个新的节点去替换旧节点 父节点.removeChild(子节点) 删除指定的子节点，推荐方式：子节点.parentNode.removeChild(子节点) DOM 对 CSS 的操作 读取和修改内联样式 使用 style 属性来操作元素的内联样式\n读取内联样式：\n// 语法 元素.style.样式名; // 例子 元素.style.width; 元素.style.height; /* *注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写 *比如：background-color \u0026gt; backgroundColor *border-width \u0026gt; borderWidth */ 修改内联样式：\n// 语法： 元素.style.样式名 = 样式值; /* *通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过JS来修改*的样式，往往会立即生效，但是如果样式中设置了!important，则内联样式将不会生效。 */ 读取元素的当前样式 正常浏览器\ngetComputedStyle(); /* 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式 参数： 1.要获取样式的元素 2.可以传递一个伪元素，一般传null *例子： * 获取元素的宽度 * getComputedStyle(box , null)[\u0026#34;width\u0026#34;]; * *通过该方法读取到样式都是只读的不能修改 */ IE8\n元素.currentStyle; /* *例子： *box.currentStyle[\u0026#34;width\u0026#34;] * *通过这个属性读取到的样式是只读的不能修改 */ 实现兼容性：\nfunction getStyle(obj, name) { //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 if (window.getComputedStyle) { //正常浏览器的方式，具有getComputedStyle()方法 return getComputedStyle(obj, null)[name]; } else { //IE8的方式，没有getComputedStyle()方法 return obj.currentStyle[name]; } } 其他的样式相关的属性 注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角\nname clientHeight 元素的可见高度，包括元素的内容区和内边距的高度 clientWidth 元素的可见宽度，包括元素的内容区和内边距的宽度 offsetHeight 整个元素的高度，包括内容区、内边距、边框 offfsetWidth 整个元素的宽度，包括内容区、内边距、边框 offsetParent 当前元素的定位父元素 offsetLeft 当前元素和定位父元素之间的水平偏移量 offsetTop 当前元素和定位父元素之间的垂直偏移量 scrollHeight 获取元素滚动区域的高度 scrollWidth 获取元素滚动区域的宽度 scrollTop 获取元素垂直滚动条滚动的距离 scrollLeft 获取元素水平滚动条滚动的距离 判断滚动条是否滚动到底：\n垂直滚动条\nscrollHeight -scrollTop = clientHeight\n水平滚动\nscrollWidth -scrollLeft = clientWidth\n事件 事件对象 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向……\n可以在响应函数中定义一个形参，来使用事件对象，但是在 IE8 以下浏览器中事件对象没有做为实参传递，而是作为 window 对象的属性保存\n例子：\n元素.事件 = function (event) { event = event || window.event; }; 元素.事件 = function (e) { e = e || event; }; 获取到鼠标的坐标：\nclientX 和 clientY\n用于获取鼠标在当前的可见窗口的坐标，div 的偏移量，是相对于整个页面的。\npageX 和 pageY 可以获取鼠标相对于当前页面的坐标。\n但是这个两个属性在 IE8 中不支持，所以如果需要兼容 IE8，则不要使用\n事件的冒泡（Bubble） 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。\n事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消，可以将事件对象的 cancelBubble 设置为 true，即可取消冒泡\n元素.事件 = function (event) { event = event || window.event; event.cancelBubble = true; }; 事件的委派 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。\n事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能。\n我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的，我们可以尝试将其绑定给元素的共同的祖先元素。\ntarget : event 中的 target 表示的触发事件的对象。\n事件的绑定 addEventListener() 通过这个方法也可以为元素绑定响应函数\n参数：\n事件的字符串，不要 on\n回调函数，当事件触发时该函数会被调用\n是否在捕获阶段触发事件，需要一个布尔值，一般都传 false\n使用 addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行。\n这个方法不支持 IE8 及以下的浏览器。\nattachEvent() 在 IE8 中可以使用 attachEvent()来绑定事件\n参数：\n事件的字符串，要 on\n回调函数\n这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是后绑定先执行，执行顺序和 addEventListener()相反。\n实现兼容性 function bind(obj , eventStr , callback){ if(obj.addEventListener){ //大部分浏览器兼容的方式 obj.addEventListener(eventStr , function(){ //在匿名函数中调用回调函数 callback.call(obj); }), false); }else{ //IE8及以下 obj.attachEvent(\u0026#34;on\u0026#34;+eventStr , function(){ //在匿名函数中调用回调函数 callback.call(obj); }); } } 事件的传播 事件传播分为三个阶段\n捕获阶段\n在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件\n目标阶段\n事件捕获到目标元素，捕获结束开始在目标元素上触发事件\n冒泡阶段\n事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件\n如果希望在捕获阶段就触发事件，可以将 addEventListener()的第三个参数设置为 true，一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是 false。\nIE8 及以下的浏览器中没有捕获阶段。\n常用事件 鼠标事件 拖拽事件\nfunction drag(obj) { //当鼠标在被拖拽元素上按下时，开始拖拽onmousedown obj.onmousedown = function (event) { //设置obj捕获所有鼠标按下的事件 /* * setCapture() * - 只有IE支持，但是在火狐中调用时不会报错， * * 而如果使用chrome调用，会报错 * */ obj.setCapture \u0026amp;\u0026amp; obj.setCapture(); event = event || window.event; //obj的定位父元素相对于可视窗口左上角的水平偏移量 鼠标.clentX - 元素.offsetLeft //obj的定位父元素相对于可视窗口左上角的垂直偏移量 鼠标.clentY - 元素.offsetTop var ol = event.clientX - obj.offsetLeft; var ot = event.clientY - obj.offsetTop; //为document绑定一个onmousemove事件 document.onmousemove = function (event) { event = event || window.event; //当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove //获取鼠标的坐标 var left = event.clientX - ol; var top = event.clientY - ot; //修改obj的位置 obj.style.left = left + \u0026#39;px\u0026#39;; obj.style.top = top + \u0026#39;px\u0026#39;; }; //为document绑定一个鼠标松开事件 document.onmouseup = function () { //当鼠标松开时，被拖拽元素固定在当前位置 onmouseup //取消document的onmousemove事件 document.onmousemove = null; //取消document的onmouseup事件 document.onmouseup = null; //当鼠标松开时，取消对事件的捕获 obj.releaseCapture \u0026amp;\u0026amp; obj.releaseCapture(); }; /* * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容， * 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为， * * 如果不希望发生这个行为，则可以通过return false来取消默认行为 * * 但是这招对IE8不起作用 */ return false; }; } 滚轮事件\nonwheel 都支持\n//获取id为box1的div var box1 = document.getElementById(\u0026#39;box1\u0026#39;); //为box1绑定一个鼠标滚轮滚动的事件 /* * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发， * 但是火狐不支持该属性 * * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件 * 注意该事件需要通过addEventListener()函数来绑定 */ box1.onmousewheel = function (event) { event = event || window.event; //event.wheelDelta 可以获取鼠标滚轮滚动的方向 //向上滚 120 向下滚 -120 //wheelDelta这个值我们不看大小，只看正负 //alert(event.wheelDelta); //wheelDelta这个属性火狐中不支持 //在火狐中使用event.detail来获取滚动的方向 //向上滚 -3 向下滚 3 //alert(event.detail); /* * 当鼠标滚轮向下滚动时，box1变长 * 当滚轮向上滚动时，box1变短 */ //判断鼠标滚轮滚动的方向 if (event.wheelDelta \u0026gt; 0 || event.detail \u0026lt; 0) { //向上滚，box1变短 box1.style.height = box1.clientHeight - 10 + \u0026#39;px\u0026#39;; } else { //向下滚，box1变长 box1.style.height = box1.clientHeight + 10 + \u0026#39;px\u0026#39;; } /* * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false * 需要使用event来取消默认行为event.preventDefault(); * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错 */ event.preventDefault \u0026amp;\u0026amp; event.preventDefault(); /* * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动， * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为 */ return false; }; //为火狐绑定滚轮事件 bind(box1, \u0026#39;DOMMouseScroll\u0026#39;, box1.onmousewheel); function bind(obj, eventStr, callback) { if (obj.addEventListener) { //大部分浏览器兼容的方式 obj.addEventListener( eventStr, function () { callback.call(obj); }, false ); } else { //IE8及以下 obj.attachEvent(\u0026#39;on\u0026#39; + eventStr, function () { callback.call(obj); }); } } 键盘事件 onkeydown\n按键被按下,如果一直按着某个按键不松手，则事件会一直触发；当 onkeydown 连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。\nonkeyup\n按键被松开\n键盘事件一般都会绑定给一些可以获取到焦点的对象或者是 document。\nkeyCode\n可以通过 keyCode 来获取按键的编码，通过它可以判断哪个按键被按下，除了 keyCode，事件对象中还提供了几个属性：\naltKey、ctrlKey、shiftKey\n这个三个用来判断 alt ctrl 和 shift 是否被按下，如果按下则返回 true，否则返回 false。\ninput.onkeydown = function (event) { event = event || window.event; //数字 48 - 57 //使文本框中不能输入数字 if (event.keyCode \u0026gt;= 48 \u0026amp;\u0026amp; event.keyCode \u0026lt;= 57) { //在文本框中输入内容，属于onkeydown的默认行为 //如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 return false; } }; BOM 浏览器对象模型(browser object model)\nBOM 可以使我们通过 JS 来操作浏览器，在 BOM 中为我们提供了一组对象，用来完成对浏览器的操作 BOM 对象。这些 BOM 对象在浏览器中都是作为 window 对象的属性保存的，可以通过 window 对象来使用，也可以直接使用。\nWindow\n代表的是整个浏览器的窗口，同时 window 也是网页中的全局对象。\nNavigator\n代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器。\nLocation\n代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。\nHistory\n代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。\n由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页；而且该操作只在当次访问时有效。\nScreen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息。\nNavigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器，由于历史原因，Navigator 对象中的大部分属性都已经不能帮助我们识别浏览器了， 一般我们只会使用 userAgent 来判断浏览器的信息。\nuserAgent 是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的 userAgent。\n在 IE11 中已经将微软和 IE 相关的标识都已经去除了，所以我们基本已经不能通过 UserAgent 来识别一个浏览器是否是 IE 了。\nalert(navigator.appName); var ua = navigator.userAgent; console.log(ua); History history 对象可以用来操作浏览器向前或向后翻页。\nlength\n可以获取到当前访问的链接数量\nback()\n可以用来回退到上一个页面，作用和浏览器的回退按钮一样\nforward()\n可以跳转下一个页面，作用和浏览器的前进按钮一样\ngo()\n可以用来跳转到指定的页面\n它需要一个整数作为参数 1:表示向前跳转一个页面 相当于 forward() 2:表示向前跳转两个页面 -1:表示向后跳转一个页面 -2:表示向后跳转两个页面\nLocation 该对象中封装了浏览器的地址栏的信息。\n如果直接打印 location，则可以获取到地址栏的信息（当前页面的完整路径）\n如果直接将 location 属性修改为一个完整的路径，或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录\nassign()\n用来跳转到其他的页面，作用和直接修改 location 一样\nreload()\n用于重新加载当前页面，作用和刷新按钮一样\n如果在方法中传递一个 true，作为参数，则会强制清空缓存刷新页面\nreplace()\n可以使用一个新的页面替换当前页面，调用完毕也会跳转页面，不会生成历史记录，不能使用回退按钮回退\nwindow 定时器 setInterval()\n定时调用\n可以将一个函数，每隔一段时间执行一次\n参数：\n回调函数\n间隔的时间，单位是毫秒\n返回值：返回一个 Number 类型的数据，这个数字用来作为定时器的唯一标识\nclearInterval()可以用来关闭一个定时器\n方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器\nvar num = 1; var timer = setInterval(function () { count.innerHTML = num++; if (num == 11) { //关闭定时器 clearInterval(timer); } }, 1000); clearInterval(timer); 延时调用 setTimeout()\n延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次。\n延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择。\nclearTimeout()\nclearTimeout()来关闭一个延时调用。\nvar timer = setTimeout(function () { console.log(num++); }, 3000); clearTimeout(timer); 修改元素的类更改样式 通过 style 属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面。 这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式。\n我们可以通过修改元素的 class 属性来间接的修改样式.这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离。\nbox.className += \u0026#39; b2\u0026#39;; //注意有空格，添加class属性 //定义一个函数，用来向一个元素中添加指定的class属性值 /* * 参数: * obj 要添加class属性的元素 * cn 要添加的class值 * */ function addClass(obj, cn) { if (!hasClass(obj, cn)) { obj.className += \u0026#39; \u0026#39; + cn; } } /* * 判断一个元素中是否含有指定的class属性值 * 如果有该class，则返回true，没有则返回false * */ function hasClass(obj, cn) { var reg = new RegExp(\u0026#39;\\\\b\u0026#39; + cn + \u0026#39;\\\\b\u0026#39;); return reg.test(obj.className); } /* * 删除一个元素中的指定的class属性 */ function removeClass(obj, cn) { //创建一个正则表达式 var reg = new RegExp(\u0026#39;\\\\b\u0026#39; + cn + \u0026#39;\\\\b\u0026#39;); //删除class obj.className = obj.className.replace(reg, \u0026#39;\u0026#39;); } /* * toggleClass可以用来切换一个类 * 如果元素中具有该类，则删除 * 如果元素中没有该类，则添加 */ function toggleClass(obj, cn) { //判断obj中是否含有cn if (hasClass(obj, cn)) { //有，则删除 removeClass(obj, cn); } else { //没有，则添加 addClass(obj, cn); } } JSON JavaScript Object Notation JS 对象表示法\nJSON 格式 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和 null 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 [ { \u0026#34;name\u0026#34;: \u0026#34;孙悟空\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;孙悟空\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34; } ] JSON 和 JS 对象转换 JSON 转 JS 对象\nvar jsObj = JSON.parse(jsonStr); JS 对象转 JSON\nvar jsonStr = JSON.stringify(jsObj); other localStorage localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。\nlocalStorage 属性是只读的。\n// 保存数据 localStorage.setItem(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); // 读取数据 var lastname = localStorage.getItem(\u0026#39;key\u0026#39;); // 删除数据 localStorage.removeItem(\u0026#39;key\u0026#39;); eval() eval() 这个函数可以用来执行一段字符串形式的 JS 代码，并将执行结果返回\n如果使用 eval()执行的字符串中含有{},它会将{}当成是代码块；如果不希望将其当成代码块解析，则需要在字符串前后各加上左右括号()。\neval()这个函数的功能很强大，可以直接执行一个字符串中的 js 代码，但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患。\nvar str = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;孙悟空\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;}\u0026#39;; var obj = eval(\u0026#39;(\u0026#39; + str + \u0026#39;)\u0026#39;); 编码 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\u0026#39;\\u2620\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--在网页中使用Unicode编码 \u0026amp;#编码; 这里的编码需要的是10进制 --\u0026gt; \u0026lt;h1 style=\u0026#34;font-size: 200px;\u0026#34;\u0026gt;\u0026amp;#9760;\u0026lt;/h1\u0026gt; \u0026lt;h1 style=\u0026#34;font-size: 200px;\u0026#34;\u0026gt;\u0026amp;#9856;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; confirm() 用于弹出一个带有确认和取消按钮的提示框，需要一个字符串作为参数，该字符串将会作为提示文字显示出来，如果用户点击确认则会返回 true，如果点击取消则返回 false。\nvar flag = confirm(\u0026#39;确认删除\u0026#39; + name + \u0026#39;吗?\u0026#39;); ","date":"2021-02-21T15:27:32Z","image":"https://static.aecra.cn/cover/javascript-notes.jpg","permalink":"https://aecra.github.io/article/javascript-notes/","title":"JavaScript 笔记"},{"content":"思路一 首先，理解 Floyd 算法是按照点的编号增加的顺序更新最短路径的。\n因为 Floyd 算法基于动态规划思想，动态规划过程必定存在一个顺序，这里的顺序就是节点编号增加的顺序。那么如果存在这个最小环，会在这个环中的编号最大的那个点 u 更新之前发现这个环。\n也就是说，当 u 点被拿来更新从 i 到 j 的最短路径时，我们就能够发现这个闭合环路，发现的方法也不难理解，**if（dis[i][j]+map[j][u]+map[u][i]\u0026lt;INF）**那么就说明以 i 到 j 的一条路径加上 j 到 u 这条边，加上 u 到 i 这条边，就能够组成一个环路。那么我们就在 floyd 实现的代码上稍加改变就可以求得这个最小环。\n思路二 我们可以逆向考虑这个问题，假设现在我们已经进行完 floyd 的过程了，dis[i][j]已经是从 i 到 j 的最短路径值了，那么如果我们设定一个数组:pre[i][j]来记录其路径的话，有这样一个方法：\n首先我们能够理解，无论对 dis[i][j]这条路径上一共用多少个点更新过这个值，最后一步更新一定是这样的：dis[i][j]=dis[i][k]+dis[k][j]，我们不妨拿出一个栗子来说：\n对于 dis[1][5]，假如其最后一次更新是这样的：\ndis[1][5]=dis[1][4]+dis[4][5]，\n其 dis[1][4]的最后一步更新为：\ndis[1][4]=dis[1][2]+dis[2][4]；\n我们不难写出其路径：1 2 4 5。\n我们这里注意，起点终点就是 dis[i][j]中的 i，j，那么 2 和 4 要如何记录呢？我们可以对其 dis[i][j]最后一次更新的点进行记录，也就是说：pre[1][5]=4；pre[1][4]=2；这个时候，我们发现 5 4 2 之间有相关联：2=pre[1][pre[1][5]]；那么我们不难想出，对于记录路径，我们可以回溯找各个节点。\n我们将 pre[i][j]初始化为 i，当其被更新的时候，我们都记录下来那个节点，回溯即可。\n代码示例 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; int const MAX = 105; int const INF = 0xfffffff; int distMAX, mapMAX, preMAX; int n, m, ans[MAX], min_loop, cnt; void init() { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { disti = INF; mapi = INF; prei = i; //开始时j的上一节点为i } } } void Floyd() { min_loop = INF; //最小环的大小 for (int k = 1; k \u0026lt;= n; k++) { //求最小环，最短路不变 for (int i = 1; i \u0026lt; k; i++) { //通过k对每一个节点进行优化 for (int j = i + 1; j \u0026lt; k; j++) { if (disti + mapi + mapk \u0026lt; min_loop) { //出现了更小的环 min_loop = disti + mapi + mapk; int tmp = j; cnt = 0; while (tmp != i) { ans[cnt++] = tmp; tmp = prei; } ans[cnt++] = i; //至此已求出i到j的上一个最短路的路径，路径是倒着存的 ans[cnt++] = k; //因为通过k松弛，所以要将k加入环 } } } //求最短路及路径 for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (disti + distk \u0026lt; disti) { disti = disti + distk; prei = prek; } } } } } int main() { int u, v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); init(); for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); if (distu \u0026gt; w) { //找最小环遇到平行边时取其最小边权 distu = distv = w; mapu = mapv = w; } } Floyd(); if (min_loop == INF) printf(\u0026#34;No solution\u0026#34;); else { for (int i = 0; i \u0026lt; cnt; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); printf(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2021-02-20T16:38:46Z","image":"https://static.aecra.cn/cover/floyd-minimum-ring.jpg","permalink":"https://aecra.github.io/article/floyd-minimum-ring/","title":"Floyd 最小环算法"},{"content":"定义 1、有向图 G 中，以顶点 v 为起点的弧的数目称为 v 的出度，记做 deg+（v）；以顶点 v 为终点的弧的数目称为 v 的入度，记做 deg-（v）。\n2、如果在有向图 G 中，有一条\u0026lt;u，v\u0026gt;有向道路，则 v 称为 u 可达的，或者说，从 u 可达 v。\n3、如果有向图 G 的任意两个顶点都互相可达，则称图 G 是强连通图，如果有向图 G 存在两顶点 u 和 v 使得 u 不能到 v，或者 v 不能到 u，则称图 G 是强非连通图。\n4、如果有向图 G 不是强连通图，他的子图 G2 是强连通图，点 v 属于 G2，任意包含 v 的强连通子图也是 G2 的子图，则乘 G2 是有向图 G 的极大强连通子图，也称强连通分量。\n5、什么是强连通？强连通其实就是指图中有两点 u，v。使得能够找到有向路径从 u 到 v 并且也能够找到有向路径从 v 到 u，则称 u，v 是强连通的。\n定义的理解 既然我们现在已经了解了什么是强连通，和什么是强连通分量，可能大家对于定义还是理解的不透彻，我们不妨引入一个图加强大家对强连通分量和强连通的理解：\n标注棕色线条框框的三个部分就分别是一个强连通分量，也就是说，这个图中的强连通分量有 3 个。\n其中我们分析最左边三个点的这部分：\n其中 1 能够到达 0,0 也能够通过经过 2 的路径到达 1，1 和 0 就是强连通的。\n其中 1 能够通过 0 到达 2,2 也能够到达 1，那么 1 和 2 就是强连通的。\n\u0026hellip;………………\n同理，我们能够看得出来这一部分确实是强连通分量，也就是说，强连通分量里边的任意两个点，都是互相可达的。\n那么如何求强连通分量的个数呢？另外强连通算法能够实现什么一些基本操作呢？我们继续详解。\nTarjan 算法详解 接着我们开始接触算法，讨论如何用 Tarjan 算法求强连通分量个数：\nTarjan 算法，是一个基于 Dfs 的算法（如果大家还不知道什么是 Dfs，自行百度学习），假设我们要先从 0 号节点开始 Dfs，我们发现一次 Dfs 我萌就能遍历整个图（树），而且我们发现，在 Dfs 的过程中，我们深搜到了其他强连通分量中，那么俺们 Dfs 之后如何判断他喵的哪个和那些节点属于一个强连通分量呢？我们首先引入两个数组：\n①dfn[]\n②low[]\n第一个数组 dfn 我们用来标记当前节点在深搜过程中是第几个遍历到的点。第二个数组是整个算法核心数组，我们稍后再说，这个时候我们不妨在纸上画一画写一写，搞出随意一个 Dfs 出来的 dfn 数组来观察一下（假设我们从节点 0 开始的 Dfs，其中一种可能的结果是这样滴）：\n这个时候我们回头来看第二个数组要怎样操作，我们定义 low[u]=min(low[u]，low[v]（即使 v 搜过了也要进行这步操作，但是 v 一定要在栈内才行）)，u 代表当前节点，v 代表其能到达的节点。这个数组在刚刚到达节点 u 的时候初始化：low[u]=dfn[u]。然后在进行下一层深搜之后回溯回来的时候，维护 low[u]。如果我们发现了某个节点回溯之后的 low[u]值还是==dfn[u]的值，那么这个节点无疑就是一个关键节点：从这个节点能够到达其强连通分量中的其他节点，但是没有其他属于这个强连通分量以外的点能够到达这个点，所以这个点的 low[u]值维护完了之后还是和 dfn[u]的值一样，口述可能理解还是相对费劲一些，我们走一遍流程图：\n① 首先进入 0 号节点，初始化其 low[0]=dfn[0]=1，然后深搜到节点 2，初始化其：low[2]=dfn[2]=2，然后深搜到节点 1，初始化其：low[1]=dfn[1]=3；\n② 然后从节点 1 开始继续深搜，发现 0 号节点已经搜过了，没有继续能够搜的点了，开始回溯维护其值。low[1]=min（low[1]，low[0]）=1；low[2]=min（low[2]，low[1]）=1；low[0]=min（low[0]，low[2]）=1；\n③ 这个时候猛然发现，low[0]==dfn[0]，这个时候不要太开心，就断定一定 0 号节点是一个关键点，别忘了，这个时候还有 3 号节点没有遍历，我们只有在其能够到达的节点全部判断完之后，才能够下结论，所以我们继续 Dfs。\n④ 继续深搜到 3 号节点，初始化其 low[3]=dfn[3]=4，然后深搜到 4 号节点，初始化其：low[4]=dfn[4]=5，这个时候发现深搜到底，回溯，因为节点 4 没有能够到达的点，所以 low[4]也就没有幸进行维护即：low[4]=dfn[4]（这个点一定是强连通分量的关键点，但是我们先忽略这个点，这个点没有代表性，一会分析关键点的问题），然后回溯到 3 号节点，low[3]=min（low[3]，low[4]）=4；发现 low[3]==dfn[3]那么这个点也是个关键点，我们同样忽略掉。\n⑤ 最终回溯到节点 0，进行最后一次值的维护：low[0]=min（low[0]，low[3]）=0，这个时候我们猛然发现其 dfn[0]==low[0]，根据刚才所述，那么这个点就是一个关键点：能够遍历其属强连通分量的点的起始点，而且没有其他点属于其他强连通分量能够有一条有向路径连到这个节点来的节点。\n※※大家仔细理解一下这句话，因为这个点属于一个强连通分量，而且强连通分量中的任意两个节点都是互达的，也就是说强连通分量中一定存在环，这个最后能够回到 0 号节点的 1 号节点一定有机会维护 low[1]，因为 0 号节点是先进来的，所以其 low[1]的值也一定会跟着变小，然后在回溯的过程中，其属一个强连通分量的所有点都会将 low[u]值维护成 low[0]，所以这个 0 号节点就是这个关键点：能够遍历其属强连通分量的起始点而且这样的起始点一定只有一个，所以只要发现了一个这样的关键起始点，那么就一定发现了一个强连通分量。而且这个节点没有其他点属于其他强连通分量能够有一条有向路径连到这个节点来的节点：如果这样的点存在，那么这些个点应该属于同一个强连通分量。\n那么综上所述，相信大家也就能够理解为什么 dfn[u]==low[u]的时候，我们就可以判断我们发现了一个强连通分量了。\n代码示例 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, m, idx = 0, k = 1, number = 0; int head[100]; //用于链式前向星 int ins[100] = {0}; int dfn[100] = {0}, low[100] = {0}; int Belong[100]; //染色，每个强连通分量一个颜色 stack\u0026lt;int\u0026gt; s; struct edge { int v, next; } e[100]; void add(int u, int v) { e[k].v = v; e[k].next = head[u]; head[u] = k++; } void readdata() { int a, b; memset(head, -1, sizeof(head)); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); } } void tarjan(int u) { int v; dfn[u] = low[u] = ++idx; //每次dfs，u的次序号增加1 s.push(u); //将u入栈，栈就是为了回溯染色 ins[u] = 1; //标记u在栈内 for (int i = head[u]; i != -1; i = e[i].next) { //访问从u出发的边 v = e[i].v; if (!dfn[v]) { //如果v没被处理过 tarjan(v); //dfs(v) low[u] = min(low[u], low[v]); //u点能到达的最小次序号是它自己能到达点的最小次序号和连接点v能到达点的最小次序号中较小的 } else if (ins[v]) low[u] = min(low[u], dfn[v]); //如果v在栈内，u点能到达的最小次序号是它自己能到达点的最小次序号和v的次序号中较小的 } if (dfn[u] == low[u]) { //回溯，对该强连通分量内的点染色 number++; do { v = s.top(); s.pop(); ins[v] = 0; Belong[v] = number; } while (u != v); } } void work() { for (int i = 1; i \u0026lt;= n; i++) if (!dfn[i]) tarjan(i); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;共有%d强连通分量，它们是:\\n\u0026#34;, number); for (int i = 1; i \u0026lt;= number; i++) { printf(\u0026#34;第%d个:\u0026#34;, i); for (int j = 1; j \u0026lt;= n; j++) { if (Belong[j] == i) printf(\u0026#34;%d \u0026#34;, j); } printf(\u0026#34;\\n\u0026#34;); } } int main() { readdata(); work(); return 0; } ","date":"2021-02-19T14:42:09Z","image":"https://static.aecra.cn/cover/tarjan-strong-connectivity-algorithm.jpg","permalink":"https://aecra.github.io/article/tarjan-strong-connectivity-algorithm/","title":"Tarjan 强连通算法"},{"content":"弗洛伊德算法 通过中间节点 k 来实现 i 和 j 的距离缩短，空间和时间复杂度都为 n3，一般数据在 400 以内可以使用。\nfor (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) for (int k = 0; k \u0026lt; n; k++) if (ai \u0026lt; inf \u0026amp;\u0026amp; ak \u0026lt; inf) { if (ai + ak \u0026lt; ai) { ai = ai + ak; } } 迪杰斯特拉算法 指定一个点到其余各个顶点的最短路径，也叫“单源最短路径”。\n矩阵存储边代码：\nint e10, dis[10], book[10], n, m, t1, t2, t3, u, v, min; int inf = 1 \u0026lt;\u0026lt; 30; //读入n和m，n表示顶点个数，m表示边的条数 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); //初始化 for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { if (i == j) ei = 0; else ei = inf; } //读入边 for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t1, \u0026amp;t2, \u0026amp;t3); et1 = t3; } //初始化dis数组，这是1号顶点到其余各个顶点的初始化路程 for (int i = 1; i \u0026lt;= n; i++) dis[i] = e1; //book数组初始化 for (int i = 1; i \u0026lt;= n; i++) book[i] = 0; book[1] = 1; //核心算法 for (int i = 1; i \u0026lt;= n - 1; i++) { //找到离1号点最近的顶点 min = inf; for (int j = 1; j \u0026lt;= n; j++) if (book[j] == 0 \u0026amp;\u0026amp; dis[j] \u0026lt; min) { min = dis[j]; u = j; } book[u] = 1; for (int v = 1; v \u0026lt;= n; v++) if (eu \u0026lt; min) if (dis[v] \u0026gt; dis[u] + eu) dis[v] = dis[u] + eu; } //输出结果 for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, dis[i]); 链式前向星存储边：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; struct EDGE { int next; //下一条边的存储下标 int to; //这条边的终点 int w; //权值 }; EDGE edge[100]; int n, m, cnt; int head[10]; //head[i]表示以i为起点的第一条边 void Add(int u, int v, int w) { //起点u, 终点v, 权值w edge[++cnt].next = head[u]; edge[cnt].w = w; edge[cnt].to = v; head[u] = cnt; //第一条边为当前边 } int main() { int dis[10], book[10], t1, t2, t3, u, v, min; int inf = 1 \u0026lt;\u0026lt; 30; //读入n和m，n表示顶点个数，m表示边的条数 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); //读入边 for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t1, \u0026amp;t2, \u0026amp;t3); Add(t1, t2, t3); } //初始化dis数组，这是1号顶点到其余各个顶点的初始化路程 for (int i = 1; i \u0026lt;= n; i++) dis[i] = inf; dis[1] = 0; for (int i = head[1]; i != 0; i = edge[i].next) dis[edge[i].to] = edge[i].w; //book数组初始化 for (int i = 1; i \u0026lt;= n; i++) book[i] = 0; book[1] = 1; //核心算法 for (int i = 1; i \u0026lt;= n - 1; i++) { //找到离1号点最近的顶点 min = inf; for (int j = 1; j \u0026lt;= n; j++) if (book[j] == 0 \u0026amp;\u0026amp; dis[j] \u0026lt; min) { min = dis[j]; u = j; } ​ book[u] = 1; ​ for (int v = head[u]; v != 0; v = edge[v].next) ​ if (dis[edge[v].to] \u0026gt; dis[u] + edge[v].w) ​ dis[edge[v].to] = dis[u] + edge[v].w; } //输出结果 for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, dis[i]); return 0; } /* 输入 6 9 1 2 1 1 3 12 2 3 9 2 4 3 3 5 5 4 3 4 4 5 13 4 6 15 5 6 4 输出 0 1 8 4 13 17 */ 使用优先队列对算法进行优化：\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; const int MAX_N = 30000, MAX_L = 30000; //边的最大数量 bool isPrint = 0; int n, m; int dis[MAX_N], book[MAX_N], nodeExist[MAX_N]; // 使用优先队列存结点，降低松弛操作复杂度 struct NODE { int aimNode, distance; NODE(int aimNode, int distance) : aimNode(aimNode), distance(distance) {} bool operator\u0026lt;(const NODE \u0026amp;rhs) const { return distance \u0026gt; rhs.distance; } }; priority_queue\u0026lt;NODE\u0026gt; Q; // 链式前向星存边 struct EDGE { int next; //下一条边的存储下标 int to; //这条边的终点 int w; //权值 }; EDGE edge[MAX_L]; int cnt; int head[MAX_N]; //head[i]表示以i为起点的第一条边 void Add(int u, int v, int w) { //起点u, 终点v, 权值w edge[++cnt].next = head[u]; edge[cnt].w = 1; edge[cnt].to = v; head[u] = cnt; //第一条边为当前边 } void Dijikstra(int startNode) { memset(dis, 0x7F, sizeof(dis)); memset(book, 0, sizeof(book)); dis[startNode] = 0; book[startNode] = 1; //核心算法 Q.push(NODE(startNode, 0)); while (!Q.empty()) { NODE q = Q.top(); Q.pop(); // book[q.aimNode] = 1; for (int v = head[q.aimNode]; v != 0; v = edge[v].next) { if (dis[edge[v].to] \u0026gt; dis[q.aimNode] + edge[v].w) { dis[edge[v].to] = dis[q.aimNode] + edge[v].w; Q.push(NODE(edge[v].to, dis[edge[v].to])); } } } //输出结果 if (isPrint) { printf(\u0026#34;---- Now Start Node IS %d ----\\n\u0026#34;, startNode); for (auto i = 0; i \u0026lt; MAX_N; i++) if (nodeExist[i]) { if (dis[i] == 2139062143) printf(\u0026#34;%d-\u0026gt;%d: inf\\n\u0026#34;, startNode, i); else printf(\u0026#34;%d-\u0026gt;%d: %d\\n\u0026#34;, startNode, i, dis[i]); } } } int main() { clock_t start, end; start = clock(); FILE *fr, *fw; fr = freopen(\u0026#34;small.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); if (isPrint) fw = freopen(\u0026#34;out_small.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); //读入n和m，n表示顶点个数，m表示边的条数 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); //读入边 for (int i = 0; i \u0026lt; m; i++) { int t1, t2; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;t1, \u0026amp;t2); nodeExist[t1] = nodeExist[t2] = 1; Add(t1, t2, 1); } // 求所有点为起点的单源最短路 int p = 0; for (int i = 0; i \u0026lt; MAX_N; i++) { if (!nodeExist[i]) continue; p++; if (!isPrint) printf(\u0026#34;%d/%d\\n\u0026#34;, p, n); Dijikstra(i); } fclose(fr); if (isPrint) fclose(fw); end = clock(); if (!isPrint) printf(\u0026#34;%fs\u0026#34;, double(end - start) / CLOCKS_PER_SEC); return 0; } bellman-ford 算法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; const int MAX_L = 30000, MAX_N = 30000; int dis[MAX_N], nodeExist[MAX_N], u[MAX_L], v[MAX_L], w[MAX_L]; int n, m; bool isPrint = 0; void bellmanFord(int origin) { memset(dis, 0x7F, sizeof(dis)); dis[origin] = 0; for (int i = 0; i \u0026lt; MAX_L; i++) if (u[i] == origin) dis[v[i]] = 1; for (int k = 1; k \u0026lt;= n; k++) for (int i = 1; i \u0026lt;= m; i++) if (dis[v[i]] \u0026gt; dis[u[i]] + w[i]) dis[v[i]] = dis[u[i]] + w[i]; if (isPrint) { printf(\u0026#34;---- Now Start Node IS %d ----\\n\u0026#34;, origin); for (auto i = 0; i \u0026lt; MAX_N; i++) if (nodeExist[i]) { if (dis[i] == 2139062143) printf(\u0026#34;%d-\u0026gt;%d: inf\\n\u0026#34;, origin, i); else printf(\u0026#34;%d-\u0026gt;%d: %d\\n\u0026#34;, origin, i, dis[i]); } } } int main() { clock_t start, end; start = clock(); FILE *fr, *fw; fr = freopen(\u0026#34;small.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); if (isPrint) fw = freopen(\u0026#34;out_small.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;u[i],\u0026amp;v[i]); nodeExist[v[i]] = nodeExist[u[i]] = w[i] = 1; } // 求所有点为起点的单源最短路 int p = 0; for (int i = 0; i \u0026lt; MAX_N; i++) if (nodeExist[i]) { p++; bellmanFord(i); if (!isPrint) printf(\u0026#34;%d/%d\\n\u0026#34;, p, n); } fclose(fr); if (isPrint) fclose(fw); end = clock(); if (!isPrint) printf(\u0026#34;%fs\u0026#34;, double(end - start) / CLOCKS_PER_SEC); return 0; } dis 数组作用与迪杰斯特拉算法相同。u、v、w 三个数组用来记录边的信息。\n第 i 条边存储在 u[i] v[i] w[i]中，表示从顶点 u[i]到到顶点 v[i]的边权值为 w[i].\nSPFA 算法 设立一个先进先出的队列 q 用来保存待优化的结点，优化时每次取出队首结点 u，并且用 u 点当前的最短路径估计值对离开 u 点所指向的结点 v 进行松弛操作，如果 v 点的最短路径估计值有所调整，且 v 点不在当前的队列中，就将 v 点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。\ndis[i] \u0026gt; dis[v] + a[v][i] \u0026ldquo;\u0026gt;\u0026ldquo;改为\u0026rdquo;\u0026lt;\u0026ldquo;后可求最长路\n代码示例：\nvoid spfa(int s) { for (int i = 0; i \u0026lt;= n; i++) dis[i] = 99999999; //初始化每点i到s的距离 dis[s] = 0; vis[s] = 1; q.push(s); //队列初始化,s为起点,dis数组作用与bellman-ford算法相同 int i, v; while (!q.empty()) { //队列非空 v = q.front();//取队首元素 vis[v] = 0;//释放队首结点，因为这节点可能下次用来松弛其它节点，重新入队 for (i = 0; i \u0026lt;= n; i++) //对所有顶点 if (a[v][i] \u0026gt; 0 \u0026amp;\u0026amp; dis[i] \u0026gt; dis[v] + a[v][i]) { //节点s到节点i通过节点v松弛 dis[i] = dis[v] + a[v][i]; //修改最短路 if (vis[i] == 0) { //如果扩展结点i不在队列中，入队 q.push(i); vis[i] = 1; } } } } ","date":"2021-02-18T20:52:34Z","permalink":"https://aecra.github.io/article/shortest-path-problem/","title":"最短路问题"},{"content":"数据库的好处 持久化数据到本地\n可以实现结构化查询，方便管理\n数据库相关概念 DB：数据库，保存一组有组织的数据的容器\nDBMS：数据库管理系统，又称为数据库软件（产品），用于管理 DB 中的数据\nSQL:结构化查询语言，用于和 DBMS 通信的语言\n数据库存储数据的特点 将数据放到表中，表再放到库中\n一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。\n表具有一些特性，这些特性定义了数据在表中如何存储，类似 java 中 “类”的设计。\n表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似 java 中的”属性”\n表中的数据是按行存储的，每一行类似于 java 中的“对象”。\nMySQL 产品的介绍和安装 MySQL 服务的启动和停止 方式一：计算机——右击管理——服务 方式二：通过管理员身份运行 net start 服务名（启动服务） net stop 服务名（停止服务） MySQL 服务的登录和退出 方式一：通过mysql自带的客户端 只限于root用户 方式二：通过windows自带的客户端 登录： mysql 【-h主机名 -P端口号 】-u用户名 -p密码 退出： exit或ctrl+C MySQL 的常见命令 # 查看当前所有的数据库 show databases; # 打开指定的库 use 库名 # 查看当前库的所有表 show tables; # 查看其它库的所有表 show tables from 库名; # 创建表 create table 表名( 列名 列类型, 列名 列类型， 。。。 ); # 查看表结构 desc 表名; # 查看服务器的版本 # 方式一：登录到mysql服务端 select version(); # 方式二：没有登录到mysql服务端 mysql --version # 或 mysql --V MySQL 的语法规范 不区分大小写,但建议关键字大写，表名、列名小写\n每条命令最好用分号结尾\n每条命令根据需要，可以进行缩进 或换行\n注释\n单行注释：#注释文字\n单行注释：\u0026ndash; 注释文字\n多行注释：/* 注释文字 */\nSQL 的语言分类 DQL（Data Query Language）：数据查询语言\nselect\nDML(Data Manipulate Language):数据操作语言\ninsert 、update、delete\nDDL（Data Define Languge）：数据定义语言\ncreate、drop、alter\nTCL（Transaction Control Language）：事务控制语言\ncommit、rollback\nSQL 的常见命令 # 查看所有的数据库 show databases; # 打开指定 的库 use 库名; # 显示库中的所有表 show tables; # 显示指定库中的所有表 show tables from 库名; # 创建表 create table 表名( 字段名 字段类型, 字段名 字段类型 ); # 查看指定表的结构 desc 表名; # 显示表中的所有数据 select * from 表名; DQL 语句 进阶 1：基础查询 语法：\nSELECT 要查询的东西 FROM 表名; 类似于 Java 中 :System.out.println(要打印的东西);\n特点：\n通过 select 查询完的结果 ，是一个虚拟的表格，不是真实存在\n要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数\n起别名\nselect last_name as 姓; select last_name 姓; 去重\nselect distinct department_id from employees; +号的作用\n# 两者都为数值型，则做加法运算 select 100+90; # 一个是字符型，一个是数值型，将字符型转换为数值型做加法运算 select \u0026#39;100\u0026#39;+90; # 一个是字符型，一个是数值型，将字符型转换为数值型做加法运算，转换失败则置为零 select \u0026#39;jhon\u0026#39;+10; # 一方为null，则结果肯定为null select null+10; 进阶 2：条件查询 条件查询：根据条件过滤原始表的数据，查询到想要的数据\n语法：\nselect 要查询的字段|表达式|常量值|函数 from 表 where 条件; 分类：\n一、条件表达式\n示例：salary\u0026gt;10000\n条件运算符：\n\u0026ldquo;\u0026gt; \u0026lt; \u0026gt;= \u0026lt;= = != \u0026lt;\u0026gt;\n二、逻辑表达式\n示例：salary\u0026gt;10000 \u0026amp;\u0026amp; salary\u0026lt;20000\n逻辑运算符：\nand（\u0026amp;\u0026amp;）:两个条件如果同时成立，结果为 true，否则为 false or(||)：两个条件只要有一个成立，结果为 true，否则为 false not(!)：如果条件成立，则 not 后为 false，否则为 true\n三、模糊查询\n示例：last_name like \u0026lsquo;_a%\u0026rsquo;\nlike、between and、in、is null\n进阶 3：排序查询 语法：\nselect 要查询的东西 from 表 where 条件 order by 排序的字段|表达式|函数|别名 【asc|desc】 进阶 4：常见函数 一、单行函数\n字符函数\nconcat 拼接\nsubstr 截取子串\nupper 转换成大写\nlower 转换成小写\ntrim 去前后指定的空格和字符\nltrim 去左边空格\nrtrim 去右边空格\nreplace 替换\nlpad 左填充\nrpad 右填充\ninstr 返回子串第一次出现的索引\nlength 获取字节个数\n数学函数\nround 四舍五入\nrand 随机数\nfloor 向下取整\nceil 向上取整\nmod 取余\ntruncate 截断\n日期函数\nnow 当前系统日期+时间\ncurdate 当前系统日期\ncurtime 当前系统时间\nstr_to_date 将字符转换成日期\ndate_format 将日期转换成字符\n流程控制函数\nif 处理双分支\ncase 语句 处理多分支,情况 1：处理等值判断,情况 2：处理条件判断\n其他函数\nversion 版本\ndatabase 当前库\nuser 当前连接用户\n二、分组函数\nsum 求和\nmax 最大值\nmin 最小值\navg 平均值\ncount 计数\n特点：\n以上五个分组函数都忽略 null 值，除了 count(*)\nsum 和 avg 一般用于处理数值型 max、min、count 可以处理任何数据类型\n都可以搭配 distinct 使用，用于统计去重后的结果\ncount 的参数可以支持： 字段、、常量值，一般放 1 建议使用 count()\n进阶 5：分组查询 语法：\nselect 查询的字段，分组函数 from 表 group by 分组的字段 特点：\n可以按单个字段分组\n和分组函数一同查询的字段最好是分组后的字段\n分组筛选\n针对的表 位置 关键字 分组前筛选 原始表 group by 的前面 where 分组后筛选 分组后的结果集 group by 的后面 having 可以按多个字段分组，字段之间用逗号隔开\n可以支持排序\nhaving 后可以支持别名\n分组函数做条件肯定放在 having 子句中\n能用分组前筛选的，就优先使用分组前筛选\n进阶 6：多表连接查询 笛卡尔乘积：如果连接条件省略或无效则会出现\n解决办法：添加上连接条件\n一、分类\n按年代分类：\nsql192 标准：内连接\nsql199 标准【推荐】：内连接+外链接（左外、右外）+交叉连接\n按功能分类\n内连接\n等值连接、非等值连接、自连接\n外连接\n左外连接、右外连接、全外连接\n交叉连接\n二、sql192 标准\n# 等值连接 select 表1.字段1, 表2.字段2 from 表1,表2 where 表1.字段3 = 表2.字段4 # 非等值连接 类比等值连接 # 自连接 SELECT e.last_name,m.last_name FROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`; 三、sql199 标准\nselect 字段，... from 表1 [inner|left outer|right outer|cross]join 表2 on 连接条件 [inner|left outer|right outer|cross]join 表3 on 连接条件 [where 筛选条件] [group by 分组字段] [having 分组后的筛选条件] [order by 排序的字段或表达式] 好处：语句上，连接条件和筛选条件实现了分离，简洁明了！\n进阶 7：子查询 含义：\n一条查询语句中又嵌套了另一条完整的 select 语句，其中被嵌套的 select 语句，称为子查询或内查询\n在外面的查询语句，称为主查询或外查询\n特点：\n子查询都放在小括号内\n子查询可以放在 from 后面、select 后面、where 后面、having 后面，但一般放在条件的右侧\n子查询优先于主查询执行，主查询使用了子查询的执行结果\n子查询根据查询结果的行数不同分为以下两类：\n单行子查询\n结果集只有一行\n一般搭配单行操作符使用：\u0026gt; \u0026lt; = \u0026lt;\u0026gt; \u0026gt;= \u0026lt;=\n非法使用子查询的情况：\n子查询的结果为一组值 子查询的结果为空 多行子查询\n结果集有多行\n一般搭配多行操作符使用：any、all、in、not in\nin： 属于子查询结果中的任意一个就行\nany 和 all 往往可以用其他查询代替\n进阶 8：分页查询 应用场景：\nweb 项目中需要根据用户的需求提交对应的分页查询的 sql 语句\n语法：\nselect 字段|表达式,... from 表 [where 条件] [group by 分组字段] [having 条件] [order by 排序的字段] limit [起始的条目索引,]条目数; 特点：\n起始条目索引从 0 开始\nlimit 子句放在查询语句的最后\n公式：select * from 表 limit （page-1）*sizePerPage,sizePerPage\n假如:\n每页显示条目数 sizePerPage\n要显示的页数 page\n进阶 9：联合查询 引入：\nunion 联合、合并\n语法：\nselect 字段|常量|表达式|函数 [from 表] [where 条件] union [all] select 字段|常量|表达式|函数 [from 表] [where 条件] union [all] select 字段|常量|表达式|函数 [from 表] [where 条件] union [all] ..... select 字段|常量|表达式|函数 [from 表] [where 条件] 特点：\n多条查询语句的查询的列数必须是一致的\n多条查询语句的查询的列的类型几乎相同\nunion 代表去重，union all 代表不去重\nDML 语句 插入 语法：\n# 方式一 insert into 表名(字段名，...) values(值1，...); # 方式二 insert into 表名 set 列名=值,列名=值,...; 特点：\n字段类型和值类型一致或兼容，而且一一对应\n可以为空的字段，可以不用插入值，或用 null 填充\n不可以为空的字段，必须插入值\n字段个数和值的个数必须一致\n字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致\n修改 修改单表语法：\nupdate 表名 set 字段=新值,字段=新值 [where 条件] 修改多表语法：\nupdate 表1 别名1,表2 别名2 set 字段=新值，字段=新值 where 连接条件 and 筛选条件 可以理解为把 select 改成 set 并变换位置\n删除 方式一：delete 语句\n单表的删除：\ndelete from 表名 [where 筛选条件] 多表的删除：\ndelete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 方式二：truncate 语句\ntruncate table 表名 两种方式的区别【面试题】\ntruncate 不能加 where 条件，而 delete 可以加 where 条件\ntruncate 的效率高一丢丢\ntruncate 删除带自增长的列的表后，如果再插入数据，数据从 1 开始 delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始\ntruncate 删除不能回滚，delete 删除可以回滚\nDDL 语句 库和表的管理 库的管理：\n# 创建库 create database [if not exists] 库名; # 删除库 drop database [if exists] 库名; # 修改字符集 alter database 库名 character set utf8; 表的管理：\n# 创建表 create table if not exists 表名( 字段名 字段的类型[(长度) 约束], 字段名 字段的类型[(长度) 约束], 字段名 字段的类型[(长度) 约束], ... 字段名 字段的类型[(长度) 约束] ); # 修改表名 alter table 原表名 rename [to] 新表名; # 修改表内字段 # add 添加字段 alter table 表名 add column 字段名 字段类型 [约束]; # modify 修改字段类型和约束 alter table 表名 modify column 字段名 [字段类型] [约束]; # drop 删除字段 alter table 表名 drop column 字段名; # change 修改字段名 alter table 表名 change column 原字段名 新字段名 字段类型 [约束]; # 删除表 drop table [if exists] studentinfo; # 复制表结构 create table 新表名 like 旧表名; # 复制表结构和内容 create table 新表名 select * from 旧表名; 常见类型 数值型： 整型：Tinyint、Smallint、Mediumint、Int/integer、Bigint 小数： 浮点型：float、double 定点型：dec、decimal 字符型： 较短的文本：char、varchar 较长的文本：text、blob 日期型： date、datetime、timestamp、time、year 常见约束 not null # 非空约束：用于保证该字段不能为空 default # 默认约束：用于保证该字段有默认值 unique #唯一约束：用于保证该字段的值具有唯一性且可空 check # 检查约束：mysql不支持 primary key # 主键约束：用于保证该字段的值具有唯一性且非空 foreign key # 外键约束：用于限制两个表的关系，该字段必须来自于主表的关联字段的值 列级约束\n# 直接在字段名和类型后面追加即可 # 只支持：默认、非空、主键、唯一 字段名 字段的类型[(长度) 约束] 表级约束\n# 在各个字段最下面，主要写外键约束 [constraint 约束名] 约束类型(字段名); [constraint 约束名] foreign key(字段名) references 主表名(外键字段名); 标识列 又称为自增长列\n含义：可以不用手动地插入值，系统提供默认的序列值\n关键字：auto_increment\n特点：\n标识列必须和主键搭配吗？不一定，但要求是一个 key\n一个表中最多一个标识列\n标识列只能是数字型\n标识列可以通过 set auto_increment_increment=3;设置步长，可以通过手动插入值设置起始值\n事务 通过一组逻辑操作单元（一组 DML——sql 语句），将数据从一种状态切换到另外一种状态\n特点 （ACID）\n原子性：要么都执行，要么都回滚\n一致性：保证数据的状态操作前和操作后保持一致\n隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰\n持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改\n相关步骤：\n开启事务 编写事务的一组逻辑操作单元（多条 sql 语句） 提交事务或回滚事务 事务的分类 隐式事务，没有明显的开启和结束事务的标志\n比如 insert、update、delete 语句本身就是一个事务\n显式事务，具有明显的开启和结束事务的标志\n# 1、开启事务 set autocommit=0; start transaction;# 可选 # 取消自动提交事务的功能 # 2、编写事务的一组逻辑操作单元（多条sql语句） insert update delete ... #3、提交事务或回滚事务 commit; rollback; # 其他 savepoint # 断点 commit to # 断点 rollback to # 断点 事务的隔离级别 事务并发问题如何发生？\n当多个事务同时操作同一个数据库的相同数据时 事务的并发问题有哪些？\n脏读：一个事务读取到了另外一个事务未提交的数据 不可重复读：同一个事务中，多次读取到的数据不一致 幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据 如何避免事务的并发问题？\n通过设置事务的隔离级别 read uncommitted read committed 可以避免脏读 repeatale read 可以避免脏读、不可重复读和一部分幻读 serializable 可以避免脏读、不可重复读和幻读 设置隔离级别：\nset session|global transaction isolation level 隔离级别名; 查看隔离级别：\nselect @@tx_isolation; 视图 含义：理解成一张虚拟的表\n视图和表的区别：\n使用方式 占用物理空间 视图 完全相同 不占用，仅仅保存的是 sql 逻辑 表 完全相同 占用 视图的好处：\nsql 语句提高重用性，效率高\n和表实现了分离，提高了安全性\n视图的创建 # 语法 CREATE VIEW 视图名 AS 查询语句; 视图的更新 # 方式一 CREATE OR REPLACE VIEW test_v7 AS SELECT last_name FROM employees WHERE employee_id\u0026gt;100; # 方式二 ALTER VIEW test_v7 AS SELECT employee_id FROM employees; 视图的删除 DROP VIEW test_v1,test_v2,test_v3; 视图结构的查看 DESC test_v7; SHOW CREATE VIEW test_v7; 视图数据的增删改查 # 查看视图的数据 SELECT * FROM my_v4; SELECT * FROM my_v1 WHERE last_name=\u0026#39;Partners\u0026#39;; # 插入视图的数据 INSERT INTO my_v4(last_name,department_id) VALUES(\u0026#39;虚竹\u0026#39;,90); # 修改视图的数据 UPDATE my_v4 SET last_name =\u0026#39;梦姑\u0026#39; WHERE last_name=\u0026#39;虚竹\u0026#39;; # 删除视图的数据 DELETE FROM my_v4; 某些视图不能更新 包含以下关键字的 sql 语句：分组函数、distinct、group by、having、union 或者 union all\n常量视图\nSelect 中包含子查询\njoin\nfrom 一个不能更新的视图\nwhere 子句的子查询引用了 from 子句中的表\n存储 含义：一组经过预先编译的 sql 语句的集合 好处：\n1、提高了 sql 语句的重用性，减少了开发程序员的压力 2、提高了效率 3、减少了传输次数\n分类：\n无返回无参\n仅仅带 in 类型，无返回有参\n仅仅带 out 类型，有返回无参\n既带 in 又带 out，有返回有参\n带 inout，有返回有参\n注意：in、out、inout 都可以在一个存储过程中带多个\n创建存储过程 语法：\ncreate procedure 存储过程名(in|out|inout 参数名 参数类型,...) begin 存储过程体 end 类似于方法：\n修饰符 返回类型 方法名(参数类型 参数名,...){ 方法体; } 注意\n# 需要设置新的结束标记 delimiter 新的结束标记 # 示例： delimiter $ CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) BEGIN sql语句1; sql语句2; END $ # 存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end # 参数前面的符号的意思 in:该参数只能作为输入 （该参数不能做返回值） out：该参数只能作为输出（该参数只能做返回值） inout：既能做输入又能做输出 调用存储过程 call 存储过程名(实参列表) 函数 创建函数 学过的函数：LENGTH、SUBSTR、CONCAT 等 语法：\nCREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型 BEGIN 函数体 END 调用函数 SELECT 函数名（实参列表） 函数和存储过程的区别 关键字 调用语法 返回值 应用场景 函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个 存储过程 PROCEDURE CALL 存储过程() 可以有 0 个或多个 一般用于更新 流程控制结构 系统变量 一、全局变量\n作用域：针对于所有会话（连接）有效，但不能跨重启\n# 查看所有全局变量 SHOW GLOBAL VARIABLES; # 查看满足条件的部分系统变量 SHOW GLOBAL VARIABLES LIKE \u0026#39;%char%\u0026#39;; # 查看指定的系统变量的值 SELECT @@global.autocommit; # 为某个系统变量赋值 SET @@global.autocommit=0; SET GLOBAL autocommit=0; 二、会话变量\n作用域：针对于当前会话（连接）有效\n# 查看所有会话变量 SHOW SESSION VARIABLES; # 查看满足条件的部分会话变量 SHOW SESSION VARIABLES LIKE \u0026#39;%char%\u0026#39;; # 查看指定的会话变量的值 SELECT @@autocommit; SELECT @@session.tx_isolation; # 为某个会话变量赋值 SET @@session.tx_isolation=\u0026#39;read-uncommitted\u0026#39;; SET SESSION tx_isolation=\u0026#39;read-committed\u0026#39;; 自定义变量 一、用户变量\n声明并初始化：\nSET @变量名=值; SET @变量名:=值; SELECT @变量名:=值; 赋值：\n方式一：一般用于赋简单的值 SET 变量名=值; SET 变量名:=值; SELECT 变量名:=值; 方式二：一般用于赋表 中的字段值 SELECT 字段名或表达式 INTO 变量 FROM 表; 使用：\nselect @变量名; 二、局部变量\n声明：\ndeclare 变量名 类型 [default 值]; 赋值：\n方式一：一般用于赋简单的值 SET 变量名=值; SET 变量名:=值; SELECT 变量名:=值; 方式二：一般用于赋表 中的字段值 SELECT 字段名或表达式 INTO 变量 FROM 表; 使用：\nselect 变量名 二者的区别：\n作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的 BEGIN END 中 BEGIN END 的第一句话 一般不用加@,需要指定类型 分支 一、if 函数\n语法：\nif(条件,值1,值2) 特点：可以用在任何位置\n二、case 语句\n语法：\n# 情况一：类似于switch # (如果是语句，需要加分号) # （如果是放在begin end中需要加上case，如果放在select后面不需要） case 表达式 when 值1 then 结果1或语句1 when 值2 then 结果2或语句2 ... else 结果n或语句n end [case] # 情况二：类似于多重if # (如果是语句，需要加分号) # （如果是放在begin end中需要加上case，如果放在select后面不需要） case when 条件1 then 结果1或语句1 when 条件2 then 结果2或语句2 ... else 结果n或语句n end [case] 特点：可以用在任何位置\n三、if elseif 语句\n语法：\nif 情况1 then 语句1; elseif 情况2 then 语句2; ... else 语句n; end if; 特点：只能用在 begin end 中！\n三者比较：\n应用场合 if 函数 简单双分支 case 结构 等值判断 的多分支 if 结构 区间判断 的多分支 循环 语法：\n[标签：] WHILE 循环条件 DO 循环体 END WHILE [标签]; 特点：\n只能放在 BEGIN END 里面\n如果要搭配 leave 跳转语句，需要使用标签，否则可以不用标签\nleave 类似于 java 中的 break 语句，跳出所在循环！！！\n","date":"2021-02-17T13:22:57Z","image":"https://static.aecra.cn/cover/mysql-database.jpg","permalink":"https://aecra.github.io/article/mysql-database/","title":"MySQL 数据库"},{"content":"功能：打字机效果、切换光标、设置打字时间间隔和光标闪烁时间间隔\n拓展：可以自行修改参数，实现自定义内容\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width\u0026#34; /\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;打字机\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { margin: 0; padding: 0 0 50px; background: #cddc39; font-family: \u0026#39;STXinwei\u0026#39;; color: #333; font-size: 16px; } div:first-child { padding: 35px 0 15px; text-align: center; } button { margin: 0 50px; width: 100px; height: 35px; border: 0; outline: 0; background: #fff; font-weight: 800; border-radius: 5px; font-size: inherit; font-family: inherit; cursor: pointer; } #wrap { margin: 0 auto; padding: 20px 15px; width: 800px; max-width: 85%; background: #fff; border-radius: 10px; text-align: justify; line-height: 1.3em; font-family: inherit; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button id=\u0026#34;start\u0026#34;\u0026gt;开始打字\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;change\u0026#34;\u0026gt;切换光标\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;pre id=\u0026#34;wrap\u0026#34;\u0026gt; //打字机 function Typewriter(arg){ //options var el = arg.el; var cursorFlash = arg.cursorFlash; var wordFlash = arg.wordFlash instanceof Array? arg.wordFlash : [0,400]; var m = wordFlash[0]; var n = wordFlash[1]; //创建过就不要再创建了 if(!el.typewriter){ el.typewriter = true; }else{ return false; } //初始化 var text = el.innerHTML; var len = 0; var text_box = document.createElement(\u0026#39;span\u0026#39;); var cursor_box = document.createElement(\u0026#39;span\u0026#39;); cursor_box.innerHTML = \u0026#39;|\u0026#39;; el.innerHTML = \u0026#39;\u0026#39;; el.appendChild(text_box); el.appendChild(cursor_box); //光标闪闪 setInterval(function (){ if(cursor_box.show){ cursor_box.style.opacity = 1; cursor_box.show = false; }else{ cursor_box.style.opacity = 0; cursor_box.show = true; } },cursorFlash); //添加字符 function addWords(){ if(len\u0026lt;=text.length){ text_box.innerHTML = text.slice(0,len); len++; setTimeout(addWords,Math.random()*(n-m)+m); } } //API this.changeCursor = function (){ cursor_box.innerHTML = cursor_box.innerHTML == \u0026#39;|\u0026#39;? \u0026#39;_\u0026#39; : \u0026#39;|\u0026#39;; } this.startWrite = function(){ if(!text_box.canadd){ text_box.canadd = true; addWords(); } } } var wrap = document.querySelector(\u0026#39;#wrap\u0026#39;); var start = document.querySelector(\u0026#39;#start\u0026#39;); var change = document.querySelector(\u0026#39;#change\u0026#39;); //创建打字机 var tw = new Typewriter({ el: wrap, cursorFlash: 400, wordFlash: [0,400] }); //开始 start.onclick = tw.startWrite; //切换光标 change.onclick = tw.changeCursor; \u0026lt;/pre \u0026gt; \u0026lt;script\u0026gt; //打字机 function Typewriter(arg) { //options var el = arg.el; var cursorFlash = arg.cursorFlash; var wordFlash = arg.wordFlash instanceof Array ? arg.wordFlash : [0, 400]; var m = wordFlash[0]; var n = wordFlash[1]; //创建过就不要再创建了 if (!el.typewriter) { el.typewriter = true; } else { return false; } //初始化 var text = el.innerHTML; var len = 0; var text_box = document.createElement(\u0026#39;span\u0026#39;); text_box.id = \u0026#39;typewriter-text\u0026#39;; var cursor_box = document.createElement(\u0026#39;span\u0026#39;); cursor_box.id = \u0026#39;typewriter-cursor\u0026#39;; cursor_box.innerHTML = \u0026#39;|\u0026#39;; el.innerHTML = \u0026#39;\u0026#39;; el.appendChild(text_box); el.appendChild(cursor_box); //光标闪闪 setInterval(function () { if (cursor_box.show) { cursor_box.style.opacity = 1; cursor_box.show = false; } else { cursor_box.style.opacity = 0; cursor_box.show = true; } }, cursorFlash); //添加字符 function addWords() { if (len \u0026lt;= text.length) { text_box.innerHTML = text.slice(0, len); len++; setTimeout(addWords, Math.random() * (n - m) + m); } } //API this.changeCursor = function () { cursor_box.innerHTML = cursor_box.innerHTML == \u0026#39;|\u0026#39; ? \u0026#39;_\u0026#39; : \u0026#39;|\u0026#39;; }; this.startWrite = function () { if (!text_box.canadd) { text_box.canadd = true; addWords(); } }; } var wrap = document.querySelector(\u0026#39;#wrap\u0026#39;); var start = document.querySelector(\u0026#39;#start\u0026#39;); var change = document.querySelector(\u0026#39;#change\u0026#39;); //创建打字机 var tw = new Typewriter({ el: wrap, cursorFlash: 400, wordFlash: [10, 400], }); //开始 start.onclick = tw.startWrite; //切换光标 change.onclick = tw.changeCursor; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2021-02-17T13:22:57Z","image":"https://static.aecra.cn/cover/using-javascript-to-achieve-typewriter-effect.jpg","permalink":"https://aecra.github.io/article/using-javascript-to-achieve-typewriter-effect/","title":"使用 JavaScript 实现打字机效果"},{"content":"引用 引用：\nint n = 4; int \u0026amp; r = n; // r引用了n,r的类型是int \u0026amp; 某个变量的引用，等价与这个变量，相当于这个变量的别名\n常引用：\nint n=4; const int \u0026amp; r = n; // r的类型是const int \u0026amp; r = 200; // 编译错误 n = 300; // 编译正确 不能通过常引用去修改引用的内容\n常引用和非常引用的转换：\nconst T \u0026amp;和 T \u0026amp;是不同的类型！！！\nT \u0026amp;类型的引用或 T \u0026amp;类型的变量可以用来初始化 const T \u0026amp;类型的引用。\nconst T \u0026amp;类型的常变量和 const T \u0026amp;类型的引用则不能用来初始化 T \u0026amp;类型的引用，除非进行强制类型转换。\nconst 关键字 定义常量：\nconst int ML = 100; const string NAME = \u0026#34;Tom\u0026#34;; 定义常量指针：\n// 不可通过常量指针修改其指向的内容 int n, m; const int *p = \u0026amp;n; *p = 5; // 编译错误 n = 4; // OK p = \u0026amp;m; // ok,常量指针的指向可以变化 常量指针不能赋值给非常量指针，反过来可以\n通过强制类型转换(int *)可以将常量指针赋值给非常量指针\n应用：\n函数参数为常量指针，可避免内部不小心改变参数指针所指地方的内容\n定义常引用：\n不能通过常引用去修改引用的变量\nint n; const int \u0026amp; r = n; r = 5;// 错误 n = 4;// 正确 动态内存分配 使用 new 运算符分配存储空间 1.分配一个变量\nP = new T; T 是任意类型名，P 是类型为 T*的指针\n动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给 P。例：\nint *pn; pn = new int; *pn = 5; 2.分配一个数组\nP = new T[N]; T：任意类型名\nP：类型为 T*的指针\nN：要分配的数组元素的个数，可以是整形表达式\n动态分配出一片大小为 sizeof(T)*N 字节的内存空间，并且将该内存空间的起始地址赋值给 P。\n使用 delete 释放分配出的空间 1.释放一个变量\nint *p = new int; *p = 5; delete p; delete p; // 异常，一片空间不能被delete多次 2.释放一个数组\nint *p = now int[10]; p[0] = 1; delete []p; // 该指针必须指向分配出来的数组，[]必须加，否则只释放一个变量的空间，而其余的将无法释放进而形成内存碎片 内联函数 1.函数调用是有时间开销的。如果函数本身只有几条语句，执行非常块，而且函数被反复执行很多次，相比 之下调用函教所产生的这个开销就会显得比较大。\n2.为了减少函数调用的开销，引入了内联函数机制。编 译器处理对内朕函数的调用语句时，是将整个函数的 代玛插入到调用语句处，而不会产生调用函数的语句。\n例：\ninline MAX(int a, int b){ if(a \u0026gt; b) return a; return b; } 函数重载 一个或多个函数，名字相同，然而参数个数或参数类型不同，这叫作函数的重载。\nint MAX(int n1, int n2){ } int MAX(double f1, double f2){ } int MAX(int n1, int n2, int n3){ } 函数重载使函数命名简单\n编译器通过调用语句中的函数实参的类型和个数判断应该调用哪个函数\n使用时应避免函数的二义性\n函数的缺省参数 C++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候．若相应位置不写参 数，参数就是缺省值。\nvoid func(int a, int b = 1, int c = 1){ } func(10); // 等效于func(10,1,1) func(10,4); // 等效于func(10,4,1) func(10,4,7); func(10, ,7); // 不行，只能最右边的连续若干个参数缺省 函数参数可缺省的目的在于提高程序的可扩充性\n在函数拓展时，只需增设缺省函数，原程序就不必修改\n类概述 概念\n类是定义同一类所有对象的变量和方法的蓝图或原型\n对象是由类定义的\n一个对象有属性和方法，属性是变量，方法是函数\n实例\nclass student{ public: int age; string name; int sex; void init(int age, string name, int sex_){ age = age, name = name, sex = sex_; } string namechange(string name_){ name = name_; } }; // 必须有分号 int main(){ student A;// A是一个对象 return 0; } 对象的内存分配\n对象所占的内存空间大小，等于所有成员变量的大小之和\n每个对象都有自己的内存空间，一个对象的成员变量改变不会影响其他对象\n对象间的运算\n可以使用“=”进行赋值运算，但不能使用“==”“！=”等运算符进行比较，除非进行运算符重载\n使用类的成员变量和成员函数\n用法一:对象.成员名\nstudent A; A.init(10, \u0026#34;Tom,1\u0026#34;); A.name = \u0026#34;Jack\u0026#34;; 用法二:指针-\u0026gt;成员名\nstudent A; shudent *p = \u0026amp;A; p-\u0026gt;init(10, \u0026#34;Tom,1\u0026#34;); // init()作用在p指向的对象上 p-\u0026gt;name = \u0026#34;Tom\u0026#34;; 用法三:引用.成员名\n类成员可访问范围 在类的定义中，用下列访问范围关键词来说明类成员可被访问的范围：\nprivate：私有成员，只能在成员函数内访问\npublic：公有成员，可以在任意地方访问\nprotected：保护成员\n以上三种关键字出现的次数和先后次序都没有限制。\nclass className{ private: 私有成员和属性 public： 公有属性和函数 protected： 保护属性和函数 }; 如果某个成员前面没有上述关键词，则缺省的被认为是私有成员\n在类的成员函数内部，能够访问：\n当前对象的全部属性、函数，同类其他对象的全部属性、函数。\n在类的成员函数以外的地方，只能够访问该类对象的共有成员\n设置私有成员的机制，叫“隐藏”\n“隐藏”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则，所有直接访问成员变量的语句都需要修改。\n与 struct 的区别是 struct 的未声明变量是公有成员\n类成员函数的重载和函数缺省 成员函数也可以重载\n成员函数也可以带缺省函数（注意避免二义性）\n构造函数 基本概念\n成员函数的一种\n名字与类名相同，可以有参数，不能有返回值（void 也不行）\n作用是对对象进行初始化，如给成员变量赋初值\n如果定义类是没写构造函数，则编译器生成一个默认的无参数的构造函数（默认构造函数无参数，不做任何操作）\n如果定义了构造函数，则编译器不生成默认的无参数的构造函数\n对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数\n一个类可以有多个构造函数\n例：\nclass student{ public: int age; string name; student(int age = 10, string name = \u0026#34;Tom\u0026#34;){ age = age, name = name; } }; 构造函数最好是 public 的，private 构造函数不能直接用来初始化对象\n构造函数在数组中应用\n初始化过程也会调用构造函数\n复制构造函数 基本概念\n只有一个参数，及对同类对象的引用\n形如 X::X(X\u0026amp;)或 X::X(const X \u0026amp;)，二者选一\n后者以常量对象作为参数\n不允许有形如 X::X(X)的构造函数\n如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能\n例：\nclass Complex{ private: double real,imag; public: Complex(const Complex \u0026amp; c){ real=c.real,imag=c.imag; } }; 起作用的三种情况\n当用一个对象去初始化同类的一个对象时\nComplex c2(c1); Complex c2 = c1; // 初始化语句，非赋值语句 如果某函数有一个参数是类 A 的对象。那么该函数调用时，类 A 的复制构造函数将被调用\n如果某函数的返回值是类 A 的对象，则函数返回时，A 的复制构造函数被调用时起作用。\n对象间赋值并不导致复制构造函数被调用\n类型转换构造函数 定义转换构造函数的目的是实现类的自动转换\n只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数\n当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量）\n例：\nclass Complex{ private: double real, imag; public: Complex(int c){ real = c, imag = 0; } }; // 显式类型转换构造函数： class Complex{ private: double real, imag; public: explicit Complex(int c){ real = c, imag = 0; } }; Complex c1; c1 = 9:// error 9不能被自动转换成一个临时Complex对象 c1 = Complex(p);// OK 析构函数 名字与类名相同，在前面加“~”，没有参数和返回值，一个类最多只能有一个析构函数\n析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。\n如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做\n如果定义了析构函数，则编译器不生成缺省的析构函数\n例：\nclass String{ priviate: char *p; public: String(){ p=new char[10]; } ~String(){ delete []p; } }; 析构函数和数组:\n对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用\nthis 指针 作用:\n其作用就是指向成员函数所作用的对象\n非静态成员函数中可以直接使用 this 来代表指向该函数作用的对象的指针\n例：\nthis-\u0026gt;real++;// 等价于 real++\n在函数中可使用*this 返回当前对象\n对象的空指针可以调用不使用成员变量的函数\n静态成员函数中不能使用 this 指针！\n因为静态成员函数并不具体作用与某个对象！\n因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数。\n静态成员 基本概念\n在定义前面加了 static 关键字的成员\n注意：\n1.普通成员变量每个对象有各自的一份，而静态成员变量一共就有一份，为所有对象共享。\n2.普通成员函数必须作用于某个对象，而静态成员函数并不具体作用于某个对象\n3.静态成员不需要通过对象就能访问\n4.静态成员变量本质上是集成到类中的全局变量，即使此类不存在一个对象，该静态成员变量也存在\n5.必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过\n6.在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数\n7.sizeof 运算符不会计算静态成员变量\n例：\nclass CRectangle{ private: int w, h; static int nTotalArea; // 静态成员变量 static int NtotalNumber; // 静态成员变量 public: CRectangle(int w, int h); ~CRectangle(); static void PrintTotal(); // 静态成员函数 }; 访问方法\n1.类名::成员名\nCRectangle::PrintTotal(); 2.对象名.成员名\nCRectangle r; r.PrintTotal(); 3.指针-\u0026gt;成员名\nCRectangle *p = \u0026amp;r; p-\u0026gt;PrintTotal(); 4.引用.成员名\nCRectangle \u0026amp;ref=r; int n =ref.nTotalNumber; 应用案例\n构造函数中对矩形数量单增，矩形面积增加\n特别注意在复制构造函数中要有构造函数相同的对静态成员变量的修改\n析构函数中对矩形数量单减，矩形面积减小\n初始化链表 class CTyre { private: int radius; int width; public: CTyre(int r, int w):radius(r),width(w){ } }; radius(r)相当于 int radius(r);是初始化。\n成员对象初始化列表中的参数可以是任意对象的表达式，可以包括函数、变量，只要表达式中的函数或变量有定义就行。\n成员对象和封闭类 基本概念\n成员对象是指一个类的成员是一个类的对象的此对象\n封闭类是指含有成员对象的类\n实例\nclass CTyre { private: int radius; int width; public: CTyre(int r,int w):radius(r),width(w){ } }; class CEngine { }; class CCar{ private: int price; CTyre tyre; CEngine engine; public: CCar(int p,int tr,int tw):price(p),tyre(tr,w){ } // tyre使用构造函数初始化，engine使用自动生成的无参构造函数初始化 }; 上例中，如果 CCar 类不定义构造函数，则下面的语句会编译出错：\nCCar car;\n因为编译器不明白 car.tyre 该如何初始化。 car.engine 的初始化没问题，用自动生成的无参构造函数即可。\n任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。\n封闭类构造函数和析构函数的执行顺序\n（1）封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类的构造函数。\n（2）对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与他们在成员初始化列表中出现的次序无关。\n（3）当对象类的对象消亡时，限制性封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反。\n常量对象、常量成员函数 基本概念\n常量对象：如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加 const 关键字。\n常量成员函数：在类的成员函数说明后面加上 const 关键字，则该成员函数称为常量成员函数。\n常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。\n实例\nclass Sample { public int value; void GetValue() const { value = 0; // wrong func(); // wrong } void func(); Sample(){} }; 常量成员函数的重载\n两个成员函数，名字和参数表都一样，但一个是 const，一个不是，算重载。\n调用时 常量成员对象调用常量成员函数，非常量成员对象先找非常量成员函数，如果没有调用常量成员函数。\n友元 友元分为友元函数和友元类\n（1）友元函数：一个类的友元函数，可以访问该类的私有成员\n​ 可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元。\n（2）友元类：如果 A 是 B 的友元类，那么 A 的成员函数可以访问 B 的私有成员\n友元使一个类可以修改其成员对象的私有成员，如果未声明友元则不可访问或修改其成员对象的私有成员。\n友元类之间的关系不能传递，不能继承\n运算符重载 基本概念 运算符重载的需求\nC++预定义的运算符，只能用于基本数据类型的运算：整型、实型、字符型、逻辑型……\n+、-、*、/、%、^、\u0026amp;、\u0026raquo;、!=、=、\u0026laquo;、|、!……\n目的：实现预期功能、使代码更简洁\n基本概念\n运算符重载，就是对已有的运算符（C++中预定义的运算符）赋予多重的含义，使同一运算符作用于不同的数据时导致不同类型的行为。\n目的：拓展 C++中提供的运算符的适用范围，使之能作用于对象。\n运算符重载的形式\n（1）运算符重载的实质是函数重载\n（2）可以重载为普通函数，也可以重载为成员函数\n（3）把含运算符的表达式转换成对运算符函数的调用\n（4）把运算符的操作数转换成运算符函数的参数\n（5）运算符被多次重载时，根据实参的类型决定调用哪个运算符函数\n运算符重载的形式\n返回值类型 operator 运算符(形参表) { } 重载为成员函数时，参数个数为运算符目数减一\n重载为普通函数时，参数个数为运算符目数\n赋值运算符的重载 赋值运算符‘=’重载\n“=”只能重载为成员函数\nclass String{ private: char *str; public: String():str(new char[1]) { str[0] = 0; } const char * c_str() { return str; }; String \u0026amp; oprator = (const char *s); String::~String() { delete[] str; } }; String \u0026amp; String::operator = (const char *s) { // 重载“=”以使得obj=“hello”能够成立 delete[] str; str = new char[strlen(s)+1]; strcpy(str, s); return *this; } 深拷贝和浅拷贝(复制构造函数应同深拷贝)\n浅拷贝：\n原生的“=”只能使两个对象的内存完全相同\n而如果成员有指针，只改变了指针指向的地址，而产生一系列问题\n深拷贝：\n重载“=”重新分配内存空间，深度拷贝\n深拷贝的问题：\ns = s; 此时直接 delete[] str; 会导致逻辑错误，因此重载时先判断指针指向的地址是否相同，再行处理\nString \u0026amp; String::operator = (const char *s) { // 重载“=”以使得obj=“hello”能够成立 if(this = \u0026amp; s) return *this; delete[] str; str = new char[strlen(s)+1]; strcpy(str, s); return *this; } 对 operator=返回值类型的讨论\n对运算符重载时，应尽量保留原运算符的特性\na = b = c; (a = b) = c; // 会修改a的值 运算符重载为友元 重载为成员函数不够用了\n(1,1)+1;\n1+(1,1);\n复数与实数相加\n流插入运算符和流提取运算符的重载 流输入运算符的重载\ncout 是在 iostream 中定义的，ostream 类的对象\n“\u0026laquo;”能用在 cout 上是因为，在 iostream 中对“\u0026laquo;”进行了重载。\nostream \u0026amp; ostream::operator\u0026lt;\u0026lt;(int n) { ……// 输出n的代码 return *this; } 实际应用时使用的是普通函数的重载\nclass Student { public: int age; }; Student a; ostream \u0026amp; ostream::operator\u0026lt;\u0026lt;(ostream \u0026amp; o,const Student \u0026amp; as) { o\u0026lt;\u0026lt;as.age; return o; } cout\u0026lt;\u0026lt;a; 流输出运算符的重载\nistream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp; is,Complex \u0026amp; c) { string s; is\u0026gt;\u0026gt;s; int pos = s.find(\u0026#34;+\u0026#34;,0); string sTmp = s.substr(0,pos); // 分离出代表实部的字符串 c.real = atof(sTmo.c_str()); // atof库函数能将const char*指针指向的内容转换成float sTmp = s.substr(pos+1,s.length()-pos-2); // 分离出代表虚部的字符串 c.imag = stof(sTmp.c_str()); return is; } 类型转换运算符的重载 #include \u0026lt;iostream\u0026gt; using namespace std; class Complex { double real,imag; public: Complex(double r = 0,double i = 0):real(r),imag(i){ }; operator double () { return real; } // 重载强制类型转换运算符 double }; int main() { Complex c(1.2,3.4); cout \u0026lt;\u0026lt; (double)c \u0026lt;\u0026lt; endl;// 输出1.2 double n = 2 + c;// 等价于 double n=2+c.operator double() cout\u0026lt;\u0026lt;n;// 输出 3.2 return 0; } 自增自减运算符的重载 ++、\u0026ndash;有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，c++规定\n前置运算符作为一元运算符重载\n重载为成员函数：\nT \u0026amp; operator++(); T \u0026amp; operator--(); 重载为全局函数：\nT1 \u0026amp; operator++(T2); T1 \u0026amp; operator--(T2); 后置运算符作为二元运算符重载，多写一个没用的参数\n重载为成员函数：\nT \u0026amp; operator++(int); T \u0026amp; operator--(int); 重载为全局函数：\nT1 \u0026amp; operator++(T2,int); T1 \u0026amp; operator--(T2,int); 但是在没有后置运算符重载而有前置重载的情况下，\n在 vs 中，obj++ 也调用前置重载，而 dev 则令 obj++ 编译出错\n前置形式的++、\u0026ndash;返回变量的引用\n后置形式的++、\u0026ndash;返回临时变量\n\u0026ndash;i 更快\n运算符重载的注意事项 1.C++不允许定义新的运算符\n2.重载后运算符的含义应该符合日常习惯\n3.运算符重载不改变运算符的优先级\n4.一下运算符不能被重载：“.”、“.*”、“::”、“?:”、sizeof；\n5.重载运算符()、[]、-\u0026gt;或赋值运算符=时，运算符重载函数必须声明为类的成员函数。\n继承和派生的基本概念 继承：在定义一个新的类 B 时，如果该类与某个已有的类 A 相似（指的是 B 拥有 A 的全部特点），那么可以把 A 作为一个基类，而把 B 作为基类的一个派生类（也称子类）。\n派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。\n派生类一经定义后，可以独立使用，不依赖于基类。\n派生类拥有基类的全部成员函数和成员变量，不论是 private、protected、public。\n在派生类的各个成员函数中，不能访问基类中的 private 成员。\n派生类的写法：\nclass 派生类名:public 基类名 { }; 派生类中的函数可以对基类函数进行覆盖，但依旧可以调用基类的相同函数。\n派生类对象的内存空间\n派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。**在派生类对象中，包含着基类对象，**而且基类对象的存储位置位于派生类对象新增的成员变量之前。\n继承关系和复合关系 类之间的两种关系\n1，继承：“是”关系\n继承 A，B 是基类 A 的派生类。\n逻辑上要求：“一个 B 对象也是一个 A 对象”。\n2.复合：“有”关系\n类 C 中“有”成员变量 k，k 是类 D 的对象，则 C 和 D 是复合关系\n一般逻辑上要求：“D 对象是 C 对象的固有属性或组成部分”。\n对于人养狗的情况，使用指针分别指向狗和人\n派生类覆盖基类成员 派生类可以定义一个和基类成员同名的成员，这叫覆盖。在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要用作用域符号::。\n成员类型访问权限：\n类的 private 成员：\n​ - 基类的成员函数\n​ - 基类的友元函数\n基类的 public 成员：\n​ - 基类的成员函数\n​ - 基类的友元函数\n​ - 派生类的成员函数\n​ - 派生类的友元函数\n​ - 其他函数\n基类的 protected 成员：\n​ - 基类的成员函数\n​ - 基类的友元函数\n​ - 派生类的成员函数可以访问当前对象的基类的保护成员\n派生类的构造函数 class Bug { private: int nLegs; int nColor; public: int nType; Bug(int legs, int color); void PrintBug(){ }; } class FlyBug: public Bug { int nWings; public: FlyBug(int legs, int color, int wings); } Bug::Bug(int legs, int color) { nLegs = legs; nColor = color; } // 错误的FlyBug构造函数 FlyBug::FlyBug(int legs, int color, int wings) { nlegs = legs;// 不能访问 nColor = color;// 不能访问 nType = 1;// OK nWings = wings; } // 正确的FlyBug构造函数 FlyBug::FlyBug(int legs, int color, int wings):Bug(legs,color) { nWing = wings; } 在创建派生类的对象时，需要调用基类的构造函数初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。\n调用基类的构造函数的两种方法\n- 显式方式：在派生类的构造函数中，为基类的构造函数提供参数。\n​ derived::derived(arg_derived-list):base(arg_base-list)\n- 隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数。\n派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。\n封闭派生类对象的构造函数的执行顺序：\n基类的构造函数-\u0026gt;成员对象类的构造函数-\u0026gt;派生类自己的构造函数\n公有继承的赋值兼容规则 public 继承的赋值兼容规则：\n1.派生类的对象可以赋值给基类对象\n2.派生类对象可以初始化基类引用\n3.派生类对象的地址可以赋值给基类指针\n直接基类和间接基类\nA 派生出 B，B 派生出 C，C 派生出 D，D 派生出 E……\n可以连续继承\n","date":"2021-02-16T20:01:41Z","image":"https://static.aecra.cn/cover/cpp-object-oriented.jpg","permalink":"https://aecra.github.io/article/cpp-object-oriented/","title":"C++ 面向对象"},{"content":"一、xlrd 和 xlwt 需要先执行 pip3 install xlrd 和 pip3 install xlwt 安装模块\n对于 excel 来说，整个 excel 文件称为工作簿，工作簿中的每个页称为工作表，工作表又由单元格组成。\n对于 xlrd 和 xlwt，行数和列数从 0 开始，单元格的行和列也从 0 开始，例如 sheet.row_values(2)表示第三行的内容，sheet.cell(1,2).value 表示第二行第三列单元格的内容。\n1.xlrd 模块读取 excel 文件 使用 xlrd 模块之前需要先导入 import xlrd，xlrd 模块既可读取 xls 文件也可读取 xlsx 文件。\n获取工作簿对象\nbook = xlrd.open_workbook(\u0026#39;excel文件名称\u0026#39;) 获取所有工作表名称，结果为列表\nnames = book.sheet_names() 根据索引获取工作表对象\nsheet = book.sheet_by_index(i) 根据名称获取工作表对象\nsheet = book.sheet_by_name(\u0026#39;工作表名称\u0026#39;) 获取工作表行数\nrows = sheet.nrows 获取工作表列数\ncols = sheet.ncols 获取工作表某一行的内容，结果为列表 【sheet.row(i)，列表】\nrow = sheet.row_values(i) 获取工作表某一列的内容，结果为列表 【sheet.col(i)，列表】\ncol = sheet.col_values(i) 获取工作表某一单元格的内容，结果为字符串或数值 【sheet.cell(0,0)，xlrd.sheet.Cell 对象】\ncell = sheet.cell_value(m,n) sheet.cell(m,n).value sheet.row(m)[n].value sheet.col(n)[m].value 2.xlwt 写入 excel 文件 使用 xlwt 模块之前需要先导入 import xlwt，xlwt 模块只能写 xls 文件，不能写 xlsx 文件(写 xlsx 程序不会报错，但最后文件无法直接打开，会报错)。\n创建工作簿，如果写入中文为乱码，可添加参数 encoding = \u0026lsquo;utf-8\u0026rsquo;\nbook = xlwt.Workbook() 创建工作表\nsheet = book.add_sheet(\u0026#39;Sheet1\u0026#39;) 向单元格写入内容\nsheet.write(m,n,\u0026#39;内容1\u0026#39;) sheet.write(x,y,\u0026#39;内容2\u0026#39;) 保存工作簿，默认保存在 py 文件相同路径下，如果该路径下有相同文件，会被新创建的文件覆盖，即 xlwt 不能修改文件。\nbook.save(\u0026#39;excel文件名称\u0026#39;) 二、openpyxl 模块 openpyxl 模块可实现对 excel 文件的读、写和修改，只能处理 xlsx 文件，不能处理 xls 文件，使用之前同样需要先安装该模块，再导入 import openpyxl。\n对于 openpyxl，行数和列数都从 1 开始，单元格的行和列也从 1 开始。例如 sheet.cell(1,2).value 表示第一行第二列单元格的内容\n1.openpyxl 读取 excel 文件 获取工作簿对象\nbook = openpyxl.load_workbook(\u0026#39;excel文件名称\u0026#39;) 获取所有工作表名称\nnames = book.sheetnames 获取工作表对象\nsheet1 = book.worksheets[n] sheet2 = book[\u0026#39;工作表名称\u0026#39;] sheet3 = book[book.sheetnames[n]] 获取工作表名称\ntitle = sheet1.title 获取工作表行数\nrows = sheet1.max_row 获取工作表列数\ncols = sheet1.max_column 获取某一单元格内容\ncell = sheet.cell(1,2).value sheet[\u0026#39;B1\u0026#39;].value 2.行和列生成器 对于 xlrd 模块来说，可直接通过 sheet.row[i]和 sheet.col[i]获取行和列的内容.但是对于 openpyxl 模块来说，无法直接获取某一行或列的内容，openpyxl 模块的 sheet.rows 和 sheet.columns 表示行和列的生成器，即 generator object，需要通过循环或转换成列表、元组的形式得到行或列的值。\n如果要获取某一行或者列的内容，可将行、列生成器对象转换成列表或者元组，再循环列表或者元组得到内容。\n前面说过 openpyxl 模块的行和列都从 1 开始，但是由于将生成器转化成了列表 list(sheet.rows)，而列表的索引从 0 开始，因此 list(sheet.rows)[1]还是表示第二行的内容，不是第一行的内容。\n3.openpyxl 写 excel 文件 创建工作簿，如果写入中文为乱码，可添加参数 encoding = \u0026lsquo;utf-8\u0026rsquo;\nbook = openpyxl.Workbook() 创建工作表，0 表示创建的工作表在工作薄最前面\nsheet = book.create_sheet(\u0026#39;工作表名称\u0026#39;,0) 向单元格写入内容\nsheet.cell(m,n,\u0026#39;内容1\u0026#39;) sheet.cell(x,y,\u0026#39;内容2\u0026#39;) 保存工作簿，默认保存在 py 文件相同路径下，如果该路径下有相同文件，会被新创建的文件覆盖。\nbook.save(\u0026#39;excel文件名称\u0026#39;) 4.openpyxl 修改 excel 文件 在第 m 行、第 n 列前面插入行、列\nsheet.insert_rows(m) sheet.insert_cols(n) 表示删除第 m 行、第 n 列\nsheet.delete_rows(m) sheet.delete_cols(n) 修改单元格内容\nsheet.cell(m,n) = \u0026#39;内容1\u0026#39; sheet[\u0026#39;B3\u0026#39;] = \u0026#39;内容2\u0026#39; 在最后追加行\nsheet.append(可迭代对象) ","date":"2021-02-12T13:23:47Z","image":"https://static.aecra.cn/cover/manipulating-tables-with-python.jpg","permalink":"https://aecra.github.io/article/manipulating-tables-with-python/","title":"用 python 操作表格"},{"content":"jQuery 简介 JavaScript 库的概念 JavaScript 开发的过程中，处理浏览器的兼容很复杂而且很耗时，于是一些封装了这些操作的库应运而生。这些库还会把一些常用的代码进行封装。\n把一些常用到的方法写到一个单独的 js 文件，使用的时候直接去引用这 js 文件就可以了。（animate.js、common.js）\n常见的 JavaScript 库 - jQuery、Prototype、MooTools。其中 jQuery 是最常用的一个。\njQuery 其实就是一个 js 文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的 common.js，因此我们学习 jQuery，其实就是学习 jQuery 这个 js 文件中封装的一大堆方法。\njQuery 的优点好处 jQuery 设计的宗旨是\u0026rsquo;Write Less，Do More\u0026rsquo;，即倡导写更少的代码，做更多的事情。它封装 JavaScript 常用的功能代码，提供一种简便的操作，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互。\njQuery 的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的 css 选择器，并且可对 CSS 选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery 兼容各种主流浏览器。\n极大地简化了 JavaScript 编程。\njQuery 的版本 jQuery版本有很多，分为1.x 2.x 3.x 1.x版本：能够兼容IE678浏览器 2.x版本：不兼容IE678浏览器 1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。 3.x版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678） 国内多数网站还在使用1.x的版本 [jQuery 官网](http:// jquery.com/)\n体验 jQuery 案例：让 div 显示与设置内容\n使用 JavaScript 开发过程中，有许多不便之处\n- 查找元素的方法太少，麻烦。 - 遍历伪数组很麻烦，通常要嵌套一大堆的for循环。 - 有兼容性问题。 - 想要实现简单的动画效果，也很麻烦 - 代码冗余。 使用 jQuery\n$(document).ready(function () { $(\u0026#39;#btn1\u0026#39;).click(function () { // 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。 $(\u0026#39;div\u0026#39;).show(200); }); $(\u0026#39;#btn2\u0026#39;).click(function () { $(\u0026#39;div\u0026#39;).text(\u0026#39;我是内容\u0026#39;); }); }); 优点总结\n- 查找元素的方法多种多样，非常灵活 - 拥有隐式迭代特性，因此不再需要手写for循环了。 - 完全没有兼容性问题。 - 实现动画非常简单，而且功能更加的强大。 - 代码简单、粗暴。 jQuery 中顶级对象 jQuery 中的顶级对象是$或 jQuery\n获取 jQuery 对象、入口函数、高级功能\n注意：jQuery 中的$和 JQuery 关键字本身为同一对象；\njQuery 中页面加载事件 使用 jQuery 的三个步骤：\n引入 jQuery 文件、入口函数、功能实现\n关于 jQuery 的入口函数：\n// 第一种写法 $(document).ready(function () {}); // 第二种写法 $(function () {}); jQuery 入口函数与 window.onload 的对比\nJavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。 jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。 jQuery 对象和 DOM 对象 jQuery 对象和 DOM 对象的区别 DOM 对象 用原生JavaScript获取的DOM对象 通过document.getElementById() 反馈的是元素(DOM对象) 通过document.getElementsByTagName()获取到的是什么？ 伪数组(集合)，集合中的每一个对象是DOM对象 jQuery 对象 jQuery对象用$()的方式获取的对象 jQuery对象又可以叫做包装集(包装的DOM对象的集合) 区别 jQuery 对象不能使用 DOM 对象的成员，DOM 对象不能使用 jQuery 对象的成员\n// DOM对象 var box = document.getElementById(\u0026#39;box\u0026#39;); // 错误 box.text(\u0026#39;hello\u0026#39;); // 正确 box.innerText = \u0026#39;hello\u0026#39;; // jQuery对象，jQuery对象加前缀$，用以区分DOM对象 var $box = $(\u0026#39;#box\u0026#39;); // 错误 $box.innerText = \u0026#39;hello\u0026#39;; // 正确 $box.text(\u0026#39;hello\u0026#39;); jQuery 对象和 DOM 对象的相互转换 jQuery对象转换成DOM对象： jQuery对象.get(索引值); jQuery对象[索引值] jQuery对象是包装集(集合)，从集合中取数据可以使用索引的方式 DOM对象转换成jQuery对象： $(DOM对象) 只有这一种方法; 选择器 jQuery 选择器是 jQuery 为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery 选择器返回的是 jQuery 对象。\njQuery 选择器有很多，基本兼容了 CSS1 到 CSS3 所有的选择器，并且 jQuery 还添加了很多更加复杂的选择器。（查看 jQuery 文档）\njQuery 选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。\njQuery 基本选择器 名称 用法 描述 ID 选择器 $(\u0026rsquo;#id\u0026rsquo;); 获取指定 ID 的元素 类选择器 $(\u0026rsquo;.class\u0026rsquo;); 获取同一类 class 的元素 标签选择器 $(\u0026lsquo;div\u0026rsquo;); 获取同一类标签的所有元素 并集选择器 $(\u0026lsquo;div,p,li\u0026rsquo;); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(\u0026lsquo;div.redClass\u0026rsquo;); 获取 class 为 redClass 的 div 元素 总结：跟 css 的选择器用法一模一样。\njQuery 层级选择器 名称 用法 描述 子代选择器 $(\u0026lsquo;ul \u0026gt; li\u0026rsquo;); 使用-号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(\u0026lsquo;ul li\u0026rsquo;); 使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等 跟 CSS 的选择器一模一样。\njQuery 过滤选择器 这类选择器都带冒号:\n名称 用法 描述 :eq（index） $(\u0026rsquo;li:eq(2)\u0026rsquo;).css(\u0026lsquo;color\u0026rsquo;, \u0026lsquo;red\u0026rsquo;); 获取到的 li 元素中，选择索引号为 2 的元素，索引号 index 从 0 开始。 :odd $(\u0026rsquo;li:odd\u0026rsquo;).css(\u0026lsquo;color\u0026rsquo;, \u0026lsquo;red\u0026rsquo;); 获取到的 li 元素中，选择索引号为奇数的元素 :even $(\u0026rsquo;li:even\u0026rsquo;).css(\u0026lsquo;color\u0026rsquo;, \u0026lsquo;red\u0026rsquo;); 获取到的 li 元素中，选择索引号为偶数的元素 jQuery 筛选选择器(方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。\n名称 用法 描述 children(selector) $(\u0026lsquo;ul\u0026rsquo;).children(\u0026rsquo;li\u0026rsquo;) 相当于$(\u0026lsquo;ul-li\u0026rsquo;)，子类选择器 find(selector) $(\u0026lsquo;ul\u0026rsquo;).find(\u0026rsquo;li\u0026rsquo;); 相当于$(\u0026lsquo;ul li\u0026rsquo;),后代选择器 siblings(selector) $(\u0026rsquo;#first\u0026rsquo;).siblings(\u0026rsquo;li\u0026rsquo;); 查找兄弟节点，不包括自己本身。 parent() $(\u0026rsquo;#first\u0026rsquo;).parent(); 查找父亲 eq(index) $(\u0026rsquo;li\u0026rsquo;).eq(2); 相当于$(\u0026rsquo;li:eq(2)\u0026rsquo;),index 从 0 开始 next() $(\u0026rsquo;li\u0026rsquo;).next() 找下一个兄弟 prev() $(\u0026rsquo;li\u0026rsquo;).prev() 找上一次兄弟 jQuery 操作样式 CSS 操作 功能：设置或者修改样式，操作的是 style 属性。\n操作单个样式\n// name：需要设置的样式名称 // value：对应的样式值 $obj.css(name, value); // 使用案例 $(\u0026#39;#one\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;gray\u0026#39;); // 将背景色修改为灰色 设置多个样式\n// 参数是一个对象，对象中包含了需要设置的样式名和样式值 $obj.css(obj); // 使用案例 $(\u0026#39;#one\u0026#39;).css({ background: \u0026#39;gray\u0026#39;, width: \u0026#39;400px\u0026#39;, height: \u0026#39;200px\u0026#39;, }); 获取样式\n// name:需要获取的样式名称 $obj.css(name); // 案例 $(\u0026#39;div\u0026#39;).css(\u0026#39;background-color\u0026#39;); 注意：获取样式操作只会返回第一个元素对应的样式值。\n隐式迭代：\n设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。 class 操作 添加样式类\n// name：需要添加的样式类名，注意参数不要带点. $obj.addClass(name); // 例子,给所有的div添加one的样式。 $(\u0026#39;div\u0026#39;).addClass(\u0026#39;one\u0026#39;); 移除样式类\n// name:需要移除的样式类名 $obj.removeClass(\u0026#39;name\u0026#39;); // 例子，移除div中one的样式类名 $(\u0026#39;div\u0026#39;).removeClass(\u0026#39;one\u0026#39;); 判断是否有某个样式类\n// name:用于判断的样式类名，返回值为true false $obj.hasClass(name); // 例子，判断第一个div是否有one的样式类 $(\u0026#39;div\u0026#39;).hasClass(\u0026#39;one\u0026#39;); 切换样式类\n// name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。 $obj.toggleClass(name); // 例子 $(\u0026#39;div\u0026#39;).toggleClass(\u0026#39;one\u0026#39;); jQuery 动画 jQuery 提供了三组基本动画，这些动画都是标准的、有规律的效果，jQuery 还提供了自定义动画的功能。\n三组基本动画 显示(show)与隐藏(hide)是一组动画： 滑入(slideDown)与滑出(slideUp)与切换(slideToggle)，效果与卷帘门类似 淡入(fadeIn)与淡出(fadeOut)与切换(fadeToggle) $obj.show([speed], [callback]); // speed(可选)：动画的执行时间 // 1.如果不传，就没有动画效果。如果是slide和fade系列，会默认为normal // 2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐) // 3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。 // callback(可选):执行完动画后执行的回调函数 slideDown(); slideUp(); slideToggle(); // 同理 fadeIn(); fadeOut(); fadeToggle(); // 同理 自定义动画 animate: 自定义动画\n$(selector).animate({ params }, [speed], [easing], [callback]); // {params}：要执行动画的CSS属性，带数字（必选） // speed：执行动画时长（可选） // easing:执行效果，默认为swing（缓动） 可以是linear（匀速） // callback：动画执行完后立即执行的回调函数（可选） 动画队列与停止动画 在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行（联想：火车进站）。\n// stop方法：停止动画效果 stop(clearQueue, jumpToEnd); // 第一个参数：是否清除队列 // 第二个参数：是否跳转到最终效果 jQuery 节点操作 创建节点 // $(htmlStr) // htmlStr：html格式的字符串 $(\u0026#39;\u0026lt;span-这是一个span元素\u0026lt;/span-\u0026#39;); 添加节点 append appendTo // 在被选元素的结尾插入内容 prepend prependTo // 在被选元素的开头插入内容 before // 在被选元素之后插入内容 after // 在被选元素之前插入内容 清空节点与删除节点 empty：清空指定节点的所有元素，自身保留(清理门户)\n$(\u0026#39;div\u0026#39;).empty(); // 清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码） $(\u0026#39;div\u0026#39;).html(\u0026#39;\u0026#39;); // 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。 remove：相比于 empty，自身也删除（自杀）\n$(\u0026#39;div\u0026#39;).remove(); 克隆节点 作用：复制匹配的元素\n// 复制$(selector)所匹配到的元素（深度复制） // cloneNode(true) // 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。 $(selector).clone(); jQuery 操作属性 attr 操作 设置单个属性\n// 第一个参数：需要设置的属性名 // 第二个参数：对应的属性值 $obj.attr(name, value); // 用法举例 $(\u0026#39;img\u0026#39;).attr(\u0026#39;title\u0026#39;, \u0026#39;哎哟，不错哦\u0026#39;); $(\u0026#39;img\u0026#39;).attr(\u0026#39;alt\u0026#39;, \u0026#39;哎哟，不错哦\u0026#39;); 设置多个属性\n// 参数是一个对象，包含了需要设置的属性名和属性值 $obj.attr(obj); // 用法举例 $(\u0026#39;img\u0026#39;).attr({ title: \u0026#39;哎哟，不错哦\u0026#39;, alt: \u0026#39;哎哟，不错哦\u0026#39;, style: \u0026#39;opacity:.5\u0026#39;, }); 获取属性\n// 传需要获取的属性名称，返回对应的属性值 $obj.attr(name); // 用法举例 var oTitle = $(\u0026#39;img\u0026#39;).attr(\u0026#39;title\u0026#39;); alert(oTitle); 移除属性\n// 参数：需要移除的属性名， $obj.removeAttr(name); // 用法举例 $(\u0026#39;img\u0026#39;).removeAttr(\u0026#39;title\u0026#39;); prop 操作 在 jQuery1.6 之后，对于 checked、selected、disabled 这类 boolean 类型的属性来说，不能用 attr 方法，只能用 prop 方法。\n// 设置属性 $(\u0026#39;:checked\u0026#39;).prop(\u0026#39;checked\u0026#39;, true); // 获取属性 $(\u0026#39;:checked\u0026#39;).prop(\u0026#39;checked\u0026#39;); // 返回true或者false val()/text/()html() $obj.val() 获取或者设置表单元素的value属性的值 $obj.html() 对应innerHTML $obj.text() 对应innerText/textContent，处理了浏览器的兼容性 jQuery 尺寸和位置操作 width 方法与 height 方法 设置或者获取高度，不包括内边距、边框和外边距\n// 带参数表示设置高度 $(\u0026#39;img\u0026#39;).height(200); // 不带参数获取高度 $(\u0026#39;img\u0026#39;).height(); 获取网页的可视区宽高\n// 获取可视区宽度 $(window).width(); // 获取可视区高度 $(window).height(); innerWidth/innerHeight/outerWidth/outerHeight innerWidth(); innerHeight(); // 方法返回元素的宽度/高度（包括内边距）。 outerWidth(); outerHeight(); // 方法返回元素的宽度/高度（包括内边距和边框）。 outerWidth(true); outerHeight(true); // 方法返回元素的宽度/高度（包括内边距、边框和外边距）。 scrollTop 与 scrollLeft 设置或者获取垂直滚动条的位置\n// 获取页面被卷曲的高度 $(window).scrollTop(); // 获取页面被卷曲的宽度 $(window).scrollLeft(); offset 方法与 position 方法 offset 方法获取元素距离 document 的位置，position 方法获取的是元素距离有定位的父元素(offsetParent)的位置。\n// 获取元素距离document的位置,返回值为对象：{left:100, top:100} $(selector).offset(); // 获取相对于其最近的有定位的父元素的位置。 $(selector).position(); jQuery 事件机制 JavaScript 中已经学习过了事件，jQuery 对 JavaScript 事件进行了封装，增加并扩展了事件处理机制。jQuery 不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。\njQuery 事件发展历程(了解) 简单事件绑定\u0026ndash;delegate 事件绑定\u0026ndash;on 事件绑定(推荐)\n简单事件注册\nclick(handler); // 单击事件 mouseenter(handler); // 鼠标进入事件 mouseleave(handler); // 鼠标离开事件 // 缺点：不能同时注册多个事件 bind 方式注册事件\n// 第一个参数：事件类型 // 第二个参数：事件处理程序 $(\u0026#39;p\u0026#39;).bind(\u0026#39;click mouseenter\u0026#39;, function () { // 事件响应方法 }); // 缺点：不支持动态事件绑定 delegate 注册委托事件\n// 第一个参数：selector，要绑定事件的元素 // 第二个参数：事件类型 // 第三个参数：事件处理函数 $(\u0026#39;.parentBox\u0026#39;).delegate(\u0026#39;p\u0026#39;, \u0026#39;click\u0026#39;, function () { // 为 .parentBox下面的所有的p标签绑定事件 }); // 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on 注册事件(重点) jQuery1.7 之后，jQuery 用 on 统一了所有事件的处理方法。 最现代的方式，兼容 zepto(移动端类似 jQuery 的一个库)，强烈建议使用。 on 注册简单事件\n// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。 $(selector).on(\u0026#39;click\u0026#39;, function () {}); on 注册事件委托\n// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定 $(selector).on(\u0026#39;click\u0026#39;, \u0026#39;span\u0026#39;, function () {}); 事件委托原理\n// 事件委托的原理 var ul = document.querySelector(\u0026#39;#ul\u0026#39;); ul.onclick = function (e) { // console.log(e.target.tagName); if (e.target.tagName.toLowerCase() === \u0026#39;li\u0026#39;) { console.log(e.target); } }; on 注册事件的语法：\n// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件） // 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。 // 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用） // 第四个参数：handler，事件处理函数 $(selector).on(events[,selector][,data],handler); 事件解绑 unbind 方式（不用）\n$(selector).unbind(); // 解绑所有的事件 $(selector).unbind(\u0026#39;click\u0026#39;); // 解绑指定的事件 undelegate 方式（不用）\n$(selector).undelegate(); // 解绑所有的delegate事件 $(selector).undelegate(\u0026#39;click\u0026#39;); // 解绑所有的click事件 off 方式（推荐）\n// 解绑匹配元素的所有事件 $(selector).off(); // 解绑匹配元素的所有click事件 $(selector).off(\u0026#39;click\u0026#39;); 触发事件 $(selector).click(); // 触发 click事件 $(selector).trigger(\u0026#39;click\u0026#39;); jQuery 事件对象 jQuery 事件对象其实就是 js 事件对象的一个封装，处理了兼容性。\nscreenX, screenY; // 对应屏幕最左上角的值 clientX, clientY; // 距离页面左上角的位置（忽视滚动条） pageX, pageY; // 距离页面最顶部的左上角的位置（会计算滚动条的距离） event.keyCode; // 按下的键盘代码 event.data; // 存储绑定事件时传递的附加数据 event.stopPropagation(); // 阻止事件冒泡行为 event.preventDefault(); // 阻止浏览器默认行为 return false; // 既能阻止事件冒泡，又能阻止浏览器默认行为。 jQuery 补充知识点 链式编程 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery 对象。\nend(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。 each 方法 jQuery 的隐式迭代会对所有的 DOM 对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。\n作用：遍历 jQuery 对象集合，为每个匹配的元素执行一个函数\n// 参数一表示当前元素在所有匹配元素中的索引号 // 参数二表示当前元素（DOM对象） $(selector).each(function (index, element) {}); 多库共存 jQuery 使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery 可以释放$符的控制权。 var c = $.noConflict(); // 释放$的控制权,并且把$的能力给了c 插件 常用插件 弹出层插件 layer layer 插件 放大镜插件 jQuery.zoom 轮播图插件 jcarousel OwlCarousel2 图片懒加载插件 jQuery.lazyload jQueryUI 常用的 2-3 个功能演示 查看 jQuery 插件的源码 自己探索插件 artDialog 图片放大 github 上搜索 jQuery 插件开发 给 jQuery 增加方法的两种方式 $.method = fn; // 静态方法 $.fn.method = fn; // 实例方法 增加一个静态方法，实现两个数的和，插件 (function ($) { $.add = function (a, b) { return a + b; }; })(jQuery); $.add(5, 6); tab 栏插件 [21-tab 栏插件.html] (function ($) { // {tabMenu: \u0026#39;#aa\u0026#39;} $.tab = function (options) { // 默认参数 var defaults = { tabMenu: \u0026#39;#tab\u0026#39;, activeClass: \u0026#39;active\u0026#39;, tabMain: \u0026#39;#tab-main\u0026#39;, tabMainSub: \u0026#39;.main\u0026#39;, selectedClass: \u0026#39;selected\u0026#39;, }; // 把options中的属性，把对应属性的值赋给defaults对应的属性 // defaults.tabMenu = options.tabMenu || defaults.tabMenu; // for(var key in options) { // defaults[key] = options[key]; // } $.extend(defaults, options); $(defaults.tabMenu).on(\u0026#39;click\u0026#39;, \u0026#39;li\u0026#39;, function () { $(this).addClass(defaults.activeClass).siblings().removeClass(defaults.activeClass); // var index = $(this).index(); // $(defaults.tabMain + \u0026#39; \u0026#39; + defaults.tabMainSub) .eq(index) .addClass(defaults.selectedClass) .siblings() .removeClass(defaults.selectedClass); }); }; })(window.jQuery); 表格插件 [22-表格插件.html] (function ($) { // 内部的变量，外部无法访问，防止变量名冲突 var a = 0; // 给$增加了一个实例方法 $.fn.table = function (header, data) { var array = []; array.push(\u0026#39;\u0026lt;table\u0026gt;\u0026#39;); array.push(\u0026#39;\u0026lt;tr\u0026gt;\u0026#39;); // 生成表头 $.each(header, function () { array.push(\u0026#39;\u0026lt;th\u0026gt;\u0026#39; + this + \u0026#39;\u0026lt;/th\u0026gt;\u0026#39;); }); array.push(\u0026#39;\u0026lt;/tr\u0026gt;\u0026#39;); // 生成数据行 $.each(data, function (index) { // this是当前遍历到的数组中的每一个对象 // 拼数据行 array.push(\u0026#39;\u0026lt;tr\u0026gt;\u0026#39;); array.push(\u0026#39;\u0026lt;td\u0026gt;\u0026#39; + (index + 1) + \u0026#39;\u0026lt;/td\u0026gt;\u0026#39;); // 遍历对象，拼表格 for (var key in this) { array.push(\u0026#39;\u0026lt;td\u0026gt;\u0026#39; + this[key] + \u0026#39;\u0026lt;/td\u0026gt;\u0026#39;); } array.push(\u0026#39;\u0026lt;/tr\u0026gt;\u0026#39;); }); array.push(\u0026#39;\u0026lt;/table\u0026gt;\u0026#39;); this.append(array.oin(\u0026#39;\u0026#39;)); }; })(window.jQuery); ","date":"2021-02-10T10:44:52Z","image":"https://static.aecra.cn/cover/jquery-notes.jpg","permalink":"https://aecra.github.io/article/jquery-notes/","title":"jQuery 笔记"},{"content":" less 是一种动态样式语言，属于 css 预处理器的范畴，它扩展了 CSS 语言， 增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展 LESS 既可以在 客户端 上运行 ，也可以借助 Node.js 在服务端运行。\nless 的中文官网 官网地址\nbootstrap 中 less 教程 教程地址\nLess 编译工具 koala 官网: www.koala-app.com\nLess 编译 用 koala 手动编译 借助 less 转 css 文件手动编译 利用打包工具编译 less 中的注释 以//开头的注释，不会被编译到 css 文件中\n以/**/包裹的注释会被编译到 css 文件中\nless 中的变量 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次。\n使用@来申明一个变量：@pink：pink;\n作为普通属性值 直接使用@pink\n@nice-blue: #5b83ad;\r@light-blue: @nice-blue + #111;\r#header {\rcolor: @light-blue;\r}\r= \u0026gt; #header {\rcolor: #6c94be;\r} 作为选择器和属性名 @{selector 的值}的形式\n\u0026lt;div id=\u0026#34;wrap\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r// less\r@selector:#wrap;\r@w:width;\r@{selector}{\r@{w}:100px;\rheight: 300px;\rborder: 1px solid;\r}\r// 编译为css后\r#wrap{\rwidth:100px;\rheight:300px;\rborder:1px solid;\r} 作为 URL @{url}\n// less\r@url: \u0026#39;../img/zdy.jpg\u0026#39;;\r#wrap {\rwidth: 100px;\rheight: 100px;\rbackground: url(\u0026#39;@{url}\u0026#39;);\r// 也可以将url作为变量，写成下面形式\r// background: url(@url);\r}\r// 编译为css后\r#wrap {\rwidth: 100px;\rheight: 100px;\rbackground: url(\u0026#39;../img/zdy.jpg\u0026#39;);\r} 变量的延迟加载 // less\r@var: 0;\r.class {\r@var: 1;\r.brass {\r@var: 2;\rthree: @var; //3\r@var: 3;\r}\rone: @var; //1\r}\r// 编译为css后\r.class {\rone: 1;\r}\r.class .brass {\rthree: 3;\r} less 作用域 首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止.\n@var: red;\r#page {\r@var: white;\r#header {\rcolor: @var; // white\r}\r}\r#footer {\rcolor: @var; // red\r} less 中的嵌套规则 基本嵌套规则\n// html页面：\r\u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt;\r\u0026lt;li\u0026gt;\r\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;a1\u0026lt;/a\u0026gt;\r\u0026lt;span\u0026gt;b1\u0026lt;/span\u0026gt;\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r// less嵌套写法：\r#list {\rlist-style: none;\rline-height: 30px;\rwidth: 300px;\rbackground: pink;\rmargin: 0 auto;\rli {\rheight: 30px;\r}\ra {\rfloat: left;\r/*\u0026amp;代表父级*/\r\u0026amp;:hover {\rcolor: red;\r}\r}\rspan {\rfloat: right;\r}\r} \u0026amp;的使用（\u0026amp;代表父级）\n如果想写串联选择器，而不是写后代选择器，就可以用到\u0026amp;了。这点对伪类尤其有用如 :hover 和 :focus.\nless 中的混合 混合就是将一系列属性从一个规则集引入到另一个规则集的方式\n任何 CSS class, id 或者 元素 属性集都可以以同样的方式引入.\n以下测试，html 模板均为\n// html \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; 普通混合 会将混合内容输出到 css 文件中\n// less\r.juzhong {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\r}\r#box1 {\rwidth: 100px;\rheight: 100px;\rbackground: pink;\r.juzhong;\r}\r// 编译为css后\r.juzhong {\r// 会将混合内容输出到css文件中\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\r}\r#box1 {\rwidth: 100px;\rheight: 100px;\rbackground: pink;\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\r} 不带输出的混合 加（）后就不会在 css 中输出混合内容了\n// less\r.juzhong() {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\r}\r#box1 {\rwidth: 100px;\rheight: 100px;\rbackground: pink;\r.juzhong;\r}\r// 编译为css后\r#box1 {\rwidth: 100px;\rheight: 100px;\rbackground: pink;\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\r} 带参数的混合 // less\r.juzhong(@w,@h,@c) {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\rwidth: @w;\rheight: @h;\rbackground: @c;\r}\r#box1 {\r.juzhong(100px,100px,pink);\rz-index: 1;\r}\r// 编译为css后\r#box1 {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\rwidth: 100px;\rheight: 100px;\rbackground: #ffc0cb;\rz-index: 1;\r} 带参数并且有默认值的混合 // less\r.juzhong(@w:100px,@h:100px,@c:pink) {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\rwidth: @w;\rheight: @h;\rbackground: @c;\r}\r#box1 {\r.juzhong;\rz-index: 1;\r}\r// 编译为css后\r#box1 {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\rwidth: 100px;\rheight: 100px;\rbackground: #ffc0cb;\rz-index: 1;\r} 带多个参数的混合 见 带参数并且有默认值的混合\n形参和实参 命名参数就是引用 mixin 时可以通过参数名称而不是参数的位置来为 mixin 提供参数值。\n任何参数都已通过它的名称来引用，这样就不必按照任意特定的顺序来使用\n// less\r.juzhong(@w:100px,@h:100px,@c:pink) {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\rwidth: @w;\rheight: @h;\rbackground: @c;\r}\r#box1 {\r// 引入混合时可以改变参数位置\r.juzhong(@h:200px;@c:deeppink;);\r}\r// 编译为css后\r#box1 {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\rwidth: 100px;\rheight: 200px;\rbackground: #ff1493;\r} 匹配模式 根据传入的参数来改变混合的默认呈现。\n// less\r/*向上的三角*/\r.triangle(top,@w:10px,@c:pink) {\rborder-width: @w;\rborder-color: transparent transparent @c transparent;\rborder-style: dashed dashed solid dashed;\r}\r/*向下的三角*/\r.triangle(bottom,@w:10px,@c:pink) {\rborder-width: @w;\rborder-color: @c transparent transparent transparent;\rborder-style: solid dashed dashed dashed;\r}\r/*向左的三角*/\r.triangle(left,@w:10px,@c:pink) {\rborder-width: @w;\rborder-color: transparent @c transparent transparent;\rborder-style: dashed solid dashed dashed;\r}\r/*向右的三角*/\r.triangle(right,@w:10px,@c:pink) {\rborder-width: @w;\rborder-color: transparent transparent transparent @c;\rborder-style: dashed dashed dashed solid;\r}\r.triangle(@_,@w:10px,@c:pink) {\rwidth: 0;\rheight: 0;\roverflow: hidden;\r}\r#box1 {\r// 向上三角图案\r.triangle(top,50px,deeppink);\r}\r// 编译为css后\r#box1 {\rborder-width: 50px;\rborder-color: transparent transparent #ff1493 transparent;\rborder-style: dashed dashed solid dashed;\rwidth: 0;\rheight: 0;\roverflow: hidden;\r} 导引表达式 当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。\n为了尽可能地保留 CSS 的可声明性，LESS 通过导引混合而非 if/else 语句来实现条件判断，因为前者已在@media query 特性中被定义。\n从该例开始\n.mixin (@a) when (lightness(@a) \u0026gt;= 50%) {\rbackground-color: black;\r}\r.mixin (@a) when (lightness(@a) \u0026lt; 50%) {\rbackground-color: white;\r}\r.mixin (@a) {\rcolor: @a;\r} when 关键字用以定义一个导引序列(此例只有一个导引)。接下来我们运行下列代码\n.class1 {\r.mixin(#ddd);\r}\r.class2 {\r.mixin(#555);\r} 就会得到\n.class1 { background-color: black; color: #ddd; } .class2 { background-color: white; color: #555; } 导引中可用的全部比较运算有： \u0026gt; \u0026gt;= = =\u0026lt; \u0026lt;。此外，关键字 true 只表示布尔真值，除去关键字 true 以外的值都被视为布尔假，下面两个混合是相同的\n.truth (@a) when (@a) {\r...;\r}\r.truth (@a) when (@a = true) {\r...;\r} 导引序列使用逗号‘,’—分割，当且仅当所有条件都符合时，才会被视为匹配成功。\n.mixin (@a) when (@a \u0026gt; 10), (@a \u0026lt; -10) {\r...;\r} 导引可以无参数，也可以对参数进行比较运算\n@media: mobile;\r.mixin (@a) when (@media = mobile) {\r...;\r}\r.mixin (@a) when (@media = desktop) {\r...;\r}\r.max (@a, @b) when (@a \u0026gt; @b) {\rwidth: @a;\r}\r.max (@a, @b) when (@a \u0026lt; @b) {\rwidth: @b;\r} 最后，如果想基于值的类型进行匹配，我们就可以使用 is*函式\n.mixin (@a, @b: 0) when (isnumber(@b)) { ... }\r.mixin (@a, @b: black) when (iscolor(@b)) { ... }\r// 下面就是常见的检测函式：\riscolor\risnumber\risstring\riskeyword\risurl\r// 如果你想判断一个值是纯数字，还是某个单位量，可以使用下列函式\rispixel\rispercentage\risem 最后再补充一点，在导引序列中可以使用 and 关键字实现与条件，使用 not 关键字实现或条件。\narguments 变量 @arguments 包含了所有传递进来的参数. 如果你不想单独处理每一个参数的话就可以像这样写\n.border(@w:10px,@style:solid,@c:deeppink) {\rborder: @arguments;\r} less 运算 任何数字、颜色或者变量都可以参与运算\n在 less 中可以进行加减乘除的运算\n括号也同样允许使用\nColor 函数\nlighten(@color, 10%); // 返回颜色比@color浅10%的颜色\rdarken(@color, 10%); //返回颜色比@color深10%的颜色\rsaturate(@color, 10%); // 返回饱和比比@color深10%的颜色\rdesaturate(@color, 10%); // 返回饱和比比@color浅10%的颜色\rfadein(@color, 10%); // 返回颜色不透明度是@color10%的颜色\rfadeout(@color, 10%); // 返回颜色透明度是@color10%的颜色\rfade(@color, 50%); // 返回透明度是@color50%的颜色\rspin(@color, 10); // 颜色比@color大10的色调\rspin(@color, -10); // 颜色比@color小10的色调\rmix(@color1, @color2); // 返回@color1与@color2的混合值 Math 函数:\nround(1.67); //四舍五入 returns `2`\rceil(2.4); // returns `3`\rfloor(2.6); // returns `2`\rpercentage(0.5); // returns `50%` less 避免编译 有时候我们需要输出一些不正确的 CSS 语法或者使用一些 LESS 不认识的专有语法.\n要输出这样的值我们可以在字符串前加上一个 ~\n.class {\rfilter: ~\u0026#34;ms:alwaysHasItsOwnSyntax.For.Stuff()\u0026#34;;\r}\r// 我们可以将要避免编译的值用 “”包含起来，输出结果为:\r.class {\rfilter: ms:alwaysHasItsOwnSyntax.For.Stuff();\r} less 继承 性能比混合高\n灵活度比混合低\nextend(继承的类 all)\n// less\r.common:hover {\rbackground: pink;\r}\r.common {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\r}\r.juzhong(@w:100px,@h:100px,@c:pink) {\r\u0026amp;:extend(.common all);\rwidth: @w;\rheight: @h;\rbackground: @c;\r}\r#box1 {\r.juzhong();\rz-index: 1;\r}\r// 编译为css后\r.common:hover {\rbackground: pink;\r}\r.common {\rposition: absolute;\rleft: 0;\rright: 0;\rbottom: 0;\rtop: 0;\rmargin: auto;\r}\r.juzhong(@w:100px,@h:100px,@c:pink) {\r\u0026amp;:extend(.common all);\rwidth: @w;\rheight: @h;\rbackground: @c;\r}\r#box1 {\r.juzhong();\rz-index: 1;\r} 命名空间 有时候，你可能为了更好组织 CSS 或者单纯是为了更好的封装，将一些变量或者混合模块打包起来\n你可以像下面这样在#bundle 中定义一些属性集之后可以重复使用\n#bundle {\r.button () {\rdisplay: block;\rborder: 1px solid black;\rbackground-color: grey;\r\u0026amp;:hover {\rbackground-color: white;\r}\r}\r.tab {\r...;\r}\r.citation {\r...;\r}\r}\r// 只需要在 #header a中像这样引入 .button\r#header a {\rcolor: orange;\r#bundle \u0026gt; .button;\r} 混合与继承区别 混合：就是将一系列属性从一个规则集引入到另一个规则集的方式，任何 CSS class, id 或者元素 属性集都可以以同样的方式引入。可带可不带参数，编译后相当于 ctrl c +ctrl v\n继承：不能带参数，性能比混合高，灵活度比混合低。编译后再 css 中会将选择器组合在一起，代码减少。\nJavaScript 表达式 慎用，测试报错\nJavaScript 表达式也可以在.less 文件中使用. 可以通过反引号的方式使用:\n@var: ` \u0026#39;hello\u0026#39; .toUpperCase() + \u0026#39;!\u0026#39; `;\r// 输出\r@var: \u0026#39;HELLO!\u0026#39;;\r// 注意你也可以同时使用字符串插值和避免编译\r@str: \u0026#39;hello\u0026#39;;\r@var: ~` \u0026#39;@{str}\u0026#39; .toUpperCase() + \u0026#39;!\u0026#39; `;\r// 输出\r@var: HELLO!;\r// 它也可以访问JavaScript环境:\r@height: `document.body.clientHeight`;\r// 如果你想将一个JavaScript字符串解析成16进制的颜色值, 你可以使用 color 函数\r@color: color(`window.colors.baseColor`);\r@darkcolor: darken(@color, 10%); ","date":"2021-02-07T11:13:35Z","image":"https://static.aecra.cn/cover/less-notes.jpg","permalink":"https://aecra.github.io/article/less-notes/","title":"Less 笔记"},{"content":" 官网\n前置知识 完整的学习 vue：html + css、JavaScript、css3、HTML5、第三方库、网络通信、ES6+、webpack、模块化、包管理、css 预编译器 体验 vue 功能：html + css、JavaScript vue 是前端的一种开发框架，它主要解决前端开发中的核心痛点——复杂的 DOM 操作\nvue 拥有以下特点：\n渐进式 组件化 响应式 vue 的应用场景：\n前台的部分页面 后台的部分页面 vue 的版本\n目前的正式版本是 2.x 3.x 版本即将上线，对 2.x 是兼容的，要完全体验到 3.x 的优势，还要学习 TypeScript vue 在前端的地位 前端是连接终端设备与人的技术\n除了 vue 之外，还需要学习哪些前端知识？\nTypeScript、ThreeJS、WebGL、ECharts、NodeJS、Egg、Redis、Mongodb、Sequelize、Express、Koa、移动端……\n学习准备 安装 VSCode\n官网\n安装 VSCode 相应插件：\nAuto Rename Tag：能够自动更改结束标签 Live Server：自动搭建本地服务器 Prettier - Code formatter：代码美化 Vetur：vue 组件格式支持 vscode-icons：美化文件图标 起步 使用 vue 的两种方式：\n在页面中引入 vue 的文件 脚手架 官方脚手架 vue-cli 其他民间脚手架，如 webpack-simple 体验 vue graph LR\rA(数据 Model) --\u0026gt;|变动| B(vue View Model)\rB(vue View Model) --\u0026gt;|更改| A(数据 Model)\rB(vue View Model) --\u0026gt;|渲染| C(界面 View)\rC(界面 View) --\u0026gt;|操作| B(vue View Model) \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;起步\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 界面模板 --\u0026gt; \u0026lt;!-- mustache语法 --\u0026gt; \u0026lt;h1\u0026gt;系统名称：{{title}}\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, i) in products\u0026#34;\u0026gt; 名称：{{item.name}} \u0026lt;button @click=\u0026#34;changeStock(item, item.stock - 1)\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span v-if=\u0026#34;item.stock \u0026gt; 0\u0026#34;\u0026gt;库存：{{item.stock}}\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;无货\u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;changeStock(item, item.stock + 1)\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;deleteProduct(i)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ // 配置 el: \u0026#39;#app\u0026#39;, // css选择器 data: { // 和界面相关的数据 title: \u0026#39;库存管理系统\u0026#39;, products: [ { name: \u0026#39;iphone\u0026#39;, stock: 10 }, { name: \u0026#39;小米\u0026#39;, stock: 3 }, { name: \u0026#39;vivo\u0026#39;, stock: 15 }, { name: \u0026#39;华为\u0026#39;, stock: 32 }, ], }, methods: { // 界面使用到的方法 deleteProduct(i) { this.products.splice(i, 1); }, changeStock(product, newStock) { if (newStock \u0026lt; 0) { newStock = 0; } product.stock = newStock; }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ES6 知识补充 速写属性 var name = \u0026#34;小姐姐\u0026#34;； var age = 18; var person = { name, age } 速写方法 var person = { name: \u0026#34;小姐姐\u0026#34;， age: 18, sayHello() { console.log(\u0026#34;Hello!\u0026#34;); } } 模板字符串 var person = { name: \u0026#34;小姐姐\u0026#34;， age: 18, } str = `I\u0026#39;m $(person.name), my age is $(person.age).`; 注入 配置对象中的部分内容会被提取到 vue 实例中：\ndata method 该过程称之为注入\n注入目的有两个：\n完成数据响应\nvue2.0 是通过 Object.defineProperty 方法完成数据响应式(无法检测到对象属性的新增或删除、不能监听数组的变化)，vue3.0 是通过 Class Proxy 完成的数据相应式\n绑定 this\n虚拟 DOM 树 为了提高渲染效率，vue 会把模板编译成为虚拟 DOM 树（vm._vnode），然后再生成真实的 DOM(vm._vnode.elm)\n模板 —— 虚拟节点树 —— 真实节点树\n当数据更改时，将重新编译成虚拟 DOM 树，然后对比前后两棵树（diff 算法），仅将差异部分反映到真实 DOM，这样既可最小程度的改动真实 DOM，又可提高效率\n因此，对于 vue 而言，提升效率重点着眼于两个方面：\n减少新的虚拟 DOM 的生成 保证对比之后，只有必要的节点有变化 vue 提供了多种方式生成虚拟 DOM 树：\n在挂载的元素内部直接书写，此时将使用元素的 outHTML 作为模板\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 界面模板 --\u0026gt; \u0026lt;!-- mustache语法 --\u0026gt; \u0026lt;h1\u0026gt;系统名称：{{title}}\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, i) in products\u0026#34;\u0026gt; 名称：{{item.name}} \u0026lt;button @click=\u0026#34;changeStock(item, item.stock - 1)\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span v-if=\u0026#34;item.stock \u0026gt; 0\u0026#34;\u0026gt;库存：{{item.stock}}\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;无货\u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;changeStock(item, item.stock + 1)\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;deleteProduct(i)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 在 template 配置中书写\nvar vm = new Vue({ // 配置 el: \u0026#34;#app\u0026#34;, // css选择器 templete: `\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 界面模板 --\u0026gt; \u0026lt;!-- mustache语法 --\u0026gt; \u0026lt;h1\u0026gt;系统名称：{{title}}\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, i) in products\u0026#34;\u0026gt; 名称：{{item.name}} \u0026lt;button @click=\u0026#34;changeStock(item, item.stock - 1)\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span v-if=\u0026#34;item.stock \u0026gt; 0\u0026#34;\u0026gt;库存：{{item.stock}}\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;无货\u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;changeStock(item, item.stock + 1)\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;deleteProduct(i)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt;` }) 在 render 配置中用函数直接创建节点数，此时，完全脱离模板，将省略编译步骤\nvar vm = new Vue({ // 配置 el: \u0026#34;#app\u0026#34;, // css选择器 render(h) { //return h(\u0026#34;h1\u0026#34;, \u0026#34;hello\u0026#34;); //return h(\u0026#34;h1\u0026#34;, this.title); return h(\u0026#34;div\u0026#34;, [ h(\u0026#34;h1\u0026#34;, this.title), h(\u0026#34;p\u0026#34;, \u0026#34;例子\u0026#34;) ]); } }) 这些步骤从上到下，优先级逐渐提升，注意：虚拟节点树必须是单根的。\n挂载 将生成的真实 DOM 树，放置到某个元素位置，称之为挂载\n挂载的方式：\n通过 el:\u0026ldquo;css 选择器\u0026quot;进行配置 通过 vue 实例.$mount(\u0026ldquo;css 选择器\u0026rdquo;)进行配置 完整流程 模板语法 内容 vue 中的元素内容使用 musrache 模板引擎进行解析\nmustache\n指令 指令会影响元素的渲染行为，指令始终以v-开头\n基础指令：\nv-for：循环渲染元素 \u0026lt;li v-for=\u0026#34;(item, i) in arrary\u0026#34;\u0026gt; arrary：可迭代，下标：i,循环变量：item \u0026lt;/li\u0026gt; v-html：设置元素的 innerHTML，该指令会导致元素的模板内容失效 \u0026lt;div v-html=\u0026#34;html\u0026#34;\u0026gt; html：带标签的HTML字符串 \u0026lt;/div\u0026gt; v-on：注册事件 该指令由于十分常用，因此提供了简写@ 事件支持一些指令修饰符，如 revent、stop 事件参数会自动传递 \u0026lt;button v-on:click=\u0026#34;function()\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;function()\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button v-on:click.prevent=\u0026#34;function()\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;function($event)\u0026#34;\u0026gt;手动传入事件参数\u0026lt;/button\u0026gt; v-bind：绑定动态属性 该指令由于十分常用，因此提供了简写: \u0026lt;img v-bind:src=\u0026#34;imgUrl\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; v-show：控制元素可见度 \u0026lt;p v-show=\u0026#34;true\u0026#34;\u0026gt;内容\u0026lt;/p\u0026gt; v-if、v-else-if、v-else：控制元素生成 v-model：双向数据绑定，常用于表单元素 该指令是 v-on 和 v-bind 的复合版 \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;text\u0026#34; @input=\u0026#34;text=$event.target.value\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;text\u0026#34;\u0026gt; 进阶指令：\nv-slot v-text v-pre v-cloak 特殊属性 最重要的特殊属性：key\n该属性可以干预 diff 算法，在同一层级，key 值相同的节点会进行对比，key 值不同则不会\n在循环生成的节点中，vue 强烈建议给予每个节点唯一且稳定的 key 值\n其他特殊属性：\nref is slot slot-scope scope 计算属性 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;姓：{{firstName}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;名：{{lastName}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;全名：{{fullName}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ // 配置 el: \u0026#34;#app\u0026#34;, // css选择器 data: { // 和界面相关的数据 firstName: \u0026#34;张\u0026#34;, lastName: \u0026#34;三\u0026#34;, }, computed: { //fullName() { // return this.firstName + this.lastName; //} fullName: { get() { return this.firstName + this.lastName; }, set(val) { // 数据处理 }, }, }, }); \u0026lt;/script\u0026gt; 计算属性和方法的区别：\n计算属性可以赋值，而方法不行 计算属性会进行缓存，如果依赖不变，则直接使用缓存结果，不会重新计算 凡是根据已有数据计算得到新数据的无参函数，都应该尽量写成计算属性，而不是方法 知识补充 箭头函数\n任何可以书写匿名函数的地方均可书写箭头函数 箭头函数将会绑定 this 为函数书写位置的 this 值 var sum = (a, b) =\u0026gt; { // 一个参数可以省略小括号 return a + b; };// 只有一个返回值，可以省略大括号和return 模块化\n没有模块化的世界：全局变量污染、难以管理的依赖 常见的模块化标准：CommonJS、ES6 Module、AMD、CMD、UMD ./utl.js export default { test1() {}, test2() {} } ./main.js import utl from \u0026#34;./utl.js\u0026#34; utl.test1(); 组件概念 一个完整的页面是复杂的，如果将其作为一个整体来开发，将会遇到下面的困难\n代码凌乱臃肿 不宜协作 难以复用 vue 推荐使用一种更加精细的控制方案——组件化开发\n所谓组件化开发，即把一个页面中区域功能细分，每一个区域作为一个组件，每各组件包含：\n功能（JS 代码） 内容（模板代码） 样式（CSS 代码） 由于没有构建工具的支持，css 代码暂时无法放到组件中\n组件开发 创建组件 组件是根据一个普通的配置对象创建的，所以要开发组件，只需要写一个配置对象即可\n该配置对象和 vue 实例是几乎一样的\nvar myComp = { data() { return { // ... } }, computed: { //... }, methods: { //... }, template: `......` } 值得注意的是，组件配置对象和 vue 实例有以下几点差异：\n无 el data 必须是一个函数，该函数返回的对象最为数据 由于没有 el 配置，组建的虚拟 DOM 树必须定义子啊 template 或 render 中 注册组件 注册组件分为两种方式，一种是全局注册，一种是局部注册\n全局注册 一旦全局注册了一个组件，整个应用中任何地方都可以只用该组件\n全局注册的方式是：\n// 参数1：组件名称。将来在模板中使用组件时，会使用该名称 // 参数2：组件配置对象 // 该代码运行后，即可在模板中使用组件 Vue.component(\u0026#39;MyComp\u0026#39;, myComp); 在模板中，可以只用组件了\n\u0026lt;myComp /\u0026gt; \u0026lt;!-- 或 --\u0026gt; \u0026lt;myComp\u0026gt;\u0026lt;/myComp\u0026gt; 但在一些工程化的大型项目中，很多组件都不需要全局使用\n比如一个登陆组件，只有在登陆相关的页面中使用，如果全局注册，将导致构建工具无法优化打包\n因此，除非组件特别通用，否则不建议使用全局注册\n局部注册 局部注册就是哪里要用到组件，就在哪里注册\n局部注册的方式是，在要使用的组件的组件或实例中加入一个配置：\nvar otherComp = { components: { // 属性名为组件名称，模板中将使用该名称 // 属性值为组件配置对象，两个名字相同时可简写 myComp: myComp, }, template: `\u0026lt;myComp\u0026gt;\u0026lt;/myComp\u0026gt;`, }; 应用组件 在模板中使用组件特别简单，把组件当作 HTML 元素名使用即可\n但要注意以下几点：\n组件必须有结束\n组件可以自结束，也可以用结束标记结束，但必须要有结束\n组件的命名\n无论你是用哪种方式注册组件，组建的明明需要遵循规范\n组件可以使用 [^kebab-case 短横线命名法] ，也可以使用 [^PascalCase 大驼峰命名法]\n以下两种命名法都是可以的\nvar otherComp = { components: { \u0026#39;my-comp\u0026#39;: myComp, // 短横线命名法 MyComp: myComp, // 大驼峰命名法 }, }; 实际上使用小驼峰命名法也是可以识别的，只不过不符合官方要求的规范\n使用大驼峰命名法，在模板中可以使用大驼峰命名法和短横线命名法两种名称\n因此，在组建使用时，常采用如下方式：\nvar MyComp = { // 组件配置 }; var OtherComp = { Components: { MyComp, // ES6速写属性 }, }; 组件树 一个组件创建好后，往往会在各种地方使用它。它可能多次出现在 vue 实例中，也可能出现在其他组件中。\n于是就形成了一个组件树\n向组件传递数据 大部分组件要完成自身的功能，都需要一些额外的信息\n比如一个头像组件，需要告诉它头像的地址，这就需要在使用组件时向组件传递数据\n传递数据的方法有很多种，主唱兼的一种是使用组件属性 component\nvar MyComp = { props: [\u0026#39;p1\u0026#39;, \u0026#39;p2\u0026#39;, \u0026#39;p3\u0026#39;], // 和vue实例一样，使用组件时，也会创建组建的实例 // 而组件的属性会被提取到组件实例中，因此可以在模板中使用 template: `\u0026lt;div\u0026gt;{{p1}},{{p2}},{{p3}}\u0026lt;/div\u0026gt;`, }; var OtherComp = { components: { MyComp, }, data() { return { a: 1, }; }, template: `\u0026lt;my-comp :p1=\u0026#34;a\u0026#34; p2=\u0026#34;2\u0026#34; p3=\u0026#34;3\u0026#34; /\u0026gt;`, }; 注意：在组件中，属性是只读的，绝对不可以更改，这叫做单向数据流。\nvue-cli 的使用 vue-cli 是一个脚手架工具，它集成了诸多前端技术，包括但不仅限于：\nwebpack babel eslint http-proxy-middleware typescript css pre-prosessor css module \u0026hellip;\u0026hellip; 这些工具，他们大部分都要依赖两个东西：\nnode 环境：很多工具的运行环境 npm：包管理器，用于下载各种第三方库 目前，npm 已和 node 继集成，当安装 node 后，会自动安装 npm\n安装 node 下载 node：https://nodejs.org/zh-cn\n验证安装 打开终端，查看 node 和 npm 版本，验证是否安装成功：\nnode -v npm -v 如果安装之前打开终端，需要在安装后重新打开\n配置源地址 默认情况下，npm 安装包会从国外的地址下载，速度很慢，容易导致安装失败，因此需要先配置 npm 的源地址\n使用下面的命令更改 npm 的源地址为淘宝源\nnpm config set registry http://registry.npm.taobao.org/ 更改好之后，查看源地址是否正确修改\nnpm config get registry 安装 vue-cli 使用下面的命令安装 vue-cli 工具\nnpm install -g @vue/cli 安装好之后，检查 vue-cli 是否安装成功\nvue --version 使用 vue-cli 在终端进入某个目录 选择一个目录，该目录将放置你的工程文件夹\n在终端中进入该目录\n搭建工程 使用 vue-cli 提供的命令搭建工程\nvue create 工程名 注意工程名只能出现英文、数字和下划线\n启动开发环境 cd bilibili-app npm run serve 打包应用 cd bilibili-app npm run build ","date":"2021-02-06T12:09:14Z","image":"https://static.aecra.cn/cover/introduction-to-vue-basics.jpg","permalink":"https://aecra.github.io/article/introduction-to-vue-basics/","title":"vue 基础入门"},{"content":" AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\nAJAX 不是新的编程语言，而是一种使用现有标准的新方法。\nAJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。\nAJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。\n原生 js GET1 const result = document.getElementById(\u0026#39;res\u0026#39;); //创建对象 const xhr = new XMLHttpRequest(); //设置请求方法和url xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8000/server\u0026#39;); //发送 xhr.send(); //事件绑定 处理服务端返回的结果 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { //服务端返回了所有结果 if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.readyState \u0026lt;= 300) { //2开头的都表示成功 //处理结果 console.log(xhr.status); //状态码 console.log(xhr.statusText); //状态字符串 console.log(xhr.getAllResponseHeaders); //所有响应头 console.log(xhr.response); //响应体 result.innerHTML = xhr.response; } else { } } }; POST1 const result = document.getElementById(\u0026#39;res\u0026#39;); const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/server\u0026#39;); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); xhr.send(\u0026#39;a=100\u0026amp;b=200\u0026amp;c=3\u0026#39;); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { result.innerHTML = xhr.response; } } }; 设置响应体格式 const result = document.getElementById(\u0026#39;res\u0026#39;); const xhr = new XMLHttpRequest(); //设置响应体数据的类型 xhr.responseType = \u0026#39;json\u0026#39;; xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8000/json-server\u0026#39;); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { //自动转换 console.log(xhr.response); result.innerHTML = xhr.response.name; } } }; IE 缓存问题 在 url 路径上加上 t = Date.now()\n超时与网络异常 const result = document.getElementById(\u0026#39;res\u0026#39;); const xhr = new XMLHttpRequest(); //超时设置 xhr.timeout = 2000; //超时回调 xhr.ontimeout = function () { alert(\u0026#39;网络异常，建议换台电脑\u0026#39;); }; //网络异常回调 xhr.onerror = function () { alert(\u0026#39;你的网络异常\u0026#39;); }; xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8000/delay\u0026#39;); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { result.innerHTML = xhr.response; } } }; 取消请求 let xhr = null; xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8000/delay\u0026#39;); xhr.send(); // 取消请求 xhr.abort(); 重复请求 设置节流阀，不发送新请求；设置请求状态变量，取消原请求，发送新请求。\njQuery GET2 $.get( \u0026#34;http://localhost:8000/jquery-server\u0026#34;, { a: 100, b: 200 }, function (data) { console.log(data); }, \u0026#34;json\u0026#34; ); POST2 $.post(\u0026#34;http://localhost:8000/jquery-server\u0026#34;,{ a: 100, b: 200 }, function (data) { console.log(data); }); AJAX $.ajax({ //url url: \u0026#39;http://localhost:8000/jquery-server\u0026#39;, //参数 data: { a: 100, b: 222 }, //请求类型 type: \u0026#39;GET\u0026#39;, //响应体结果 dataType: \u0026#39;json\u0026#39;, //成功的回调 success: function (data) { console.log(data); }, //超时时间 timeout: 2000, //失败的回调 error: function () { console.log(\u0026#39;出错了\u0026#39;); }, //头信息设置 headers: { c: 300, d: 400, }, }); axios GET3 axios .get(\u0026#39;http://localhost:8000/axios-server\u0026#39;, { //url参数 params: { id: 1000, vip: 12, }, //请求头信息 headers: { name: \u0026#39;hanser\u0026#39;, age: \u0026#39;2\u0026#39;, }, }) .then((value) =\u0026gt; { console.log(value); }); POST3 axios.post( \u0026#39;http://localhost:8000/axios-server\u0026#39;, //请求体 { username: \u0026#39;admin\u0026#39;, password: \u0026#39;123\u0026#39;, }, { //url参数 params: { id: 1, vip: 123, }, //请求头参数 headers: { name: \u0026#39;yousa\u0026#39;, age: \u0026#39;23\u0026#39;, }, } ); axious axios({ method: \u0026#39;POST\u0026#39;, url: \u0026#39;http://localhost:8000/axios-server\u0026#39;, //url参数 params: { vip: 10, id: 123, }, //头信息 headers: { a: 100, b: 200, }, //请求体参数 data: { name: \u0026#39;hanser\u0026#39;, age: \u0026#39;7\u0026#39;, }, }).then((response) =\u0026gt; { console.log(response); }); fetch fetch(\u0026#39;http://localhost:8000/fetch-server\u0026#39;, { //请求方法 method: \u0026#39;POST\u0026#39;, //请求头 headers: { name: \u0026#39;hanser\u0026#39;, }, //请求体 body: \u0026#39;name=admin\u0026amp;pd=admin\u0026#39;, }) .then((Response) =\u0026gt; { console.log(Response); return Response.text(); }) .then((Response) =\u0026gt; { console.log(Response); }); 跨域 CORS 设置 http 响应的响应头\nAccess-Control-Allow-Origin：允许请求的源地址\n设置为*则为不限制跨域请求。\n","date":"2021-02-05T10:17:04Z","image":"https://static.aecra.cn/cover/use-of-ajax-in-javascript.jpg","permalink":"https://aecra.github.io/article/use-of-ajax-in-javascript/","title":"JavaScript 中 AJAX 的使用"},{"content":"HTML 基础 文档声明 文档声明用来告诉浏览器当前网页的版本\n\u0026lt;!DOCTYPE html\u0026gt; 语言声明 声明在 html 根标签中\n\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/html\u0026gt; 实体 html 实体用来呈现特殊字符\n\u0026amp;nbsp; 空格 \u0026amp;gt; 大于号 \u0026amp;lt; 小于号 \u0026amp;copy; 版权符号 meta 标签 meta 主要用于设置网页中的一些元数据\n1.charset 指定网页的字符集 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 2.name 指定的数据的名称 content 指定的数据的内容 keywords 网站的关键字，多个关键字用,隔开 description 用于指定网站的描述 title标签的内容会作为搜索结果的超链接上的文字显示 \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;网购，电商\u0026#34; /\u0026gt; 3.http-equiv将页面重定向到另一个网站 \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;3;url=https://www.mozilla.org\u0026#34; /\u0026gt; 语义化标签 标签的名字表征了标签的用途\nh1-h6 标题 p 段落 em 加重 strong 强调 blockquote 长引用 q 短引用 br 换行 header 网页的头部 main 网页的主体部分 footer 网页的底部 nav 网页中的导航 aside 和主体相关的其他内容（侧边栏） article 一个独立的文章 section 表示一个独立的区块 div 没有语义 span 行内元素，无语义 列表 无序列表，使用ul标签来创建无序列表 使用li表示列表项 有序列表，使用ol标签来创建无序列表 使用li表示列表项 定义列表，使用dl标签来创建一个定义列表 使用dt来表示定义的内容 使用dd来对内容进行解释说明 列表之间可以互相嵌套 超链接 \u0026lt;a href=\u0026#34;https://www.baidu.com\u0026#34;\u0026gt;超链接\u0026lt;/a\u0026gt; target属性，用来指定超链接打开的位置 可选值： _self 默认值 在当前页面中打开超链接 _blank 在一个新的要么中打开超链接 可以直接将超链接的href属性设置为#，跳转到当前页面 将href属性设置 #目标元素的id属性值，可以跳转到页面的指定位置 图片标签 img这种元素属于替换元素（块和行内元素之间，具有两种元素的特点） 属性： src 属性指定的是外部图片的路径（路径规则和超链接是一样的） alt 图片的描述，这个描述默认情况下不会显示，有些浏览器在图片无法加载时显示，搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所收录 width 图片的宽度 (单位是像素) height 图片的高度 - 宽度和高度中如果只修改了一个，则另一个会等比例缩放 注意： 一般情况在pc端，不建议修改图片的大小，需要多大的图片就裁多大 但是在移动端，经常需要对图片进行缩放（大图缩小） 内联框架 内联框架，用于向当前页面中引入一个其他页面\nsrc 指定要引入的网页的路径\nframeborder 指定内联框架的边框(inline)\n\u0026lt;iframe src=\u0026#34;https://www.qq.com\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;600\u0026#34; frameborder=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 音视频 audio 标签用来向页面中引入一个音频文件\nvideo 标签用来向网页中引入一个视频文件\n属性\ncontrols 是否允许用户控制播放 autoplay 音频文件是否自动播放 loop 音乐是否循环播放 例子\n\u0026lt;audio src=\u0026#34;./source/audio.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;audio controls\u0026gt; \u0026lt;!-- 对不起，您的浏览器不支持播放音频！请升级浏览器！ --\u0026gt; \u0026lt;source src=\u0026#34;./source/audio.mp3\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;./source/audio.ogg\u0026#34; /\u0026gt; \u0026lt;embed src=\u0026#34;./source/audio.mp3\u0026#34; type=\u0026#34;audio/mp3\u0026#34; width=\u0026#34;300\u0026#34; height=\u0026#34;100\u0026#34; /\u0026gt; \u0026lt;/audio\u0026gt; 表格 \u0026lt;!-- 短表格 --\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;D1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C2\u0026lt;/td\u0026gt; \u0026lt;!-- rowspan 纵向的合并单元格 --\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;D2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;!-- 长表格 --\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;日期\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;收入\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;支出\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;合计\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2000.1.1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;500\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;200\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;300\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2000.1.1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;500\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;200\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;300\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;合计\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;300\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 注释 \u0026lt;!-- 这是注释 --\u0026gt; CSS 基础 层叠样式表，用来控制 HTML 展现样式\n使用方式 内联样式\n在标签内部通过 style 属性来设置元素的样式\n内部样式表\n将样式编写到 head 中的 style 标签里\n外部样式表\n将 CSS 样式编写到一个外部的 CSS 文件中通过 link 标签引入\n\u0026lt;p style=\u0026#34;color: red; font-size: 60px;\u0026#34;\u0026gt;今天天气真不错！\u0026lt;/p\u0026gt; \u0026lt;style\u0026gt; p { color: green; font-size: 50px; } \u0026lt;/style\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34; /\u0026gt; 语法 选择器，通过选择器可以选中页面中的指定元素\n比如 p 的作用就是选中页面中所有的 p 元素\n声明块，通过声明块来指定要为元素设置的样式\n声明块由一个一个的声明组成。声明是一个名值对结构。一个样式名对应一个样式值，名和值之间以:连接，以;结尾\np { color: red; font-size: 40px; } h1 { color: green; } 选择器 基本选择器 元素选择器\n标签名 { } id 选择器\n#id属性值 { } 类选择器\n.class属性值 { } 通配选择器\n* { } 复合选择器 交集选择器\n语法：选择器1选择器2选择器3选择器n{} 交集选择器中如果有元素选择器，必须使用元素选择器开头 选择器分组（并集选择器）\n语法：选择器1, 选择器2, 选择器3, 选择器n { } 关系选择器 父元素：直接包含子元素的元素叫做父元素\n子元素：直接被父元素包含的元素是子元素\n祖先元素：直接或间接包含后代元素的元素叫做祖先元素\n后代元素：直接或间接被祖先元素包含的元素叫做后代元素\n兄弟元素：拥有相同父元素的元素是兄弟元素\n子元素选择器\n语法：父元素 \u0026gt; 子元素 后代元素选择器\n语法：祖先 后代 选择下一个兄弟\n语法：前一个 + 下一个 选择下边所有的兄弟\n兄 ~ 弟 属性选择器 [属性名] 选择含有指定属性的元素 [属性名=属性值] 选择含有指定属性和属性值的元素 [属性名^=属性值] 选择属性值以指定值开头的元素 [属性名$=属性值] 选择属性值以指定值结尾的元素 [属性名*=属性值] 选择属性值中含有某值的元素的元素 伪类选择器 伪类用来描述一个元素的特殊状态\n比如：第一个子元素、被点击的元素、鼠标移入的元素\u0026hellip;\n:first-child 第一个子元素 :last-child 最后一个子元素 :only-child 没有任何兄弟元素的子元素 :nth-child() 选中第n个子元素 特殊值： n 第n个 n的范围0到正无穷 2n 或 even 表示选中偶数位的元素 2n+1 或 odd 表示选中奇数位的元素 - 以上这些伪类都是根据所有的子元素进行排序 :first-of-type :last-of-type :nth-of-type() :only-of-type :empty - 这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序 a 元素的伪类 :link 用来表示没访问过的链接（正常的链接） :visited 用来表示访问过的链接 :hover 用来表示鼠标移入的状态 :active 用来表示鼠标点击 伪元素选择器 伪元素：表示页面中一些特殊的并不真实的存在的元素（特殊的位置）\n::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 元素的开始 ::after 元素的最后 - before 和 after 必须结合content属性来使用 样式的继承 样式的继承，我们为一个元素设置的样式同时也会应用到它的后代元素上 利用继承我们可以将一些通用的样式统一设置到共同的祖先元素上， 这样只需设置一次即可让所有的元素都具有该样式 注意：并不是所有的样式都会被继承： 比如 背景相关的，布局相关等的这些样式都不会被继承。 选择器的权重 样式的冲突：当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。\n选择器的权重\n内联样式 1,0,0,0 id选择器 0,1,0,0 类和伪类选择器 0,0,1,0 元素选择器 0,0,0,1 通配选择器 0,0,0,0 继承的样式 没有优先级 可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式\n单位 像素 - 屏幕（显示器）实际上是由一个一个的小点点构成的 - 不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰 - 所以同样的200px在不同的设备下显示效果不一样 百分比 - 也可以将属性值设置为相对于其父元素属性的百分比 - 设置百分比可以使子元素跟随父元素的改变而改变 em - em是相对于元素的字体大小来计算的 - 1em = 1font-size - em会根据字体大小的改变而改变 rem - rem是相对于根元素的字体大小来计算 颜色 颜色名 red、orange、yellow、blue、green ... ... RGB值 - RGB通过三种颜色的不同浓度来调配出不同的颜色 - R red，G green ，B blue - 每一种颜色的范围在 0 - 255 (0% - 100%) 之间 - 语法：rgb(255, 0, 0) RGBA: - 就是在rgb的基础上增加了一个a表示不透明度 - 需要四个值，前三个和rgb一样，第四个表示不透明度 1表示完全不透明 0表示完全透明 .5半透明 - 语法：rgba(106,153,85,0.5) 十六进制的RGB值： - 颜色浓度通过 00-ff - 如果颜色两位两位重复可以进行简写 #aabbcc --\u0026gt; #abc - 语法：#红色绿色蓝色 HSL值 HSLA值 - H 色相(0 - 360) - S 饱和度，颜色的浓度 0% - 100% - L 亮度，颜色的亮度 0% - 100% - 语法：hsla(98, 48%, 40%, 0.658) 盒模型 文档流（normal flow） - 网页是一个多层的结构，一层摞着一层 - 通过CSS可以分别为每一层来设置样式 - 作为用户来讲只能看到最顶上一层 - 这些层中，最底下的一层称为文档流，文档流是网页的基础 我们所创建的元素默认都是在文档流中进行排列 - 对于我们来说元素主要有两个状态 在文档流中 不在文档流中（脱离文档流） - 元素在文档流中有什么特点： - 块元素 - 块元素会在页面中独占一行(自上向下垂直排列) - 默认宽度是父元素的全部（会把父元素撑满） - 默认高度是被内容撑开（子元素） - 行内元素 - 行内元素不会独占页面的一行，只占自身的大小 - 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素 则元素会换到第二行继续自左向右排列（书写习惯一致） - 行内元素的默认宽度和高度都是被内容撑开 盒模型示例 子元素溢出 如果子元素的大小超过了父元素，则子元素会从父元素中溢出 使用 overflow 属性来设置父元素如何处理溢出的子元素 (overflow-x、overflow-y) 可选值： visible 默认值 子元素会从父元素中溢出，在父元素外部的位置显示 hidden 溢出内容将会被裁剪不会显示 scroll 生成两个滚动条，通过滚动条来查看完整的内容 auto 根据需要生成滚动条 margin 的折叠 - 相邻的垂直方向外边距会发生重叠现象 - 兄弟元素 - 兄弟元素间的相邻垂直外边距会取两者之间的较大值（两者都是正值） - 特殊情况： 如果相邻的外边距一正一负，则取两者的和 如果相邻的外边距都是负值，则取两者中绝对值较大的 - 兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理 - 父子元素 - 父子元素间相邻外边距，子元素的会传递给父元素（上外边距） - 父子外边距的折叠会影响到页面的布局，必须要进行处理 行内元素的盒模型 行内元素的盒模型 - 行内元素不支持设置宽度和高度 - 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局 - 行内元素可以设置border，垂直方向的border不会影响页面的布局 - 行内元素可以设置margin，垂直方向的margin不会影响布局 盒模型类别 display 用来设置元素显示的类型\n可选值： inline 将元素设置为行内元素 block 将元素设置为块元素 inline-block 将元素设置为行内块元素 行内块，既可以设置宽度和高度又不会独占一行 table 将元素设置为一个表格 none 元素不在页面中显示 visibility 用来设置元素的显示状态 可选值： visible 默认值，元素在页面中正常显示 hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置 重置样式表 默认样式： - 通常情况，浏览器都会为元素设置一些默认样式 - 默认样式的存在会影响到页面的布局 重置样式表：专门用来对浏览器的样式进行重置的 reset.css 直接去除了浏览器的默认样式 normalize.css 对默认样式进行了统一 盒子的尺寸 默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定 box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用） 可选值： content-box 默认值，宽度和高度用来设置内容区的大小 border-box 宽度和高度用来设置整个盒子可见框的大小 width 和 height 指的是内容区 和 内边距 和 边框的总大小 轮廓和圆角 阴影\nbox-shadow 用来设置元素的阴影效果，阴影不会影响页面布局 第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动 第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动 第三个值 阴影的模糊半径 第四个值 阴影的颜色 轮廓线\noutline 用来设置元素的轮廓线，用法和border一模一样 轮廓和边框不同的点，就是轮廓不会影响到可见框的大小 圆角\nborder-radius 用来设置元素的圆角半径大小 浮动 简介 使用 float 属性来设置于元素的浮动 可选值： none 默认值 ，元素不浮动 left 元素向左浮动 right 元素向右浮动 注意：元素设置浮动以后，水平布局的等式便不需要强制成立 元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置， 所以元素下边的还在文档流中的元素会自动向上移动 浮动的特点： 1、浮动元素会完全脱离文档流，不再占据文档流中的位置 2、设置浮动以后元素会向父元素的左侧或右侧移动， 3、浮动元素默认不会从父元素中移出 4、浮动元素向左或向右移动时，不会超过它前边的其他浮动元素 5、如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移 6、浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是和它一样高 简单总结： 浮动目前来讲它的主要作用就是让页面中的元素可以水平排列， 通过浮动可以制作一些水平方向的布局 其他特点 浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围， 所以我们可以利用浮动来设置文字环绕图片的效果 脱离文档流的特点： 块元素： 1、块元素不在独占页面的一行 2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开 行内元素： 行内元素脱离文档流以后会变成块元素，特点和块元素一样 高度坍塌 在浮动布局中，父元素的高度默认是被子元素撑开的，\n当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离\n将会无法撑起父元素的高度，导致父元素的高度丢失\n父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱\nBFC BFC(Block formatting context)直译为\u0026quot;块级格式化上下文\u0026quot;。它是一个独立的渲染区域，只有 Block-level box 参与， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。\n特点\n独立的布局区域，将内外的布局分隔开 开启方式\n1、设置元素的浮动（不推荐） 2、将元素设置为行内块元素（不推荐） 3、将元素的overflow设置为一个非visible的值 - 常用的方式 为元素设置 overflow:hidden 开启其 BFC 以使其可以包含浮动元素 clear 如果我们不希望某个元素因为其他元素浮动的影响而改变位置，可以通过clear属性来清除浮动元素对当前元素所产生的影响 clear - 作用：清除浮动元素对当前元素所产生的影响 - 可选值： left 清除左侧浮动元素对当前元素的影响 right 清除右侧浮动元素对当前元素的影响 both 清除两侧中最大影响的那侧 原理： 设置清除浮动以后，浏览器会自动为元素添加一个上外边距， 以使其位置不受其他元素的影响 理想的解决方案 设置父元素的::after 伪类\n.box1::after { content: \u0026#39;\u0026#39;; clear: both; display: block; } clearfix /* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 */ .clearfix::before, .clearfix::after { content: \u0026#39;\u0026#39;; display: table; clear: both; } 定位 定位是一种更加高级的布局手段\n通过定位可以将元素摆放到页面的任意位置\n使用position属性来设置定位 可选值： static 默认值，元素是静止的没有开启定位 relative 开启元素的相对定位 absolute 开启元素的绝对定位 fixed 开启元素的固定定位 sticky 开启元素的粘滞定位 偏移量\n当元素开启了定位以后，可以通过偏移量来设置元素的位置 top - 定位元素和定位位置上边的距离 bottom - 定位元素和定位位置下边的距离 - 定位元素垂直方向的位置由top和bottom两个属性来控制 --------------------------------------------------------- left - 定位元素和定位位置的左侧距离 right - 定位元素和定位位置的右侧距离 - 定位元素水平方向的位置由left和right两个属性控制 相对定位 - 当元素的position属性值设置为relative时则开启了元素的相对定位 - 相对定位的特点： 1.元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化 2.相对定位是参照于元素在文档流中的位置进行定位的 3.相对定位会提升元素的层级 4.相对定位不会使元素脱离文档流 5.相对定位不会改变元素的性质块还是块，行内还是行内 绝对定位 - 当元素的position属性值设置为absolute时，则开启了元素的绝对定位 - 绝对定位的特点： 1.开启绝对定位后，如果不设置偏移量元素的位置不会发生变化 2.开启绝对定位后，元素会从文档流中脱离 3.绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开 4.绝对定位会使元素提升一个层级 5.绝对定位元素是相对于其包含块进行定位的 绝对定位的包含块: 包含块就是离它最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位则根元素就是它的包含块 固定定位 - 将元素的position属性设置为fixed则开启了元素的固定定位 - 固定定位也是一种绝对定位，所以固定定位的大部分特点都和绝对定位一样,唯一不同的是固定定位永远参照于浏览器的视口进行定位,固定定位的元素不会随网页的滚动条滚动 粘滞定位 - 当元素的position属性设置为sticky时则开启了元素的粘滞定位 - 粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置时将其固定 元素层级 对于开启了定位元素，可以通过z-index属性来指定元素的层级 z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示 如果元素的层级一样，则优先显示靠下的元素 祖先的元素的层级再高也不会盖住后代元素 字体 提供字体 font-face 可以将服务器中的字体直接提供给用户去使用\n@font-face { /* 指定字体的名字 */ font-family: \u0026#39;myfont\u0026#39;; /* 服务器中字体的路径 */ src: url(\u0026#39;./font/ZCOOLKuaiLe-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); } 字体样式 颜色（color）\ncolor: #fff; 字体大小（font-size）\n和font-size相关的单位 em 相当于当前元素的一个font-size rem 相对于根元素的一个font-size 字体族（font-family）\nserif 衬线字体 sans-serif 非衬线字体 monospace 等宽字体 - 指定字体的类别，浏览器会自动使用该类别下的字体 - font-family 可以同时指定多个字体，多个字体间使用,隔开 字体生效时优先使用第一个，第一个无法使用则使用第二个 以此类推 字重（font-weight）\n字体的加粗 可选值： normal 默认值 不加粗 bold 加粗 100-900 九个级别（没什么用） 字体的风格（font-style）\n可选值： normal 正常的 italic 斜体 图标字体 - 在网页中经常需要使用一些图标，可以通过图片来引入图标 但是图片大小本身比较大，并且非常的不灵活 - 所以在使用图标时，我们还可以将图标直接设置为字体， 然后通过font-face的形式来对字体进行引入 - 这样我们就可以通过使用字体的形式来使用图标 文本属性 行高（line-height）\n- 行高指的是文字占有的实际高度 - 可以通过line-height来设置行高 行高可以直接指定一个大小（px em） 也可以直接为行高设置一个整数 如果是一个整数的话，行高将会是字体的指定的倍数 - 行高经常还用来设置文字的行间距 行间距 = 行高 - 字体大小 水平对齐（text-align）\n可选值： left 左侧对齐 right 右对齐 center 居中对齐 justify 两端对齐 垂直对齐（ vertical-align）\n可选值： baseline 默认值 基线对齐 top 顶部对齐 bottom 底部对齐 middle 居中对齐 文本修饰（text-decoration）\n可选值： none 什么都没有 underline 下划线 line-through 删除线 overline 上划线 空白（white-space）\n可选值： normal 正常 nowrap 不换行 pre 保留空白 背景 背景颜色（background-color）\nbackground-color: #bfa; 背景图片 （background-image）\n- 可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色 - 如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满 - 如果背景的图片大于元素，将会一个部分背景无法完全显示 - 如果背景图片和元素一样大，则会直接正常显示 background-image: url(\u0026#34;./img/1.png\u0026#34;); 背景的重复（background-repeat）\n可选值： repeat 默认值 ， 背景会沿着x轴 y轴双方向重复 repeat-x 沿着x轴方向重复 repeat-y 沿着y轴方向重复 no-repeat 背景图片不重复 背景图片的位置（background-position）\n- 通过 top left right bottom center 几个表示方位的词来设置背景图片的位置 使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center - 通过偏移量来指定背景图片的位置 水平方向的偏移量 垂直方向变量 背景的范围（background-clip、background-origin）\nbackground-clip border-box 默认值，背景会出现在边框的下边 padding-box 背景不会出现在边框，只出现在内容区和内边距 content-box 背景只会出现在内容区 background-origin 背景图片的偏移量计算的原点 padding-box 默认值，background-position从内边距处开始计算 content-box 背景图片的偏移量从内容区处计算 border-box 背景图片的变量从边框处开始计算 背景图片的大小(background-size)\n第一个值表示宽度 第二个值表示高度 - 如果只写一个，则第二个值默认是 auto cover 图片的比例不变，将元素铺满 contain 图片比例不变，将图片在元素中完整显示 背景图片的固定（background-attachment）\nscroll 默认值。背景图像会随着页面其余部分的滚动而移动。 fixed 当页面的其余部分滚动时，背景图像不会移动。 渐变\n通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果 ！！渐变是图片，需要通过background-image来设置 线性渐变linear-gradient() 语法： linear-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区域 - 线性渐变的开头，我们可以指定一个渐变的方向 to left、to right、to bottom、to top、deg、turn - 渐变可以同时指定多个颜色，多个颜色默认情况下平均分布， 也可以手动指定渐变的分布情况 repeating-linear-gradient() 可以平铺的线性渐变 径向渐变radial-gradient() - 语法： radial-gradient(形状 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置) 形状： circle 圆形 ellipse 椭圆 closest-side 近边 closest-corner 近角 farthest-side 远边 farthest-corner 远角 位置： top right left center bottom 坐标 - 默认情况下径向渐变的形状根据元素的形状来计算的 - 我们也可以手动指定径向渐变的形状circle、ellipse 表单 在现实生活中表单用于提交数据\n在网页中也可以使用表单，网页中的表单用于将本地的数据提交给远程的服务器\n使用 form 标签来创建一个表单\n表单\n\u0026lt;form action=\u0026#34;target.html\u0026#34;\u0026gt; \u0026lt;!-- action 表单要提交的服务器的地址 method 表单提交的方式GET、POST --\u0026gt; \u0026lt;/form\u0026gt; 文本框\n\u0026lt;!-- 注意：数据要提交到服务器中，必须要为元素指定一个name属性值 autocomplete=\u0026#34;off\u0026#34; 关闭自动补全 readonly 将表单项设置为只读，数据会提交 disabled 将表单项设置为禁用，数据不会提交 autofocus 设置表单项自动获取焦点 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; /\u0026gt; 密码框\n\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt; 单选按钮\n\u0026lt;!-- - 像这种选择框，必须要指定一个value属性，value属性最终会作为用户的填写的值传递给服务器 - checked 可以将单选按钮设置为默认选中 --\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;hello\u0026#34; value=\u0026#34;a\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;hello\u0026#34; value=\u0026#34;b\u0026#34; checked /\u0026gt; 多选框\n\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;test\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;test\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;test\u0026#34; value=\u0026#34;3\u0026#34; checked /\u0026gt; 下拉列表\n\u0026lt;select name=\u0026#34;haha\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;i\u0026#34;\u0026gt;选项一\u0026lt;/option\u0026gt; \u0026lt;option selected value=\u0026#34;ii\u0026#34;\u0026gt;选项二\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;iii\u0026#34;\u0026gt;选项三\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 文件提交\n\u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;\u0026#34; /\u0026gt; 提交按钮\n\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;注册\u0026#34; /\u0026gt; 重置按钮\n\u0026lt;input type=\u0026#34;reset\u0026#34; /\u0026gt; 弹性盒模型 弹性盒模型\n","date":"2021-01-31T13:18:45Z","image":"https://static.aecra.cn/cover/html-css.jpg","permalink":"https://aecra.github.io/article/html-css/","title":"HTML + CSS"}]